#include "copyright.i"

!*******************************************************************************
!
! Module:  dihedrals_imp_mod
!
! Description:
!          CHARMM FORCE FIELD SUPPORT MODULE
!
! This is the CHARMM module which is used to provide
! support for the CHARMM force field within AMBER.
! This contains support for CHARMM specifics such as
! Urey-Bradley, CHARMM impropers and CMAP
!
! It is designed to be used with a special CHARMM prmtop
! file generated by chamber.
!
! Chamber Authors: Mike Crowley (NREL)
!                  Mark Williamson (SDSC)
!                  Ross Walker (SDSC)
!
! CHARMM Module Authors: Mark Williamson (SDSC)
!                        Ross Walker (SDSC)
!
! Date: Apr 2009.
!
!---------------------------------------------------------


!*******************************************************************************
!
! Module:  dihedrals_imp_mod
!
! Description: <TBS>
!              
!*******************************************************************************

module dihedrals_imp_mod

  use gbl_datatypes_mod

  implicit none

! The following are derived from prmtop dihedral info:

  integer, save                             :: cit_nimphi

  type(dihed_imp_rec), allocatable, save    :: cit_dihed_imp(:)

contains

!*******************************************************************************
!
! Subroutine:  dihedrals_imp_setup
!
! Description:  <TBS>
!
!*******************************************************************************

subroutine dihedrals_imp_setup(num_ints, num_reals, use_atm_map)

  use parallel_dat_mod
  use pmemd_lib_mod
  use prmtop_dat_mod

  implicit none

! Formal arguments:

  ! num_ints and num_reals are used to return allocation counts. Don't zero.

  integer, intent(in out)       :: num_ints, num_reals
  integer                       :: use_atm_map(natom)

! Local variables:

  integer               :: alloc_failed
  type(dihed_imp_rec)   :: diheds_imp_copy(nimphi)
  integer               :: atm_i, atm_j, atm_k, atm_l, diheds_imp_idx
  integer               :: my_dihed_imp_cnt

! This routine can handle reallocation, and thus can be called multiple
! times.

! Find all diheds for which this process owns either atom:

  my_dihed_imp_cnt = 0

  do diheds_imp_idx = 1, nimphi

    atm_i = gbl_dihed_imp(diheds_imp_idx)%atm_i
    atm_j = gbl_dihed_imp(diheds_imp_idx)%atm_j
    atm_k = gbl_dihed_imp(diheds_imp_idx)%atm_k
    atm_l = gbl_dihed_imp(diheds_imp_idx)%atm_l

#if defined(MPI) && !defined(CUDA)
    if (gbl_atm_owner_map(atm_i) .eq. mytaskid) then
      my_dihed_imp_cnt = my_dihed_imp_cnt + 1
      diheds_imp_copy(my_dihed_imp_cnt) = gbl_dihed_imp(diheds_imp_idx)
      use_atm_map(atm_i) = 1
      use_atm_map(atm_j) = 1
      use_atm_map(atm_k) = 1
      use_atm_map(atm_l) = 1
    else if (gbl_atm_owner_map(atm_j) .eq. mytaskid) then
      my_dihed_imp_cnt = my_dihed_imp_cnt + 1 
      diheds_imp_copy(my_dihed_imp_cnt) = gbl_dihed_imp(diheds_imp_idx)
      use_atm_map(atm_i) = 1
      use_atm_map(atm_j) = 1
      use_atm_map(atm_k) = 1
      use_atm_map(atm_l) = 1
    else if (gbl_atm_owner_map(atm_k) .eq. mytaskid) then
      my_dihed_imp_cnt = my_dihed_imp_cnt + 1
      diheds_imp_copy(my_dihed_imp_cnt) = gbl_dihed_imp(diheds_imp_idx)
      use_atm_map(atm_i) = 1
      use_atm_map(atm_j) = 1
      use_atm_map(atm_k) = 1
      use_atm_map(atm_l) = 1
    else if (gbl_atm_owner_map(atm_l) .eq. mytaskid) then
      my_dihed_imp_cnt = my_dihed_imp_cnt + 1
      diheds_imp_copy(my_dihed_imp_cnt) = gbl_dihed_imp(diheds_imp_idx)
      use_atm_map(atm_i) = 1
      use_atm_map(atm_j) = 1
      use_atm_map(atm_k) = 1
      use_atm_map(atm_l) = 1
    end if
#else
    my_dihed_imp_cnt = my_dihed_imp_cnt + 1
    diheds_imp_copy(my_dihed_imp_cnt) = gbl_dihed_imp(diheds_imp_idx)

    use_atm_map(atm_i) = 1
    use_atm_map(atm_j) = 1
    use_atm_map(atm_k) = 1
    use_atm_map(atm_l) = 1
#endif

  end do

  cit_nimphi = my_dihed_imp_cnt

  if (my_dihed_imp_cnt .gt. 0) then
    if (allocated(cit_dihed_imp)) then
      if (size(cit_dihed_imp) .lt. my_dihed_imp_cnt) then
        num_ints = num_ints - size(cit_dihed_imp) * dihed_imp_rec_ints
        deallocate(cit_dihed_imp)
        allocate(cit_dihed_imp(my_dihed_imp_cnt), stat = alloc_failed)
        if (alloc_failed .ne. 0) call setup_alloc_error
        num_ints = num_ints + size(cit_dihed_imp) * dihed_imp_rec_ints
      end if
    else
      allocate(cit_dihed_imp(my_dihed_imp_cnt), stat = alloc_failed)
      if (alloc_failed .ne. 0) call setup_alloc_error
      num_ints = num_ints + size(cit_dihed_imp) * dihed_imp_rec_ints
    end if
    cit_dihed_imp(1:my_dihed_imp_cnt) = diheds_imp_copy(1:my_dihed_imp_cnt)
  end if

#ifdef CUDA
  call gpu_dihedrals_imp_setup(my_dihed_imp_cnt, cit_dihed_imp, gbl_imp_pk, gbl_imp_phase); 
#endif
 
  return

end subroutine dihedrals_imp_setup

!*******************************************************************************
!
! Subroutine:  get_dihed_energy
!
! Description: <TBS>
!              
!*******************************************************************************

subroutine get_dihed_imp_energy(dihed_imp_cnt, dihed_imp, x, frc, ep)
  ! Calculates CHARMM improper torsion terms.
  ! E=K(w-weq)^2
  !
  !    l
  !    |
  !    i
  !   / \
  !  k   j
  !
  ! Where W is the angle between the plane ijk and jkl.

  !use constants, only : RAD_TO_DEG, DEG_TO_RAD

  use gbl_constants_mod
  use mdin_ctrl_dat_mod
  use parallel_dat_mod
  use prmtop_dat_mod
  use charmm_mod, only : AM_VAL_GEOM_torsion

  implicit none

! Formal arguments:

  integer,             intent(in)     :: dihed_imp_cnt
  type(dihed_imp_rec), intent(in)     :: dihed_imp(*)
  double precision,    intent(in)     :: x(3, *)
  double precision,    intent(inout)  :: frc(3, *)
  double precision,    intent(inout)  :: ep


! Local
  double precision :: crd_ijkl(12),gradphi_ijkl(12),cosphi,sinphi
  double precision :: phi,function_val
  integer          :: m, jn, ic
  integer          :: i, j, k, l
  double precision :: epw, epl

  epl = 0.d0

  do jn = 1, dihed_imp_cnt

    i = dihed_imp(jn)%atm_i
    j = dihed_imp(jn)%atm_j
    k = dihed_imp(jn)%atm_k
    l = dihed_imp(jn)%atm_l

    do m = 1,3 !First loop assign x, second assign y, and finally z
      crd_ijkl(m)   = x(m, i)
      crd_ijkl(m+3) = x(m, j)
      crd_ijkl(m+6) = x(m, k)
      crd_ijkl(m+9) = x(m, l)
    enddo

    call AM_VAL_GEOM_torsion(crd_ijkl,gradphi_ijkl,cosphi,sinphi)

    ! Calculate the improper energy and add it to the AMBER dihedral
    ! energy term.
    !Note - when calculating phi acos only returns values between 0 and 180 degrees (in radians)
    !       but if cosphi is 0.5d0 for example then phi could be -90 or +90 and we need to know
    !       this when calculating the derviatives. However, a solution is given since we also
    !       know sinphi - hence if cosphi is 0.5 and sinphi is 0.5 then phi is +90 degrees.
    !       However, if cosphi is 0.5 and sinphi is -0.5 then phi is -90 degrees.
    ! We need protection here to deal with the situation where ACOS has a singularity.
    phi = sign(acos(cosphi),sinphi)

    ic = dihed_imp(jn)%parm_idx

    epw =(gbl_imp_pk(ic) * (phi - gbl_imp_phase(ic))**2)

  ! Now add the force to the main force array.
  ! Remember, force is the negative of the gradient
    function_val  = -2.0d0 * gbl_imp_pk(ic) * ( phi - gbl_imp_phase(ic))

#ifdef MPI
! We use atm_i to determine who sums up the energy...
    if (gbl_atm_owner_map(i) .eq. mytaskid) then
      epl = epl  + epw
      do m = 1,3
        frc(m, i) = frc(m, i) + (gradphi_ijkl(m)   * function_val)
      enddo
    end if

    if (gbl_atm_owner_map(j) .eq. mytaskid) then
      do m = 1,3
        frc(m, j) = frc(m, j) + (gradphi_ijkl(m+3) * function_val)
      enddo
    end if

    if (gbl_atm_owner_map(k) .eq. mytaskid) then
      do m = 1,3
        frc(m, k) = frc(m, k) + (gradphi_ijkl(m+6) * function_val)
      enddo
    end if

    if (gbl_atm_owner_map(l) .eq. mytaskid) then
      do m = 1,3
        frc(m, l) = frc(m, l) + (gradphi_ijkl(m+9) * function_val)
      enddo
    end if
#else

    do m = 1,3
      frc(m, i) = frc(m, i) + (gradphi_ijkl(m)   * function_val)
      frc(m, j) = frc(m, j) + (gradphi_ijkl(m+3) * function_val)
      frc(m, k) = frc(m, k) + (gradphi_ijkl(m+6) * function_val)
      frc(m, l) = frc(m, l) + (gradphi_ijkl(m+9) * function_val)
    end do

   epl = epl + epw
#endif

!DEBUGGING
!        write(6,'(10x,a,i1)'),"Mytaskid ",mytaskid
!        write(6,'(10x,a,i1)'),"Improper ",jn
!        write(6,'(10x,a,i5,i5,i5,i5)'),"Atoms: ",i,j,k,l
!        write(6,'( 10x,a)'),"coordinates"
!        write(6,'( 10x,a1,3(f10.6,x) )'),"i",crd_ijkl(1:3)
!        write(6,'( 10x,a1,3(f10.6,x) )'),"j",crd_ijkl(4:6)
!        write(6,'( 10x,a1,3(f10.6,x) )'),"k",crd_ijkl(7:9)
!        write(6,'( 10x,a1,3(f10.6,x) )'),"l",crd_ijkl(10:12)
!        write(6,'(a)'),""
!        write(6,'( 10x,a10,f8.3 )'),"Angle: ",phi
!        write(6,'(a)'),""
!        write(6,'( 10x,a10,f8.3 )'),"Energy: ",epl
!        write(6,'( 10x,a20,f8.3 )'),"Function value ",function_val
!        write(6,'(a)'),""
!        write(6,'( 10x,a6,3(f10.6,x) )'),"grad_i",gradphi_ijkl(1:3)
!        write(6,'( 10x,a6,3(f10.6,x) )'),"grad_j",gradphi_ijkl(4:6)
!        write(6,'( 10x,a6,3(f10.6,x) )'),"grad_k",gradphi_ijkl(7:9)
!        write(6,'( 10x,a6,3(f10.6,x) )'),"grad_l",gradphi_ijkl(10:12)
!        write(6,'(a)'),""
!        write(6,'(a)'),""
  end do

  ep = epl

  return
end subroutine get_dihed_imp_energy

end module dihedrals_imp_mod
