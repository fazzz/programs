#include "copyright.i"

!*******************************************************************************
!
! Module:  charmm_mod
!
! Description:
!          CHARMM FORCE FIELD SUPPORT MODULE
!
! This is the CHARMM module which is used to provide
! support for the CHARMM force field within AMBER.
! This contains support for CHARMM specifics such as
! Urey-Bradley, CHARMM impropers and CMAP
!
! It is designed to be used with a special CHARMM prmtop
! file generated by chamber.
!
! Chamber Authors: Mike Crowley (NREL)
!                  Mark Williamson (SDSC)
!                  Ross Walker (SDSC)
!
! CHARMM Module Authors: Mark Williamson (SDSC)
!                        Ross Walker (SDSC)
!
! Date: Apr 2009.
!
!---------------------------------------------------------

!
!*******************************************************************************

module charmm_mod

  implicit none

  private

!--------------- Public variables and subroutines -----------
  !Variables
  public :: charmm_active
  public :: AM_VAL_GEOM_torsion

  !Subroutines
  public :: check_for_charmm
!------------- End Public variables and subroutines ---------

!------------------------------------------------------------
! VARIABLES AND DERIVED DATA TYPES
!------------------------------------------------------------
  ! Do we have reason to be?
  logical,save :: charmm_active


!------------------------------------------------------------
! END VARIABLES AND DERIVED DATA TYPES
!------------------------------------------------------------

contains

!------------------------------------------------------------
! SUBROUTINES
!------------------------------------------------------------

!*******************************************************************************
!
! Subroutine:  check_for_charmm
!
! Description:
! This subroutine is responsible for checking the prmtop file
! contains the charmm force field and if it does it sets
! charmm_active to .true.
!
!*******************************************************************************
subroutine check_for_charmm(nlines,ffdesc)

  use file_io_dat_mod, only : mdout
  use pmemd_lib_mod, only : mexit

  implicit none

!Passed in
  integer, intent(in) :: nlines
  character(len=80), intent(in) :: ffdesc(nlines)

!Local
  integer :: i

  charmm_active = .false.
  do i = 1, nlines
    if (index(ffdesc(i),'CHARMM') /= 0) then
      write(mdout,'("|")')
      write(mdout,'(a,a)') '|CHARMM: CHARMM force field in use. '
      charmm_active = .true.
    end if
  end do

  return

end subroutine check_for_charmm

!*******************************************************************************
!
! Subroutine: AM_VAL_GEOM_torsion
!
! Description:
! Routine to calculate generic angle and partial deriv between 4 points that make
! up two planes.
!
!*******************************************************************************
subroutine AM_VAL_GEOM_torsion(crd_abcd,gradphi_abcd,cosphi,sinphi)

! This routine is from Darden's generic torsion
! code in AM_VAL_GEOM_torsion in amoeba_valence.f
! Optimized by Ross Walker

  implicit none
  double precision, intent(in) :: crd_abcd(12)
  double precision, intent(out) :: gradphi_abcd(12),cosphi,sinphi
! given coords of points a,b,c,d this routine calculates
! cosine and sine of torsion phi
! as well as gradient of phi with respect to coords of a,b,c,d
! units are in radians

  double precision :: rab(3),rcb(3),rdc(3),ucb(3),upab(3),updc(3),rcross(3), &
         upabc(3),upbcd(3),onesizcb,dotp_ab_cb,onesizpab,dotp_dc_cb, &
         onesizpdc,vecS(3),dot,cosphi_pre,sinphi_pre
  integer :: m
  do m = 1,3
    rab(m) = crd_abcd(m) -   crd_abcd(m+3)
    rcb(m) = crd_abcd(m+6) - crd_abcd(m+3)
    rdc(m) = crd_abcd(m+9) - crd_abcd(m+6)
  enddo

  onesizcb = 1.0d0/sqrt(rcb(1)*rcb(1)+rcb(2)*rcb(2)+rcb(3)*rcb(3))
  ucb(1:3) = rcb(1:3)*onesizcb
  dotp_ab_cb = rab(1)*ucb(1)+rab(2)*ucb(2)+rab(3)*ucb(3)
! upab is unit vector along component rab perp to ucb
  dot = rab(1)*ucb(1)+rab(2)*ucb(2)+rab(3)*ucb(3)
  upab(1:3) = rab(1:3) - dot*ucb(1:3)
  onesizpab = 1.0d0/sqrt(upab(1)*upab(1)+upab(2)*upab(2)+upab(3)*upab(3))
  upab(1:3) = upab(1:3) * onesizpab
  dotp_dc_cb = rdc(1)*ucb(1)+rdc(2)*ucb(2)+rdc(3)*ucb(3)
! updc is unit vector along component rdc perp to ucb
  dot = rdc(1)*ucb(1)+rdc(2)*ucb(2)+rdc(3)*ucb(3)
  updc(1:3) = rdc(1:3) - dot*ucb(1:3)
  onesizpdc = 1.0d0/sqrt(updc(1)*updc(1)+updc(2)*updc(2)+updc(3)*updc(3))
  updc(1:3) = updc(1:3) * onesizpdc
! cosine of phi is given by dot product of upab and updc

! cosphi must be returned in the range -1.d0 to 1.d0
! small rounding issues in the 16th decimal place of the
! folloing sum can cause this value to lie outside of this range
! by 1E-16 when:
!  upab(1) = updc(1) and upab(2) = updc(2) and upab(3) = updc(3)

  cosphi_pre = upab(1)*updc(1)+upab(2)*updc(2)+upab(3)*updc(3)
  cosphi = min( max(cosphi_pre, -1.d0), 1.d0)

! sine of phi is given by dot product of ucb and upab x updc
  rcross(1) = upab(2)*updc(3) - upab(3)*updc(2)
  rcross(2) = upab(3)*updc(1) - upab(1)*updc(3)
  rcross(3) = upab(1)*updc(2) - upab(2)*updc(1)

!See note above of cosphi_pre
  sinphi_pre = rcross(1)*ucb(1)+rcross(2)*ucb(2)+rcross(3)*ucb(3)
  sinphi = min( max(sinphi_pre, -1.d0), 1.d0)

! gradient of phi wrt ra is perp to abc plane---movement of ra by dr perp
! to abc plane results in dphi of dr/sizpab
! perp to abc given by upab x ucb  (these are orthogonal unit vectors)
  upabc(1) = upab(2)*ucb(3) - upab(3)*ucb(2)
  upabc(2) = upab(3)*ucb(1) - upab(1)*ucb(3)
  upabc(3) = upab(1)*ucb(2) - upab(2)*ucb(1)
! grad of phi wrt rd is perp to bcd plane--calc sim to grad phi wrt ra
! perp given by updc x ucb or ucb x updc
  upbcd(1) = ucb(2)*updc(3) - ucb(3)*updc(2)
  upbcd(2) = ucb(3)*updc(1) - ucb(1)*updc(3)
  upbcd(3) = ucb(1)*updc(2) - ucb(2)*updc(1)
! now have enough for gradphi for a and d
  do m = 1,3
    gradphi_abcd(m) = upabc(m) * onesizpab
    gradphi_abcd(9+m) = upbcd(m) * onesizpdc
  enddo
! following chap 5 of thesis of Bekker we have grad phi wrt b = -grad phi wrt a
! plus some vec S and rad phi wrt c = -grad phi wrt d - S
! S is perp to rcb; using simple torque rule and identity for
! triple cross product he derives S (eqn 5.20)
  do m = 1,3
    vecS(m) = (dotp_ab_cb*onesizcb)*gradphi_abcd(m) + &
           (dotp_dc_cb*onesizcb)*gradphi_abcd(m+9)
    gradphi_abcd(m+3) = vecS(m) - gradphi_abcd(m)
    gradphi_abcd(m+6) = -vecS(m) - gradphi_abcd(m+9)
  enddo
end subroutine AM_VAL_GEOM_torsion




!------------------------------------------------------------
! END SUBROUTINES
!------------------------------------------------------------


end module charmm_mod
