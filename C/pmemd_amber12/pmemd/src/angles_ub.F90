#include "copyright.i"
!*******************************************************************************
!
! Module:  angles_ub_mod
!
! Description:
!          CHARMM FORCE FIELD SUPPORT MODULE
!
! This is the CHARMM module which is used to provide
! support for the CHARMM force field within AMBER.
! This contains support for CHARMM specifics such as
! Urey-Bradley, CHARMM impropers and CMAP
!
! It is designed to be used with a special CHARMM prmtop
! file generated by chamber.
!
! Chamber Authors: Mike Crowley (NREL)
!                  Mark Williamson (SDSC)
!                  Ross Walker (SDSC)
!
! CHARMM Module Authors: Mark Williamson (SDSC)
!                        Ross Walker (SDSC)
!
! Date: Apr 2009.
!
!---------------------------------------------------------

!*******************************************************************************
!
! Module:  angles_ub_mod
!
! Description: Routines related to the calculations of Urey Bradley terms
!              
!*******************************************************************************

module angles_ub_mod

  use gbl_datatypes_mod

  implicit none

! The following are derived from prmtop angle info:

  integer, save                            :: cit_nthet_ub !=cit_ntheth + cit_ntheta

  type(angle_ub_rec), allocatable, save    :: cit_angle_ub(:)

contains

!*******************************************************************************
!
! Subroutine:  angles_ub_setup
!
! Description:  <TBS>
!
!*******************************************************************************

subroutine angles_ub_setup(num_ints, num_reals, use_atm_map)

  use parallel_dat_mod
  use pmemd_lib_mod
  use prmtop_dat_mod

  implicit none

! Formal arguments:

  ! num_ints and num_reals are used to return allocation counts. Don't zero.

  integer, intent(in out)       :: num_ints, num_reals
  integer                       :: use_atm_map(natom)

! Local variables:

  integer               :: alloc_failed
  type(angle_ub_rec)    :: angles_ub_copy(nub)
  integer               :: atm_i, atm_k, angles_ub_idx
  integer               :: my_angle_ub_cnt

! This routine can handle reallocation, and thus can be called multiple
! times.

! Find all ub_angles for which this process owns either atom:

  my_angle_ub_cnt = 0

  do angles_ub_idx = 1, nub

    atm_i = gbl_angle_ub(angles_ub_idx)%atm_i
    atm_k = gbl_angle_ub(angles_ub_idx)%atm_k

#if defined(MPI) && !defined(CUDA)
    if (gbl_atm_owner_map(atm_i) .eq. mytaskid) then
      my_angle_ub_cnt = my_angle_ub_cnt + 1
      angles_ub_copy(my_angle_ub_cnt) = gbl_angle_ub(angles_ub_idx) !Local copy angle_ub object
      use_atm_map(atm_i) = 1
      use_atm_map(atm_k) = 1

    else if (gbl_atm_owner_map(atm_k) .eq. mytaskid) then
      my_angle_ub_cnt = my_angle_ub_cnt + 1
      angles_ub_copy(my_angle_ub_cnt) = gbl_angle_ub(angles_ub_idx)
      use_atm_map(atm_i) = 1
      use_atm_map(atm_k) = 1
    end if
#else
    my_angle_ub_cnt = my_angle_ub_cnt + 1
    angles_ub_copy(my_angle_ub_cnt) = gbl_angle_ub(angles_ub_idx)
    use_atm_map(atm_i) = 1
    use_atm_map(atm_k) = 1
#endif

  end do

  cit_nthet_ub = my_angle_ub_cnt

  if (my_angle_ub_cnt .gt. 0) then
    if (allocated(cit_angle_ub)) then
      if (size(cit_angle_ub) .lt. my_angle_ub_cnt) then
        num_ints = num_ints - size(cit_angle_ub) * angle_ub_rec_ints
        deallocate(cit_angle_ub)
        allocate(cit_angle_ub(my_angle_ub_cnt), stat = alloc_failed)
        if (alloc_failed .ne. 0) call setup_alloc_error
        num_ints = num_ints + size(cit_angle_ub) * angle_ub_rec_ints
      end if
    else
      allocate(cit_angle_ub(my_angle_ub_cnt), stat = alloc_failed)
      if (alloc_failed .ne. 0) call setup_alloc_error
      num_ints = num_ints + size(cit_angle_ub) * angle_ub_rec_ints
    end if
    cit_angle_ub(1:my_angle_ub_cnt) = angles_ub_copy(1:my_angle_ub_cnt)
  end if

#ifdef CUDA
  call gpu_angles_ub_setup(my_angle_ub_cnt, cit_angle_ub, gbl_ub_r0, gbl_ub_rk)
#endif

  return

end subroutine angles_ub_setup

!*******************************************************************************
!
! Subroutine:  get_ub_angle_energy
!
! Description:  Routine to get the bond energies and forces for potentials of
!               the type ct*(t-t0)**2.
!
!*******************************************************************************

subroutine get_angle_ub_energy(angle_ub_cnt, angle_ub, x, frc, angle_ub_energy)

  use nmr_calls_mod
  use parallel_dat_mod
  use prmtop_dat_mod

  implicit none

! Formal arguments:

  integer,           intent(in)   :: angle_ub_cnt
  type(angle_ub_rec),intent(in)   :: angle_ub(*)
  double precision,  intent(in)   :: x(3, *)
  double precision,  intent(inout):: frc(3, *)
  double precision,  intent(out)  :: angle_ub_energy

! Local variables:

  double precision      :: da
  double precision      :: df
  double precision      :: dfw
  integer               :: i, k, ic, jn
  double precision      :: lcl_angle_ub_energy
  double precision      :: xa, ya, za
  double precision      :: rik
  double precision      :: xik, yik, zik

  lcl_angle_ub_energy = 0.0d0

! Grand loop for the bond stuff:

  do jn = 1, angle_ub_cnt
    i =  angle_ub(jn)%atm_i
    k =  angle_ub(jn)%atm_k
    ic = angle_ub(jn)%parm_idx

! Calculation of the bond vector:

    xik = x(1, i) - x(1, k)
    yik = x(2, i) - x(2, k)
    zik = x(3, i) - x(3, k)

    rik = sqrt(xik * xik + yik * yik + zik * zik)

! Calculation of the energy and deriv:

    da = rik - gbl_ub_r0(ic)

#ifdef MPI
! If ebdev is ever supported under mpi, you will need to treat it like the
! energy...
#else
    ebdev = ebdev + da * da ! For rms deviation from ideal bonds:
#endif

    df =       gbl_ub_rk(ic)*da
    dfw = (df + df) / rik !TODO Optimize

!DEBUGGING
!#ifdef MPI
!     write(mdout,*) "mytaskid is  :",mytaskid
!#endif
!
!     write(mdout,*) "jn is  :",jn
!     write(mdout,*) "i is  :",x(1,i),x(2,i),x(3,i)
!     write(mdout,*) "k is  :",x(1,k),x(2,k),x(3,k)
!     write(mdout,*) "rik is  :",rik
!     write(mdout,*) "ic is  :",ic
!     write(mdout,*) "gbl_ub_r0(ic) is  :",gbl_ub_r0(ic)
!     write(mdout,*) "da is :",da
!     write(mdout,*) "gbl_ub_rk(ic) is  :",gbl_ub_rk(ic)
!     write(mdout,*) "df is :",df
!     write(mdout,*) "ebw(jn) is :", df*da
!     write(mdout,*) ""
!#endif


! Calculation of the force:

    xa = dfw * xik
    ya = dfw * yik
    za = dfw * zik

#ifdef MPI
    ! We use atm_i to determine who sums up the energy...
    if (gbl_atm_owner_map(i) .eq. mytaskid) then
      lcl_angle_ub_energy = lcl_angle_ub_energy + df * da
      frc(1, i) = frc(1, i) - xa
      frc(2, i) = frc(2, i) - ya
      frc(3, i) = frc(3, i) - za
    end if

    if (gbl_atm_owner_map(k) .eq. mytaskid) then
      frc(1, k) = frc(1, k) + xa
      frc(2, k) = frc(2, k) + ya
      frc(3, k) = frc(3, k) + za
    end if
#else
      lcl_angle_ub_energy = lcl_angle_ub_energy + df * da
      frc(1, i) = frc(1, i) - xa
      frc(2, i) = frc(2, i) - ya
      frc(3, i) = frc(3, i) - za
      frc(1, k) = frc(1, k) + xa
      frc(2, k) = frc(2, k) + ya
      frc(3, k) = frc(3, k) + za
#endif

  end do

  angle_ub_energy = lcl_angle_ub_energy


  return

end subroutine get_angle_ub_energy

end module angles_ub_mod
