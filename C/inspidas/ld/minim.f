C***********************************************************************
      SUBROUTINE MINIM
C***********************************************************************
C        MAIN SUBROUTINE FOR MINIMIZATION
C**********************************************************************
C*                                                                    *
C* <<REGULARIZATION OF PDB DATA FOR FEDER PROGRAM>>                   *
C*                                                                    *
C*    CONFORMATIONAL ENERGY MINIMIZATION WITH DISTANCE CONSTRAINTS    *
C*      * DISTANCE CONSTRAINTS ARE GIVEN FROM ATOMIC COORDINATES      *
C*      * ALL INTERACTABLE ATOM PAIRS ARE CONSIDERED IN               *
C*        CONFORMATIONAL ENERGY CALCULTION                            *
C*                                                                    *
C*        VERSION     1.0                  (DEC  1986)                *
C*        VERSION     2.0                  (AUG  1987)                *
C*                                                                    *
C**********************************************************************
C*       <INPUT FILES>
C*
C*     31:    PRECEP OUTPUT DATA
C*     33:    ENERGY PARAMETERS
C*     35:    INITIAL ANGLES IN UNITS OF DEGREES (FORMATTED)
C*     37:    INITIAL ANGLES IN UNITS OF RADIANS (UNFORMATTED)
C*              (RESTART FILE )
C*    --------------------------------------------------------------
C*       <OUTPUT FILES>
C*     32:    FINAL ANGLES (FORMATTED)
C*     34:    FLEXS FORMATTED DATA (ANGLES AND COORDINATES)
C*     36:    FIRST AND SECOND DERIVATIVE (UNFORMATTED)
C*     38:    FINAL COORDINATES AND ANGLES (FORMATTED)
C*     39:    FINAL COORDINATES (UNFORMATTED)
C*     40:    FINAL ANGLES IN UNITS OF RADIANS (UNFORMATTED)
C*              (RESTART FILE )
C*                OPERAND   SHR   IS NECESSARY IN >>FILE.
C*                USED FOR CONTINUATION TO THE NEXT JOB, IF
C*                CONVERGENCE IS NOT ATTAINED IN THIS JOB.
C***********************************************************************
C
C     PLEASE CHECK THE FOLLOWING PARAMETERS IN PARAMETER STATEMENTS ON
C     WHETHER SUITABLE VALUES ARE ASSIGNED TO THEM, BEFORE YOU RUN THIS
C     PROGRAM.
C
C          MAXVAR, MAXRES, MAXATM, MAXLEN, MAXSS, MAXINT, MAXPER
C
C     IN THE SUBROUTINES;  INPUTA, CRDREF, PAIR14, CRCRNT, GENRA,
C        DRVTVA, DRVTVX, DRVTVZ, ENRGYA, ENRGYX, ENRGYZ, ECALX, ECALZ,
C        DCALA, DCALX, DCALZ
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4 (I-N)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (COMMAND)
      INCLUDE 'inc/command'
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
CMSP  INCLUDE (FILEIO)
      INCLUDE 'inc/fileio'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (ALPHA)
      INCLUDE 'inc/alpha'
CMSP  INCLUDE (ATOM)
      INCLUDE 'inc/atom'
CMSP  INCLUDE (BOND)
      INCLUDE 'inc/bond'
CMSP  INCLUDE (CHARGE)
      INCLUDE 'inc/charge'
CMSP  INCLUDE (COORD)
      INCLUDE 'inc/coord'
CMSP  INCLUDE (REFRNC)
      INCLUDE 'inc/refrnc'
CMSP  INCLUDE (SSPAIR)
      INCLUDE 'inc/sspair'
CMSP  INCLUDE (TORSN0)
      INCLUDE 'inc/torsn0'
CMSP  INCLUDE (VARANG)
      INCLUDE 'inc/varang'
CMSP  INCLUDE (FMATRIX)
      INCLUDE 'inc/fmatrix'
C     CHARACTER  ATNAME*4,RENAME*4,TITLE1*80
      CHARACTER  TITLE1*80
      REAL*4  TLIMIT
      CHARACTER*4 SUBTAS,NXTWD
      CHARACTER*20 FORMA
      CHARACTER*80 NAME
C     PARAMETER  (MAXATM=3000,MAXVAR=800,MAXRES=150)
C     PARAMETER  (MXATM1=MAXATM+1)
C     PARAMETER  (MXPAIR=MAXVAR*(MAXVAR+1)/2)
C     PARAMETER  (MXPAR1=(MAXVAR+1)*(MAXVAR+2)/2)
C     PARAMETER  (MAXSS =5,MAXSS2=2*MAXSS)
      PARAMETER  (PI=3.141 592 653 589 793D0,RAD=PI/180.D0)
      PARAMETER  (HALFPI=PI/2.)
      EXTERNAL  ENRGYA,DRVTVA,ENRGYX,DRVTVX,ENRGYZ,DRVTVZ
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/ALPH1/   ATNAME(MAXATM),RENAME(MAXATM)
C     COMMON/ALPH2/   NMBRES(MAXATM)
C     COMMON/ATOM00/  KUNIT(MAXATM),KATOM(MXATM1),JATOM(MAXATM)
C     COMMON/BOND01/  IBCHAR(3,MAXVAR)
C     COMMON/CHARGE/  CHARGE(MAXATM)
C     COMMON/COORD/   CO(3,MAXATM)
      COMMON/CCTIME/   ITIME,TLIMIT,LOUT,ITRS,LAMBDA,IREST
      COMMON/ENE001/  ERRR,WVLTN
      COMMON/ENE002/  COX(3,MAXATM),NFLAG(MAXATM)
      COMMON/RANGE/   KRANGE
C     COMMON/REFRNC/  REFCRD(3,MAXATM),REFANG(MAXVAR)
C     COMMON/SSPAIR/  KSSPER(6,2,MAXSS),JSS(3,MAXSS),KSS(MAXSS2),
C    &                LSS(MAXSS2)
      COMMON/TABLE4/  KMAX,LISTK(-1:MAXVAR),JANGLE(MXPAIR),
     &                KANGLE(0:MXPAR1)
      COMMON/TITLE1/  TITLE1
C     COMMON/TORSN0/  A(MAXVAR),NB(MAXVAR),NS(MAXVAR),IFTOR(MAXVAR)
C     COMMON/VARANG/  ANGLES(10,MAXRES),INDXV(MAXVAR)
C     DIMENSION  VAR(MAXVAR),DF(MAXVAR),G(MXPAIR),G0(MXPAIR)
C     DIMENSION  DF(MAXVAR),G(MXPAIR),G0(MXPAIR)
      DIMENSION  WORK1(MAXVAR),WORK2(MAXVAR),WORK3(MAXVAR),WORK4(MAXVAR)
      DIMENSION  IWRK1(MAXVAR),IWRK2(MAXVAR)
      DIMENSION  WORK6(4,MAXRES)
      DIMENSION  LRANGE(100),WVLTN0(100),LFUNC0(100),NITRTN(100)
      DIMENSION  CONV0(100),LOMEGA(100)
      DIMENSION  COWRK(3,MAXATM),LFLAG(MAXATM)
C     DATA  IREAD/20/,KREAD/22/,MREAD/63/
C     DATA  KWRITE/3/, ISF/2/
      DATA  ISF/2/
C  DEFAULT VALUES OF CONTROL PARAMETERS
      TLIMIT=600.
      LOUT=50
      NUMRNG=1
      LRANGE(1)=400
      WVLTN0(1)=0.0
      LFUNC0(1)=-1
      NITRTN(1)=200
      CONV0(1)=1.D-12
      LOMEGA(1)=0
CKM  INITIALIZATION OF ITTERATION NUMBER (?)
      II = 1
CKM  INTIALIZATION OF RESTART FLAG
      IREST=0
C
C     *** GET SUBTASK
C
  999 CONTINUE
      CALL NXTCMN(SUBTAS)
      WRITE(IOUT02,5) SUBTAS
      WRITE(IOUT06,5) SUBTAS
    5 FORMAT(/5X,' NEXT SUBTASK : ',A4,/)
      IF (SUBTAS.EQ.'QUIT') GOTO 990
C
C-----------R E A D  I N   C O N T R O L   P A R A M E T E R S --------
C
C   TLIMIT     CPU TIME LIMIT (SEC).
C   LOUT       CONTROL FOR OUTPUT.    AT EVERY LOUT-TH ITERATION
C              ANGLES ARE OUTPUTTED TO THE FILE #40.
C
C   NUMRNG     NUMBER OF DATA SPECIFIED BELOW.
C
C   LRANGE     RANGE OF INTERACTABLE ATOM PAIRS.  RANGE IS GIVEN BY
C              THE DISTANCE BETWEEN UNITS.
C   WVLTN0     WEIGHTING FACTOR FOR PENALTY FUNCTION IN THE FUNCTON
C              TO  BE MINIMIZED.
C   LFUNC0     OPTION OF ENERGY FUNCTION.
C              LFUNC0<0 : CONFORMATIONAL ENERGY ONLY.
C              LFUNC0=0 : CONF. ENERGY + (PENALTY  FUNC.)*WVLTN.
C              LFUNC0>0 : PENALTY FUNCTION ONLY.
C   NITRTN     LIMIT NUMBER OF ITERATIONS.
C   CONV0      WHEN ENERGY DIFFERENCE BETWEEN TWO CONSECUTIVE ITERATION
C              IS LESS THAN THIS VALUE, MINIMIZATION IS TERMINATED.
C               (1.D-12  IS RECOMMENDED)
C   LOMEGA     OPTION FOR ENERGY BARRIER OF OMEGA.
C              IF LOMEGA=0, STANDARD VALUES (10 KCAL/MOL) ARE ASSIGNED.
C              OTHERWISE 1000 KCAL/MOL IS ASSIGNED.
C
C   IRNDM      INITIALIZING NUMBER FOR RANDOM NUMBER GENERATOR.
C                  NECESSARY ONLY IF ISTART<0
C
C     READ(5,*)     NCONF
C     READ(5,*)     ISTART,TLIMIT,LOUT
C     READ(5,*)     NUMRNG
C      READ(5,*)        LRANGE(I),WVLTN0(I),LFUNC0(I),NITRTN(I),CONV0(I)
C    &               ,LOMEGA(I)
C     IF (ISTART.LT.0)  READ(5,*)  IRNDM
C
      IF (SUBTAS.EQ.'INPU') THEN
        CALL NXTWRD(COMLY2,COMLEN,NXTWD,4)
        IF (NXTWD.EQ.'CNTL') THEN
          CALL GETPAF(COMLY2,COMLEN,'TLIMIT',6,' ',0,TT)
          TLIMIT = SNGL(TT)
          CALL GETPAI(COMLY2,COMLEN,'LOUT',4,' ',0,LOUT)
          CALL GETPAI(COMLY2,COMLEN,'NUMRNG',6,' ',0,NUMRNG)
          DO 10 I=1,NUMRNG
            CALL GETPAI(COMLY2,COMLEN,'LRANGE',6,' ',0,LRANGE(I))
            CALL GETPAF(COMLY2,COMLEN,'WVLTN0',6,' ',0,WVLTN0(I))
            CALL GETPAI(COMLY2,COMLEN,'LFUNC0',6,' ',0,LFUNC0(I))
            CALL GETPAI(COMLY2,COMLEN,'NITRTN',6,' ',0,NITRTN(I))
            CALL GETPAF(COMLY2,COMLEN,'CONV0',5,' ',0,CONV0(I))
            CALL GETPAI(COMLY2,COMLEN,'LOMEGA',6,' ',0,LOMEGA(I))
   10     CONTINUE
C         IF (ISTART.LT.0) THEN
C           CALL GETPAI(COMLY2,COMLEN,'IRNDM',5,' ',0,IRNDM)
C         END IF
        END IF
      GOTO 999
      END IF
C-----------S P E C I F Y   R E S T A R T   F I L E  ------------------
C                          (UNIT 40)
      IF (SUBTAS.EQ.'REST') THEN
        CALL GTFLNM(NAME)
        CALL NXTWRD(COMLY2,COMLEN,NXTWD,4)
        FORMA='UNFORMATTED'
        IF (NXTWD.EQ.'OVER') FORMA='OVERWRITE  '
        CALL OPENWT(IOUT40,FORMA,NAME,IOUT06)
        WRITE(IOUT06,5900) NXTWD,NAME
 5900    FORMAT(5X,A4,' RESTART FILE NAME ',A60)
        WRITE (IOUT02,1900) NAME
 1900    FORMAT (5X,'RESTART FILE NAME:',A60)
        IREST=1
        GOTO 999
      END IF
C-----------R E A D  I N   E N E R G Y   P A R A M E T E R S -----------
C                          (FROM UNIT 33)
      IF (SUBTAS.EQ.'READ') THEN
        CALL NXTWRD(COMLY2,COMLEN,NXTWD,4)
        IF (NXTWD.EQ.'PARM') THEN
          CALL GTFLNM(NAME)
          CALL OPENRD(IN33,'FORMATTED',NAME,IOUT06)
          WRITE(IOUT06,6000) NXTWD,NAME
 6000    FORMAT(5X,A4,' READ FROM ',A60)
          CALL CRDREF(CO)
          CALL READ21
          CLOSE (IN33)
          WRITE (IOUT02,2000) NAME
 2000    FORMAT (5X,'ENERGY PARAMETERS ARE READ IN FROM FILE:',
     1            A60)
        END IF
C-----------R E A D   I N   I N I T I A L   A N G L E S ----------------
C               (FORMATTED, FROM UNIT 35)
        IF (NXTWD.EQ.'ANGL') THEN
          CALL GTFLNM(NAME)
          CALL OPENRD(IN35,'FORMATTED',NAME,IOUT06)
          WRITE(IOUT06,6100) NXTWD,NAME
 6100    FORMAT(5X,A4,' READ FROM ',A60)
          CALL INPANG
          CLOSE (IN35)
          WRITE (IOUT02,2100) NAME
 2100    FORMAT (5X,'INITIAL ANGLES ARE READ IN FROM FILE:',
     1            A60)
        END IF
C-----------R E A D   I N   P R E C E P  O U T P U T   D A T A ---------
C                           (FROM UNIT 31)
        IF (NXTWD.EQ.'PREC') THEN
          CALL GTFLNM(NAME)
          CALL OPENRD(IN31,'FORMATTED',NAME,IOUT06)
          WRITE(IOUT06,6200) NXTWD,NAME
 6200    FORMAT(5X,A4,' READ FROM ',A60)
          CALL INPUTA
          CLOSE (IN31)
          WRITE (IOUT02,2200) NAME
 2200    FORMAT (5X,'PRECEP OUTPUT DATA ARE READ IN FROM FILE:',
     1            A60)
        END IF
      GOTO 999
      END IF
C-----------R E A D   I N   I N I T I A L   A N G L E S ---------------
C              (UNFORMATTED, FROM UNIT 37)
      IF (SUBTAS.EQ.'GET ') THEN
        CALL NXTWRD(COMLY2,COMLEN,NXTWD,4)
        IF (NXTWD.EQ.'ANGL') THEN
          CALL GTFLNM(NAME)
          CALL OPENRD(IN37,'UNFORMATTED',NAME,IOUT06)
          WRITE(IOUT06,7100) NXTWD,NAME
 7100    FORMAT(5X,A4,' READ FROM ',A60)
          CALL GTANGL(IN37,II)
          CLOSE (IN37)
          WRITE (IOUT02,3100) NAME
 3100    FORMAT (5X,'INITIAL ANGLES ARE READ IN FROM FILE:',
     1            A60)
        END IF
        GOTO 999
      END IF
C-----------R U N   M I N I M I Z A T I O N ----------------------------
C
      IF (SUBTAS.EQ.'RUN') THEN
        WRITE(IOUT06,200)
*HITAC  CALL  CLOCK
C     CALL  INPUTA (IREAD,CO,CHARGE)
C     CALL  READ21
      WRITE(IOUT06,*)' NUMVAR=',NUMVAR,' NUMINT=',NUMINT,' NN2=',NN2
      WRITE(IOUT02,*)' NUMVAR=',NUMVAR,' NUMINT=',NUMINT,' NN2=',NN2
        CALL  PRESET (KMAX,LISTK,JANGLE,KANGLE,IBCHAR)
        CALL  PRESS2 (JANGLE,KUNIT,IBCHAR,KSSPER,JSS,KSS,LSS)
        CALL  PAIR14 (KMAX,LISTK,JANGLE,KANGLE)
C
C       WRITE(IOUT06,400) NCONF
        WRITE(IOUT06,401) TLIMIT,LOUT
        WRITE(IOUT02,401) TLIMIT,LOUT
        DO  2  I = 1, NUMRNG
          WRITE(IOUT06,402) I, LRANGE(I),WVLTN0(I),LFUNC0(I),
     &                  NITRTN(I),CONV0(I),LOMEGA(I)
          WRITE(IOUT02,402) I, LRANGE(I),WVLTN0(I),LFUNC0(I),
     &                  NITRTN(I),CONV0(I),LOMEGA(I)
    2   CONTINUE
C 400   FORMAT('  NCONF=',I5)
  401   FORMAT(',   TLIMIT=',F7.1,'(SEC),   LOUT=',I3)
  402   FORMAT('  ',I3,':  LRANGE=',I3,',   WVLTN0=',1PD12.5,
     &         ',   LFUNC0=',I2,',   NITRTN=',I5,',   CONVO=',1PD10.3,
     &         ',   LOMEGA=',I1)
C
C---- INPUT X-RAY DATA  --------------------------------------
C
C*    CALL  INPUTX (MREAD,COX,NFLAG,TITLE1,LFLAG,ATNAME)
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C       DO  2010  ICONF =  1, NCONF
C
C         WRITE(IOUT06,420) ICONF
C 420     FORMAT('0    **************************************'/
C    &           '     *      CONFORMATION  NO. ',I5,'       *'/
C    &           '     **************************************')
C
C---  READ A STARTING CONFORMAION ----------------
C
C       II = 1
C
C       IF (ISTART.EQ.0)  THEN
C         CALL  CNVTDR (INDXV,ANGLES,VAR)
C       IF (ISTART.GT.0)  THEN
C         CALL  READ31 (VAR,II)
C       ELSE IF (ISTART.LT.0) THEN
C         CALL  INPUTR (VAR,ANGLES,INDXV,IRNDM)
C       ENDIF
C
C---  R.M.S. DEVIATION  -------------------------------------
C
C*    CALL  RMSDEV (VAR,CO,COX,COWRK,LFLAG)
C
C********** MINIMIZATION SECTION ***************************************
C
      DO  70  K = 1, NUMRNG
C
        KRANGE = LRANGE(K)
        IF (KRANGE.GT.KMAX)  KRANGE=KMAX
        WVLTN  = WVLTN0(K)
        LFUNC  = LFUNC0(K)
        MAXITR = NITRTN(K)
        CONV   = CONV0(K)
        AMBDA = 0.102D5
        IF (LOMEGA(K).EQ.0)  THEN
          DO  22  I = 1, NUMVAR
            J = INDXV(I)/100
            KK = INDXV(I) - 100*J
C*          IF (KK.EQ.3)  A(I) = 10.D0
  22      CONTINUE
        ELSE
          DO  23  I = 1, NUMVAR
            J = INDXV(I)/100
            KK = INDXV(I) - 100*J
            IF (KK.EQ.3)  A(I) = 1000.D0
  23      CONTINUE
        ENDIF
C
        WRITE(IOUT06,600) KRANGE,WVLTN,LFUNC,MAXITR,CONV,LOMEGA(K)
        WRITE(IOUT02,600) KRANGE,WVLTN,LFUNC,MAXITR,CONV,LOMEGA(K)
C
C--- LFUNC>0 ------ PENALTY FUNCTION ONLY ------------------------------
              IF (LFUNC.GE.1)  THEN
C
      WRITE(IOUT06,610)
      WRITE(IOUT02,610)
C
        NITR = MAXITR-II+1
        ITRS = II-1
        LAMBDA = 0
C
        CALL  MINMZ2 (NUMVAR,NN2,F0,VAR,DF,G,G0,WORK1,WORK2,WORK3,WORK4,
     &       IWRK1,IWRK2,NITR,AMBDA,CONV,ENRGYX,DRVTVX,ICONV,CO,CHARGE)
C
C* CHECK CPU TIME LIMIT *
          IF (ITIME.EQ.1)  THEN
              WRITE(IOUT06,260)
              WRITE(IOUT02,260)
              CALL  DEVIAT (VAR,CO,COX,COWRK,LFLAG,WORK6,
     &                      ATNAME,RENAME,NMBRES)
              STOP
          ENDIF
C
C* CHECK CIS/TRANS OFOMEGA *
        KOMEGA=0
        DO  40  J = 1, NUMVAR
          JJ = INDXV(J)/100
          JK = INDXV(J) - 100*JJ
          IF (JK.EQ.3)  THEN
            OMEGA=VAR(J)
            IF (OMEGA.GT.PI)  THEN
  42          OMEGA=OMEGA-2*PI
              IF (OMEGA.GT.PI)  GOTO  42
            ELSE IF (OMEGA.LT.-PI)  THEN
  44          OMEGA=OMEGA+2*PI
              IF (OMEGA.LT.PI)  GOTO  44
            ENDIF
            OMEGA=ABS(OMEGA)
            IF (ABS(REFANG(J)).GT.HALFPI)  THEN
              IF (OMEGA.LT.HALFPI)  THEN
                WRITE(IOUT06,650) J,VAR(J)/RAD
                WRITE(IOUT02,650) J,VAR(J)/RAD
                KOMEGA=1
              ENDIF
            ELSE
              IF (OMEGA.GT.HALFPI)  THEN
                WRITE(IOUT06,660) J,VAR(J)/RAD
                WRITE(IOUT02,660) J,VAR(J)/RAD
                KOMEGA=1
              ENDIF
            ENDIF
          ENDIF
  40    CONTINUE
        IF (KOMEGA.EQ.1)  THEN
          WRITE(IOUT06,670)
          WRITE(IOUT02,670)
          STOP
        ENDIF
  650   FORMAT(' *** OMEGA OF RESIDUE NO.',I4,' IS CIS, WHILE THIS ',
     &   'OMEGA IN PRECEP DATA IS TRANS.'/' ',10X,'OMEGA=',F8.3)
  660   FORMAT(' *** OMEGA OF RESIDUE NO.',I4,' IS TRANS, WHILE THIS ',
     &   'OMEGA IN PRECEP DATA IS CIS.'/' ',10X,'OMEGA=',F8.3)
  670   FORMAT(' ***** OMEGA VALUES ARE INVALID.   COMPUTATION IS ',
     &   'TERMINATED.')
C
C* MINIMIZATION CONVERGED *
        IF (ICONV.EQ.1)  THEN
          WRITE(IOUT06,230)
          WRITE(IOUT02,230)
C         CALL  OUTMIN (VAR,DF,ICONV,ANGLES,INDXV)
          GOTO  60
        ENDIF
  30  CONTINUE
C
C--- LFUNC=0 --- COFORMATIONAL ENERGY + PENALTY FUNCTION -------------
                  ELSE  IF (LFUNC.EQ.0)  THEN
C
      WRITE(IOUT06,620)
      WRITE(IOUT02,620)
C
        NITR = MAXITR-II+1
        ITRS = II-1
        LAMBDA = 1
C
        CALL  MINMZ2 (NUMVAR,NN2,F0,VAR,DF,G,G0,WORK1,WORK2,WORK3,WORK4,
     &       IWRK1,IWRK2,NITR,AMBDA,CONV,ENRGYZ,DRVTVZ,ICONV,CO,CHARGE)
C
C* CHECK CPU TIME LIMIT *
          IF (ITIME.EQ.1)  THEN
              WRITE(IOUT06,260)
              WRITE(IOUT02,260)
C            ------------------------------
              CALL  DEVIAT (VAR,CO,COX,COWRK,LFLAG,WORK6,
     &                      ATNAME,RENAME,NMBRES)
C            ------------------------------
              STOP
          ENDIF
C
C* MINIMIZATION CONVERGED  *
        IF (ICONV.EQ.1)  THEN
          WRITE(IOUT06,230)
          WRITE(IOUT02,230)
C         CALL  OUTMIN (VAR,DF,ICONV,ANGLES,INDXV)
          GOTO  60
        ENDIF
C
C--- LFUNC<0 ---- CONFORMATIONAL ENERGY ONLY -------------------------
                  ELSE
C
      WRITE(IOUT06,630)
      WRITE(IOUT02,630)
C
        NITR = MAXITR-II+1
        ITRS = II-1
        LAMBDA = 1
C
        CALL  MINMZ2 (NUMVAR,NN2,F0,VAR,DF,G,G0,WORK1,WORK2,WORK3,WORK4,
     &       IWRK1,IWRK2,NITR,AMBDA,CONV,ENRGYA,DRVTVA,ICONV,CO,CHARGE)
C
C* CHECK CPU TIME LIMIT *
          IF (ITIME.EQ.1)  THEN
              WRITE(IOUT06,260)
              WRITE(IOUT02,260)
C            ------------------------------
C*            CALL  DEVIAT (VAR,CO,COX,COWRK,LFLAG,WORK6,
C*   &                      ATNAME,RENAME,NMBRES)
C            ------------------------------
              STOP
          ENDIF
C
C* MINIMIZATION CONVERGED *
        IF (ICONV.EQ.1)  THEN
          WRITE(IOUT06,230)
          WRITE(IOUT02,230)
C         CALL  OUTMIN (VAR,DF,ICONV,ANGLES,INDXV)
C         CALL  DRVTVA(NUMVAR,NN2,VAR,F0,DF,G,CO,CHARGE)
C         CALL  DRVTVA(VAR,F0,DF,G,CO,CHARGE)
C         CALL  OUTFMT(F0,DF,G)
          GOTO  60
        ENDIF
  32  CONTINUE
C---------------------------------------------------------------------
                       ENDIF
      WRITE(IOUT06,240)
      WRITE(IOUT02,240)
  60  II = 1
C
C--------- R.M.S. DEVIATION ----------------------------------
C
C*    CALL  RMSDEV (VAR,CO,COX,COWRK,LFLAG)
C
C--------- OUTPUT TO I/O UNIT #69 ----------------------------
C
CKM  NOT SUPPORTED IN THIS VERSION.
C     IF (K.EQ.1) WRITE(IOUT38,730)
C    >           ((COX(J,I),J=1,3),LFLAG(I),I=1,NUMATM)
C     WRITE(IOUT38,700) K,NUMATM,NUMVAR
C     WRITE(IOUT38,710) ((COWRK(J,I),J=1,3),I=1,NUMATM)
C     WRITE(IOUT38,720) (VAR(I),I=1,NUMVAR)
C 700 FORMAT('K=',I5,I10,I10)
C 710 FORMAT(10F8.3)
C 720 FORMAT(8F10.6)
C 730 FORMAT(3(3F8.3,I2))
C
C***********************************************************************
C
  70  CONTINUE
C
C  CLOSE RESTART FILE
        IF (IREST.EQ.1) THEN
          CLOSE (IOUT40)
        END IF
C
C     WRITE(IOUT06,242) ICONF
C*    CALL  DEVIAT (VAR,CO,COX,COWRK,LFLAG,WORK6,ATNAME,
C*   &              RENAME,NMBRES)
C     CALL  OUTMIN (VAR,DF,ICONV,ANGLES,INDXV)
C     CALL  OUTSTD (KWRITE,ISF,CO,ANGLES,KSSPER,TITLE1,ATNAME,RENAME,
C    &              NMBRES)
C2010 CONTINUE
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
  200 FORMAT('1'//'   ***  DISTANCE-CONSTRAINED ENERGY MINIMIZATION ',
     &       '(COORDINATE)  ***')
  230 FORMAT('0    ***  END OF MINIMIZATION  ***'/)
  240 FORMAT('0    ***  MINIMIZATION HAS EXHAUSTED  ***'/)
C 242 FORMAT('0    ***  THE CALCULATION FOR THE CONFORMATION NO.',I5,
C    &       ' IS FINISHED  ***'/)
  260 FORMAT('0    ***  CPU TIME LIMIT  ***')
  320 FORMAT(10F8.3)
  600 FORMAT('0',15X,'******** PARAMETERS HAVE BEEN CHANGED ********'/
     &       '    KRANGE=',I3,',  WVLTN=',1PE10.3,',   LFUNC=',I2,
     &       ',   MAXITR=',I5,',   CONV=',1PE10.3,',   LOMEGA=',I1/)
  610 FORMAT('    -> MINIMIZE PENELTY FUNCTION ONLY'/)
  620 FORMAT('    -> MINIMIZE CONFORMATIONAL ENERGY + PENALTY FUNCTION'/
     &)
  630 FORMAT('    -> MINIMIZA CONFORMATIONAL ENERGY ONLY'/)
      GOTO 999
      END IF
      IF (SUBTAS.EQ.'WRIT') THEN
        CALL NXTWRD(COMLY2,COMLEN,NXTWD,4)
C-----------P R I N T   O U T   F I N A L   A N G L E S ----------------
C                           (TO UNIT 32)
        IF (NXTWD.EQ.'ANGL') THEN
          CALL GTFLNM(NAME)
          CALL OPENWT(IOUT32,'FORMATTED',NAME,IOUT06)
          WRITE(IOUT06,6300) NXTWD,NAME
 6300    FORMAT(5X,A4,' WRITTEN TO ',A60)
          CALL OUTMIN
          CLOSE (IOUT32)
          WRITE (IOUT02,2300) NAME
 2300    FORMAT (5X,'FINAL ANGLES ARE WRITEN TO FILE:',
     1            A60)
        END IF
C-----------P R I N T   O U T   F I N A L   C O O R D I N A T E S ------
C                (FORMATTTED,TO UNIT 34)
        IF (NXTWD.EQ.'COOR') THEN
          CALL NXTWRD(COMLY2,COMLEN,NXTWD,4)
          IF (NXTWD.EQ.'FLEX') THEN
            CALL GTFLNM(NAME)
            CALL OPENWT(IOUT34,'FORMATTED',NAME,IOUT06)
            WRITE(IOUT06,6400) NXTWD,NAME
 6400       FORMAT(5X,A4,' WRITTEN TO ',A60)
            CALL OUTSTD(ISF,CO,ANGLES,KSSPER,TITLE1,ATNAME,
     &                  RENAME,NMBRES)
            CLOSE (IOUT34)
            WRITE (IOUT02,2400) NAME
 2400       FORMAT (5X,'FINAL COORDINATES ARE WRITEN TO FILE:',
     &            A60)
          END IF
          IF (NXTWD.EQ.'PDB ') THEN
C    *************NOT SUPPORTED IN THIS VERSION********
          END IF
        END IF
      GOTO 999
      END IF
      IF (SUBTAS.EQ.'PUT ') THEN
        CALL NXTWRD(COMLY2,COMLEN,NXTWD,4)
C-----------P R I N T   O U T   F I N A L   C O O R D I N A T E S ------
C                (UNFORMATTTED,TO UNIT 39)
        IF (NXTWD.EQ.'COOR') THEN
          CALL GTFLNM(NAME)
          CALL NXTWRD(COMLY2,COMLEN,NXTWD,4)
          FORMA='UNFORMATTED'
          IF (NXTWD.EQ.'OVER') FORMA='OVERWRITE  '
          CALL OPENWT(IOUT39,FORMA,NAME,IOUT06)
          WRITE(IOUT06,6600) NXTWD,NAME
 6600     FORMAT(5X,A4,' WRITTEN TO ',A60)
          CALL PTCOOR(IOUT39)
          CLOSE (IOUT39)
          WRITE (IOUT02,2600) NAME
 2600     FORMAT (5X,'FINAL COORDINATES ARE WRITEN TO FILE:',
     &            A60)
        END IF
C-----------P R I N T   O U T   D E R I V A T I V E S -----------
C                           (TO UNIT 36)
        IF (NXTWD.EQ.'FMAT') THEN
          CALL GTFLNM(NAME)
          CALL NXTWRD(COMLY2,COMLEN,NXTWD,4)
          FORMA='UNFORMATTED'
          IF (NXTWD.EQ.'OVER') FORMA='OVERWRITE  '
          CALL OPENWT(IOUT36,FORMA,NAME,IOUT06)
          WRITE(IOUT06,6500) NXTWD,NAME
 6500    FORMAT(5X,A4,' WRITTEN TO ',A60)
          CALL  DRVTVA(VAR,F0,DF,G,CO,CHARGE)
          CALL  OUTFMT(F0)
          CLOSE (IOUT36)
          WRITE (IOUT02,2500) NAME
 2500    FORMAT (5X,'FIRST AND SECOND DIRIVATIVES ',
     &           'ARE WRITEN TO FILE:',A60)
        END IF
        GOTO 999
      END IF
      GOTO 999
  990 RETURN
      END
C-----------------------------------------------------------------------
      SUBROUTINE  INPUTA
C-----------------------------------------------------------------------
C     READ IN PRECET OUTPUT DATA.
C
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXATM=3000,MAXVAR=800,MAXRES=150,MAXLEN=3500)
C     PARAMETER  (MXATM1=MAXATM+1,MVAR1=MAXVAR+1)
C     PARAMETER  (MAXSS =5,MAXSS2=2*MAXSS)
      CHARACTER*80 TITLE1
C     CHARACTER*4  SEQATM,SEQAA
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (ATOM)
      INCLUDE 'inc/atom'
CMSP  INCLUDE (BOND)
      INCLUDE 'inc/bond'
CMSP  INCLUDE (CHARGE)
      INCLUDE 'inc/charge'
CMSP  INCLUDE (NBTYPE)
      INCLUDE 'inc/nbtype'
CMSP  INCLUDE (INTER0)
      INCLUDE 'inc/inter0'
CMSP  INCLUDE (REFRNC)
      INCLUDE 'inc/refrnc'
CMSP  INCLUDE (TABLE1)
      INCLUDE 'inc/table1'
CMSP  INCLUDE (TORSN0)
      INCLUDE 'inc/torsn0'
CMSP  INCLUDE (SSPAIR)
      INCLUDE 'inc/sspair'
CMSP  INCLUDE (VARANG)
      INCLUDE 'inc/varang'
CMSP  INCLUDE (ALPHA)
      INCLUDE 'inc/alpha'
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/NUMBR1/  NATM1,NVAR1,NPAIR1
C     COMMON/ATOM00/  KUNIT(MAXATM),KATOM(MXATM1),JATOM(MAXATM)
C     COMMON/ATOM01/  LATOM0(0:MAXVAR),LATOM1(MAXATM)
C     COMMON/BOND00/  DIRCOS(3,MAXVAR),IBND1(MAXVAR),IBND2(0:MVAR1)
C     COMMON/BOND01/  IBCHAR(3,MAXVAR)
C     COMMON/NBTYPE/  NBTYPE(MAXATM)
C     COMMON/INTER0/  INTER(MAXATM),INTATM(3,MAXLEN)
C     COMMON/REFRNC/  REFCRD(3,MAXATM),REFANG(MAXVAR)
C     COMMON/TABLE1/  IFRONT(MAXVAR),NBACK(0:MAXVAR),IBACK(2,0:MAXVAR)
C     COMMON/TORSN0/  A(MAXVAR),NB(MAXVAR),NS(MAXVAR),IFTOR(MAXVAR)
C     COMMON/SSPAIR/  KSSPER(6,2,MAXSS),JSS(3,MAXSS),KSS(MAXSS2),
C    &                LSS(MAXSS2)
C     COMMON/VARANG/  ANGLES(10,MAXRES),INDXV(MAXVAR)
C     COMMON/ALPH1/   SEQATM(MAXATM),SEQAA(MAXATM)
C     COMMON/ALPH2/   ISEQRS(MAXATM)
      COMMON/EPARAM/  PNB(28,56)
      COMMON/TITLE1/  TITLE1
C
      READ(IN31,100)  TITLE1
      READ(IN31,110)  NUMATM,NUMVAR,NUMRES,NUMINT,NSS
C     NATM1 = NUMATM + 1
C     NVAR1 = NUMVAR + 1
C     NN2 = NUMVAR*(NUMVAR+1)/2
C     NPAIR1 = (NUMVAR+1)*(NUMVAR+2)/2
C
      DO  10  I = 1, NUMRES
  10  READ(IN31,120)  (ANGLES(J,I),J=1,10)
C
      READ(IN31,131)  NBACK(0),IBACK(1,0),IBACK(2,0)
      DO  20  I = 1, NUMVAR
C INDEXV CANNOT BE READ USING OPEN STATEMENT COMMENTED BY M.IRISA
C 20  READ(IN31,130)  INDXV(I),IBND1(I),IBND2(I),IFRONT(I),
C    &     (IBCHAR(J,I),J=1,3),A(I),NB(I),NS(I),IFTOR(I),
C    &     NBACK(I),IBACK(1,I),IBACK(2,I)
      READ(IN31,132)  INDXV1,INDXV2,IBND1(I),IBND2(I),IFRONT(I),
     &     (IBCHAR(J,I),J=1,3),A(I),NB(I),NS(I),IFTOR(I),
     &     NBACK(I),IBACK(1,I),IBACK(2,I)
      INDXV(I)=100*INDXV1+INDXV2
  20  CONTINUE
C FOLLOWING TWO LINES ARE MOVED TO CRDREF
C     IBND2(0) = 1
C     IBND2(NUMVAR+1) = NUMATM+1
C
      DO  30  I = 1, NUMATM
C 30  READ(IN31,140)  (REFCRD(L,I),L=1,3),CHARGE(I),NBTYPE(I),
C    &      KUNIT(I),KATOM(I),JATOM(KATOM(I))
C    &      ,SEQATM(I),SEQAA(I),ISEQRS(I)
  30  READ(IN31,140)  (REFCRD(L,I),L=1,3),CHARGE(I),NBTYPE(I),
     &      KUNIT(I),KATOM(I),JATOM(KATOM(I))
     &      ,ATNAME(I),RENAME(I),NMBRES(I)
      READ(IN31,110)  (INTER(I),I=1,NUMATM)
      READ(IN31,150)  ((INTATM(J,I),J=1,3),I=1,NUMINT)
C THIS EQUATION WAS MOVED TO CRDREF
C     KATOM(NUMATM+1) = NUMATM+1
C
      IF (NSS.EQ.0)  GOTO  50
C
      DO  40  I = 1, NSS
  40  READ(IN31,110)  (KSSPER(J,1,I),J=1,6)
C
  100 FORMAT(A80)
  110 FORMAT(16I5)
  120 FORMAT(10F8.3)
  130 FORMAT(I6,2X,2I5,2X,2I5,2I2,F10.4,3I3,5X,I5,2I5)
C INDEXV CANNOT BE READ USING OPEN STATEMENT COMMENTED BY M.IRISA
  132 FORMAT(I4,I2,2X,2I5,2X,2I5,2I2,F10.4,3I3,5X,I5,2I5)
C 130 FORMAT(I6,2X,2I5,2X,2I5,2I2,F10.4,3I3,5X,I5,1X,2I3)
  131 FORMAT(53X,5X,I5,1X,2I3)
  140 FORMAT(3F10.4,4X,F10.3,4I5,2X,A4,1X,A4,I5)
  150 FORMAT(5(1X,3I5))
  160 FORMAT(A6)
  170 FORMAT(I5,2F10.4,I10)
  180 FORMAT(I10,F10.4,I5)
C
  50  CALL  OUT001
C
C '90 1/12 COMMENTED BY M. IRISA
C THIS SUBROUTINE WILL NOT BE NEEDED IN THE COMPLETE VERSION (PRECEPP
C + FEDER)
C IN THE COMPLETE VERSION, REFANG IS INCLUIDED IN THE GLOBAL COMMON
      CALL  CNVTDR (INDXV,ANGLES,REFANG)
C
C     CALL  CRDREF (CO)
C
      RETURN
      END
      SUBROUTINE  INPUTD (LREAD,KMAX,LCNSTR)
C
C  READ THE DATA ON DISTANCE CONSTRAINTS
C
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXCNS=900)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      COMMON/CNSTR1/  DCNSTR(MAXCNS),WGHT(MAXCNS)
      COMMON/CNSTR2/  NUMCNS,NCNSTR(MAXCNS),
     &                MPAIR1(MAXCNS),MPAIR2(MAXCNS)
      DIMENSION  LCNSTR(-1:KMAX)
C
      READ(LREAD,100)  (LCNSTR(I),I=-1,KMAX)
  100 FORMAT(16I5)
C
      KK = 1
  10  READ(LREAD,110,END=200)  NCNSTR(KK),DCNSTR(KK),MPAIR1(KK),
     &                         MPAIR2(KK),WGHT(KK)
  110 FORMAT(I5,F10.3,2I6,5X,F10.3)
      KK = KK+1
        GOTO  10
C
 200  NUMCNS = KK-1
      RETURN
      END
      SUBROUTINE  INPUTX (MREAD,COX,NFLAG,TITLE1,LFLAG,ATNAME)
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER  TITLE1*80,ITITL1*80,ID*4
      CHARACTER  ATNAME(NUMATM)*4,FLAG*2
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  COX(3,NUMATM),NFLAG(NUMATM),LFLAG(NUMATM)
C
      READ(MREAD,110)  ID
      READ(MREAD,120)  ITITL1
      DO  10  I = 1, NUMATM
        READ(MREAD,130)  (COX(K,I),K=1,3),NFLAG(I),FLAG
        LFLAG(I) = 0
        IF (.NOT.(FLAG.EQ.'  '.OR.FLAG(1:1).EQ.'-'))  THEN
          IF (ATNAME(I).EQ.'CA  ' .OR. ATNAME(I).EQ.'N   ' .OR.
     &        ATNAME(I).EQ.'C   ' .OR. ATNAME(I).EQ.'O   ' .OR.
     &        ATNAME(I).EQ.'CB  ')  THEN
                 LFLAG(I)=2
          ELSE
                 LFLAG(I)=1
          ENDIF
        ENDIF
  10  CONTINUE
C
 110  FORMAT(A4)
 120  FORMAT(A80)
 130  FORMAT(3F8.3,1X,I1,11X,A2)
C
      WRITE(IOUT06,210) TITLE1
      WRITE(IOUT06,220) ITITL1,ID
      WRITE(IOUT02,210) TITLE1
      WRITE(IOUT02,220) ITITL1,ID
 210  FORMAT('0  TITLE1 OF CALUCULATED PROTEIN  :  ',A80)
 220  FORMAT('   TITLE1 OF X-RAY DATA PROTEIN   :  ',A80,' (ID:',A4,')')
      RETURN
      END
C---------------------------------------------------------------------
      SUBROUTINE INPANG
C-----------------------------------------------------------------------
C     READ IN INITIAL ANGLES FROM AN ECCEP FORMATTED FILE
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
CMSP  INCLUDE (VARANG)
      INCLUDE 'inc/varang'
      CALL RDANGL(IN35)
C     DO  10  I = 1, NUMRES
C 10    READ(IN35,320)  (ANGLES(J,I),J=1,10)
      CALL  CNVTDR (INDXV,ANGLES,VAR)
  320 FORMAT(10F8.3)
      RETURN
      END
C-----------------------------------------------------------------------
      SUBROUTINE  INPUTR (VAR,ANGLES,INDXV,IRNDM)
C-----------------------------------------------------------------------
C
C  ASSIGN THE RANDOM NUMBERS TO VAR(I)
C
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER  (PI=3.141 592 653 589 793D0)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  VAR(NUMVAR),ANGLES(10,NUMRES),INDXV(NUMVAR)
      DATA  ZERO /0.D0/
C
      DO  10  I = 1, NUMVAR
        J = INDXV(I)/100
        K = INDXV(I) - 100*J
C
C  VAR(I) IS NOT OMEGA, THEN..
C
        IF (K.NE.3)  THEN
          VAR(I) = RANDUN(IRNDM)*PI
C
C  VAR(I) IS OMEGA, THEN..
C
        ELSE
          IF (ABS(ANGLES(K,J)).GT.90.D0)  THEN
            VAR(I) = PI
          ELSE
            VAR(I) = ZERO
          ENDIF
        ENDIF
C
 10   CONTINUE
C
      RETURN
      END
      FUNCTION RANDUN(IX)
      IMPLICIT REAL*8 (A-H,O-Z)
      IX=IX*48828125
      IF(IX) 10,20,20
   10 IX=(IX+2147483647)+1
   20 X=DFLOAT(IX)*0.4656613D-9
      RANDUN = X + X - 1.0
      RETURN
      END
C-----------------------------------------------------------------------
      SUBROUTINE  READ21
C-----------------------------------------------------------------------
C     READ IN ENERGY PARAMETERS (BD8)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
      COMMON/DISULF/  RSS(4),ASS(4),BSS(9)
      COMMON/EPARAM/  PNB(28,56)
C
C     DATA  JREAD/21/
C
      DO  200  J = 1, 56, 2
C       READ(JREAD,210)  (PNB(I,J),I=1,28)
C       READ(JREAD,210)  (PNB(I,J+1),I=1,28)
        READ(IN33,210)  (PNB(I,J),I=1,28)
        READ(IN33,210)  (PNB(I,J+1),I=1,28)
  200 CONTINUE
  210 FORMAT(8F10.6)
C
C     READ(JREAD,220)  (RSS(I),I=1,4)
C     READ(JREAD,220)  (ASS(I),I=1,4)
C     READ(JREAD,230)  (BSS(I),I=1,9)
      READ(IN33,220)  (RSS(I),I=1,4)
      READ(IN33,220)  (ASS(I),I=1,4)
      READ(IN33,230)  (BSS(I),I=1,9)
  220 FORMAT(10F8.3)
  230 FORMAT(3D25.0)
C
      RETURN
      END
C
      SUBROUTINE  PRESET (KMAX,LISTK,JANGLE,KANGLE,IBCHAR)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/NUMBR1/  NATM1,NVAR1,NPAIR1
      DIMENSION  LISTK(-1:MAXVAR),JANGLE(MXPAIR),KANGLE(0:MXPAR1)
      DIMENSION  IBCHAR(3,MAXVAR)
C************************************************
C  THIS SECTION MAKES THE LISTS OF BOND PAIRS.
C************************************************
C
C  LIST:     JANGLE
C
      KMAX = 0
      KMIN = NUMVAR
      LISTK(KMIN-1) = 1
      DO  30  KK = NUMVAR-1, 0, -1
      DO  30  IB = 1, NUMVAR-KK
        IA = IB + KK
        NAB = IA*(IA-1)/2 + IB
        KAB = KDIST(IA,IB,IBCHAR)
C       IF(KAB.GT.MAXVAR)WRITE(6,*)'KAB=',KAB,' IA=',IA,' IB=',IB
        KMAX = MAX (KMAX,KAB)
        IF (KAB.LT.KMIN)  THEN
          LISTK0 = LISTK(KMIN-1)
          DO  10  I = KAB-1, KMIN-2
  10      LISTK(I) = LISTK0
          KMIN = KAB
        ENDIF
        DO  20  I = KMIN-1, KAB-1
  20    LISTK(I) = LISTK(I) + 1
        JANGLE(NAB) = LISTK(KAB-1) - LISTK(KAB)
  30  CONTINUE
C
C  LIST:     KANGLE
C
      DO  70  KK = NUMVAR-1, 0, -1
      DO  70  IB = 1, NUMVAR-KK
        IA = IB + KK
        NAB = IA*(IA-1)/2 + IB
        KAB = KDIST(IA,IB,IBCHAR)
        KNC = IA*10000 + IB
        IF (IBCHAR(2,IB).EQ.0)   GOTO  50
        IF (IBCHAR(1,IA).NE.IBCHAR(1,IB))  GOTO  60
        IF (IBCHAR(3,IA).LT.IBCHAR(3,IB))  GOTO  60
  50    KNC = - KNC
  60    L = LISTK(KAB) - 1 + JANGLE(NAB)
        KANGLE(L) = KNC
  70  CONTINUE
      RETURN
      END
      SUBROUTINE  PRESS2 (JANGLE,KUNIT,IBCHAR,KSSPER,JSS,KSS,LSS)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  KSSPER(6,2,NSS),JSS(3,NSS),KSS(NSS*2),LSS(NSS*2)
      DIMENSION  JANGLE(NN2),KUNIT(NUMATM),IBCHAR(3,NUMVAR)
      DIMENSION  LSSPER(6,2)
C
      IF (NSS.EQ.0)  RETURN
C
      DO  140  I = 1, NSS
C
C  UNIT IB : CB(2),SG(3),        UNIT (IB-1) : CA(1)
C  UNIT IA : CB(5),SG(6),        UNIT (IA-1) : CA(4)
C
        IA = KUNIT(KSSPER(6,1,I))
        IB = KUNIT(KSSPER(3,1,I))
        I2 = 2*I
        I1 = I2 - 1
        LSS(I1) = I1
        LSS(I2) = I2
        KSS(I1) = KDIST(IA,IB,IBCHAR)
        KSS(I2) = KSS(I1) - 1
C
C UNIT PAIR : IA & IB  / SG(6)-SG(3),SG(6)-CB(2),CB(5)-SG(3),CB(5)-CB(2)
C
        NAB = IA*(IA-1)/2 + IB
        JSS(1,I) = JANGLE(NAB)
          LSSPER(1,1) = KSSPER(6,1,I)
          LSSPER(1,2) = KSSPER(3,1,I)
          LSSPER(2,1) = KSSPER(6,1,I)
          LSSPER(2,2) = KSSPER(2,1,I)
          LSSPER(3,1) = KSSPER(5,1,I)
          LSSPER(3,2) = KSSPER(3,1,I)
          LSSPER(4,1) = KSSPER(5,1,I)
          LSSPER(4,2) = KSSPER(2,1,I)
C
C UNIT PAIR : IA & IB-1 / SG(6)-CA(1)
C
        NAB = NAB+1
        JSS(2,I) = JANGLE(NAB)
          LSSPER(5,1) = KSSPER(6,1,I)
          LSSPER(5,2) = KSSPER(1,1,I)
C
C UNIT PAIR : IA-1 & IB / CA(4)-SG(3)
C
        NAB = NAB - IA
        JSS(3,I) = JANGLE(NAB)
          LSSPER(6,1) = KSSPER(4,1,I)
          LSSPER(6,2) = KSSPER(3,1,I)
C
        DO  100  J = 1, 6
          KSSPER(J,1,I) = LSSPER(J,1)
  100     KSSPER(J,2,I) = LSSPER(J,2)
C
        IF (I.EQ.1)  GOTO  140
C
C ARRANGE IN DESCENDING ORDER OF UNIT DISTANCES
C
        MSS = I1
  110   MSS = MSS-1
        IF (KSS(LSS(MSS)).GE.KSS(LSS(MSS+1)))  GOTO  120
          LS = LSS(MSS)
          LSS(MSS) = LSS(MSS+1)
          LSS(MSS+1) = LS
        IF (MSS.GT.1)  GOTO  110
C
  120   MSS = I2
  130   MSS = MSS-1
        IF (KSS(LSS(MSS)).GE.KSS(LSS(MSS+1)))  GOTO  140
          LS = LSS(MSS)
          LSS(MSS) = LSS(MSS+1)
          LSS(MSS+1) = LS
        IF (MSS.GT.1)  GOTO  130
C
  140 CONTINUE
      RETURN
      END
      SUBROUTINE  PAIR14 (KMAX,LISTK,JANGLE,KANGLE)
C
C  THIS SUBROUTINE MAKES THE LISTS OF INTERACTABLE ATOM PAIRS IPAIR1
C  AND IPAIR2.
C
C FOR ATOM PAIRS THAT BELONG TO THE UNIT PAIRS OF DISTACES K=0, 1 OR 2
C   THE LISTS IPAIR1 AND IPIAR2 ARE MADE.
C FOR ATOM PAIRS THAT BELONG TO THE UNIT PAIRS OF DISTACES K>=3
C   ONLY INTERACTION TYPES (1-4 OR 1-5) ARE CHECKED, AND ATOM PAIRS OF
C   1-4 INTERACTION ARE STORED  IN LIST14.
C
C  THIS SUBROUTINE IS CALLED ONLY ONCE.
C
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXATM=3000,MAXVAR=800,MAXLEN=3500,MAXINT=60000)
C     PARAMETER  (MXATM1=MAXATM+1,MVAR1=MAXVAR+1)
C     PARAMETER  (MAXI1=MAXINT/2,MAXI2=MAXINT-MAXI1)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (ATOM)
      INCLUDE 'inc/atom'
CMSP  INCLUDE (BOND)
      INCLUDE 'inc/bond'
CMSP  INCLUDE (INTER0)
      INCLUDE 'inc/inter0'
CMSP  INCLUDE (TABLE1)
      INCLUDE 'inc/table1'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/NUMBR1/  NATM1,NVAR1,NPAIR1
C     COMMON/ATOM00/  KUNIT(MAXATM),KATOM(MXATM1),JATOM(MAXATM)
C     COMMON/BOND00/  DIRCOS(3,MAXVAR),IBND1(MAXVAR),IBND2(0:MVAR1)
      COMMON/INTR14/  NO14(-1:MAXVAR),LIST14(100),
     &                NO12(-1:MAXVAR),LIST12(100)
C     COMMON/INTER0/  INTER(MAXATM),INTATM(3,MAXLEN)
C     COMMON/TABLE1/  IFRONT(MAXVAR),NBACK(0:MAXVAR),IBACK(2,0:MAXVAR)
      COMMON/TABLE3/  NINT,IPAIR1(MAXI1),IPAIR2(MAXI2),LINT(-1:MAXVAR)
      DIMENSION  LISTK(-1:NUMVAR),JANGLE(NN2),KANGLE(0:NPAIR1)
      NINT = 0
      N14  = 0
      NO14(KMAX) = 1
      N12  = 0
      NO12(KMAX) = 1
C
      DO  30  KAB = KMAX, 0, -1
        LINI = LISTK(KAB)
        LFIN = LISTK(KAB-1) - 1
        LINT0 = 0
        MINT0 = 0
        MFLAG = -1
        IF (KAB.LE.2)  MFLAG = 1
C
        DO  20  LKJ = LINI, LFIN
          KA = IABS(KANGLE(LKJ))
          IA = KA/10000
          IB = KA - 10000*IA
          IF (KANGLE(LKJ).LT.0)  IB = IFRONT(IB)
          JA1 = KATOM(IBND2(IA))
          JA2 = KATOM(IBND2(IA+1)) - 1
          JB1 = KATOM(IBND2(IB))
          JB2 = KATOM(IBND2(IB+1)) - 1
          NRPAIR = 0
C
          DO  10  JA = JA1, JA2
            JJA = JATOM(JA)
          DO  10  JB = JB1, JB2
            JJB = JATOM(JB)
            LPRE = LINT0
            CALL  TYPCK  (JJA,JJB,NINT,INTER,INTATM,IPAIR1,IPAIR2,
     &                    NRPAIR,LINT0,MFLAG)
C
C  IF INTERACTION BETWEEN ATOMS JJA AND JJB IS OF 1-4 TYPE, THEN ...
C
            IF (MFLAG.EQ.-2)  THEN
              N14 = N14 + 1
              LIST14(N14) = LINT0
              MFLAG = -1
            ENDIF
C
C  IF INTERACTION BETWEEN ATOMS JJA AND JJB IS OF 1-2 OR 1-3 TYPE, THEN
C
            IF (MFLAG.LT.0)  THEN
              MINT0 = MINT0 + 1
              IF (LPRE.EQ.LINT0)  THEN
                N12 = N12 + 1
                LIST12(N12) = MINT0
              ENDIF
            ENDIF
C
  10      CONTINUE
C
          JANGLE(LKJ) = JANGLE(LKJ) + NRPAIR
C
  20    CONTINUE
C
        LINT(KAB) = LINT0
        NO14(KAB-1) = N14 + 1
        NO12(KAB-1) = N12 + 1
C
  30  CONTINUE
C
      LM1 = 0
      DO  40  K = 0, KMAX
  40  LM1 = LM1 + LINT(K)
      LINT(-1) = LM1 + 1
      DO  50  K = 0, KMAX
  50  LINT(K) = LINT(K-1) - LINT(K)
      RETURN
      END
      SUBROUTINE TYPCK (II,JJ,NINT,INTER,INTATM,IPAIR1,IPAIR2,NRPAIR,
     &                   LINT,MFLAG)
C
C  THIS SUBROUTINE CHECKS THE INTERACTION TYPE OF THE PAIR OF ATOMS
C  II AND JJ.  IF THE INTERACTION IS OF 1-4 TYPE, THEN SET IPAIR1<0
C  IF MFLAG>0  OR SET MFLAG=-2 IF MFLAG<0.
C
C     PARAMETER  (MAXATM=3000,MAXVAR=800,MAXLEN=3500,MAXINT=60000)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     INCLUDE (INTER0)
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  IPAIR1(*),IPAIR2(*),INTER(NUMATM),INTATM(3,NUMINT)
      M1 = MIN(II,JJ)
      M2 = MAX(II,JJ)
      INTM1 = INTER (M1)
C
  10  IATMI = M1 + INTATM(1,INTM1)
      NUM4 = INTATM(2,INTM1)
      IATMF = IATMI + NUM4 - 1
      IF (NUM4.EQ.0)  GOTO  20
      IF (M2.GE.IATMI.AND.M2.LE.IATMF)  THEN
        IF (MFLAG.LT.0)  THEN
          MFLAG = -2
        ELSE
          NINT = NINT + 1
          IPAIR1(NINT) = -II
          IPAIR2(NINT) = JJ
        ENDIF
        GOTO  120
      ENDIF
C
  20  KEY = INTATM(3,INTM1)
      IF (KEY.EQ.0)  GOTO  30
      IATMI = IATMF + 1
      IATMF = NUMATM
      IF (KEY.GT.0)  IATMF = IATMI + KEY - 1
      IF (M2.GE.IATMI.AND.M2.LE.IATMF)  THEN
        IF (MFLAG.GT.0)  THEN
          NINT = NINT + 1
          IPAIR1(NINT) = II
          IPAIR2(NINT) = JJ
        ENDIF
        GOTO  120
      ENDIF
C
  30  IF (NUM4.EQ.0.AND.KEY.EQ.0)  RETURN
      IF (KEY.LT.0)  RETURN
      INTM1 = INTM1 + 1
         GOTO  10
C
  120 NRPAIR = NRPAIR + 10000
      LINT = LINT + 1
      RETURN
      END
      SUBROUTINE  PAIR15 (JPAIR1,JPAIR2,JAA,JBF,JFIN,
     &              KATOM,JATOM,IBND2,LI,LF,LIST14,MI,MF,LIST12,MFLAG)
C
C  THIS SUBROUTINE MAKES THE LISTS OF INTERACTABLE ATOM PAIRS JPAIR1
C  AND JPAIR2.  IN THIS SUBROUTINE ONLY THE ATOM PAIRS THAT BELONGS TO
C  THE UNIT PAIRS OF A GIVEN DISTANCE K (K>2) ARE LISTED UP.
C
C  THIS SUBROUTINE IS CALLED EVERY TIME THE SUBROUTINE DERVTV IS
C  CALLED IN ORDER TO SAVE THE MEMORY SPACE FOR JPAIR1 AND JPAIR2.
C
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/NUMBR1/  NATM1,NVAR1,NPAIR1
      DIMENSION  JPAIR1(*),JPAIR2(*),JAA(JFIN),JBF(JFIN)
      DIMENSION  KATOM(NATM1),JATOM(NUMATM),IBND2(0:NVAR1)
      DIMENSION  LIST14(*),LIST12(*)
C
      LFIN = 0
C
      DO  20  LKJ = 1, JFIN
        IA = JAA(LKJ)
        IB = JBF(LKJ)
        JA1 = KATOM(IBND2(IA))
        JA2 = KATOM(IBND2(IA+1)) - 1
        JB1 = KATOM(IBND2(IB))
        JB2 = KATOM(IBND2(IB+1)) - 1
C
C  TO EXPAND A MOST INNER LOOP FIVE CASES ARE CONSIDERED.
C
        IF (JB2-JB1-3)  1, 5, 6
   1    IF (JB2-JB1-1)  2, 3, 4
C  JB2-JB1=0
   2    JATJB1 = JATOM(JB1)
        DO  12  JA = JA1, JA2
          LFIN = LFIN + 1
          JPAIR1(LFIN) = JATOM(JA)
  12      JPAIR2(LFIN) = JATJB1
            GOTO  20
C  JB2-JB1=1
   3    JATJB1 = JATOM(JB1)
        JATJB2 = JATOM(JB2)
        DO  13  JA = JA1, JA2
          JPAIR1(LFIN+1) = JATOM(JA)
          JPAIR1(LFIN+2) = JATOM(JA)
          JPAIR2(LFIN+1) = JATJB1
          JPAIR2(LFIN+2) = JATJB2
  13      LFIN = LFIN + 2
            GOTO  20
C  JB2-JB1=2
   4    JATJB1 = JATOM(JB1)
        JATJB2 = JATOM(JB1+1)
        JATJB3 = JATOM(JB2)
        DO  14  JA = JA1, JA2
          JPAIR1(LFIN+1) = JATOM(JA)
          JPAIR1(LFIN+2) = JATOM(JA)
          JPAIR1(LFIN+3) = JATOM(JA)
          JPAIR2(LFIN+1) = JATJB1
          JPAIR2(LFIN+2) = JATJB2
          JPAIR2(LFIN+3) = JATJB3
  14      LFIN = LFIN + 3
            GOTO  20
C  JB2-JB1=3
   5    JATJB1 = JATOM(JB1)
        JATJB2 = JATOM(JB1+1)
        JATJB3 = JATOM(JB1+2)
        JATJB4 = JATOM(JB2)
        DO  15  JA = JA1, JA2
          JPAIR1(LFIN+1) = JATOM(JA)
          JPAIR1(LFIN+2) = JATOM(JA)
          JPAIR1(LFIN+3) = JATOM(JA)
          JPAIR1(LFIN+4) = JATOM(JA)
          JPAIR2(LFIN+1) = JATJB1
          JPAIR2(LFIN+2) = JATJB2
          JPAIR2(LFIN+3) = JATJB3
          JPAIR2(LFIN+4) = JATJB4
  15      LFIN = LFIN + 4
            GOTO  20
C  JB2-JB1>3
   6    DO  17  JA = JA1, JA2
          JPA = JATOM(JA)
          DO  16  JB = JB1, JB2
            LFIN = LFIN + 1
            JPAIR1(LFIN) = JPA
            JPAIR2(LFIN) = JATOM(JB)
  16     CONTINUE
  17   CONTINUE
  20  CONTINUE
C
C  MFLAG.LT.0   INDICATES THAT ALL THE INTERACTIONS OF ATOM PAIRS
C               CONSIDERED NOW ARE OF 1-5 TYPE.
C  MFLAG.GT.0   INDICATES THAT THE INTERACTIONS OF ATOM PAIRS CONSIDERED
C               NOW ARE OF EITHER 1-4 OR 1-5 TYPE. THIS IS THE CASE OF
C               DISULFIDE BONDS.
C
      IF (MFLAG.LT.0)  RETURN
C
      IF (MF.LT.MI)    GOTO  50
C
C  1-2 AND 1-3 TYPE INTERACTIONS ARE DISCARDED.
C
      KFIN = LIST12(MI)-1
      DO  42  M = MI, MF
        M1 = LIST12(M)+1
        IF (M.EQ.MF)  THEN
          M2 = LFIN
        ELSE
          M2 = LIST12(M+1)-1
        ENDIF
        IF (M2.LT.M1)  GOTO  42
        DO  40  J = M1, M2
          KFIN = KFIN+1
          JPAIR1(KFIN) = JPAIR1(J)
          JPAIR2(KFIN) = JPAIR2(J)
  40    CONTINUE
  42  CONTINUE
      LFIN=KFIN
C
  50  IF (LF.LT.LI)    RETURN
C
C  1-4 TYPE INTERACTIONS ARE MARKED.
C
*VOPTION VEC
      DO  60  L = LI, LF
  60    JPAIR1(LIST14(L)) = -JPAIR1(LIST14(L))
C
      RETURN
      END
      FUNCTION  KDIST (IA,IB,IBCHAR)
C
C  THIS FUNCTION SUBPROGRAM COMPUTES THE DISTANCE BETWEEN TWO BONDS
C  IA AND IB ALONG THE CHAIN.
C
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     DIMENSION  IBCHAR(3,NUMVAR)
      DIMENSION  IBCHAR(3,MAXVAR)
C
      IF (IBCHAR(1,IA).NE.IBCHAR(1,IB))  THEN
        KDIST=IABS(IBCHAR(1,IA)-IBCHAR(1,IB))+IBCHAR(2,IA)+IBCHAR(2,IB)
     &                                       +IBCHAR(3,IA)+IBCHAR(3,IB)
        KDIST = KDIST/2
      ELSE IF (IBCHAR(2,IA).NE.IBCHAR(2,IB))  THEN
        KDIST=IABS(IBCHAR(2,IA)-IBCHAR(2,IB))+IBCHAR(3,IA)+IBCHAR(3,IB)
        KDIST = KDIST/2
      ELSE
        KDIST=IABS(IBCHAR(3,IA)-IBCHAR(3,IB))/2
      ENDIF
C
      RETURN
      END
      SUBROUTINE  DEVIAT (VAR,CO,COX,COWRK,LFLAG,WRK,
     &                    ATNAME,RENAME,NMBRES)
C
C  THIS SUBROUTINE COMPUTES THE DEVIATIONS OF ATOM POSITIONS INCOMPUTED
C  CONFORMATION FROM THOSE IN X-RAY DATA, WHEN TWO CONFORMATIONS ARE
C  SUPERIMPOSED ON EACH OTHER.
C  LARGER DEVIATED ATOMS AND MEAN DEVIATON FOR EACH RESIDUE ARE PRINTED
C  OUT.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*4  ATNAME(NUMATM),RENAME(NUMATM)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  VAR(NUMVAR),CO(3,NUMATM),COX(3,NUMATM),COWRK(3,NUMATM)
      DIMENSION  LFLAG(NUMATM),WRK(4,NUMRES),NMBRES(NUMATM)
      DATA  DEVMAX /2.0/,IPRMAX/100/
C
      CALL  GENRA (VAR,CO)
      DO  10  L = 1, 3
      DO  10  I = 1, NUMATM
  10    COWRK(L,I) = CO(L,I)
C
      CALL  BSTFTX (NUMATM,COX,COWRK,LFLAG,1,RMS)
C
      DO  20  I = 1, NUMRES
        WRK(1,I) = 0.D0
        WRK(2,I) = 0.D0
        WRK(3,I) = 0.D0
        WRK(4,I) = 0.D0
  20  CONTINUE
C
      WRITE(IOUT06,200) DEVMAX
      WRITE(IOUT02,200) DEVMAX
      JPR = 0
C
      DO  30  I = 1, NUMATM
        IF (LFLAG(I).GE.1)  THEN
          D = (COWRK(1,I)-COX(1,I))**2 + (COWRK(2,I)-COX(2,I))**2
     &        + (COWRK(3,I)-COX(3,I))**2
          IF (DSQRT(D).GT.DEVMAX)  THEN
            JPR = JPR + 1
            IF (JPR.LE.IPRMAX)  THEN
              WRITE(IOUT06,100) ATNAME(I),RENAME(I),NMBRES(I),DSQRT(D)
              WRITE(IOUT02,100) ATNAME(I),RENAME(I),NMBRES(I),DSQRT(D)
  100         FORMAT('  ',10X,A4,1X,A4,I5,F10.2)
            ENDIF
          ENDIF
          IRES = NMBRES(I)
          WRK(1,IRES) = WRK(1,IRES) + D
          WRK(2,IRES) = WRK(2,IRES) + 1.
          IF (LFLAG(I).GE.2)  THEN
            WRK(3,IRES) = WRK(3,IRES) + D
            WRK(4,IRES) = WRK(4,IRES) + 1.
          ENDIF
        ENDIF
  30  CONTINUE
C
      WRITE(IOUT06,110) JPR
      WRITE(IOUT06,120) RMS
      WRITE(IOUT06,210)
      WRITE(IOUT02,110) JPR
      WRITE(IOUT02,120) RMS
      WRITE(IOUT02,210)
      DO  40  I = 1, NUMRES-2
        IF (WRK(2,I).NE.0.)  WRK(1,I) = WRK(1,I)/WRK(2,I)
        IF (WRK(4,I).NE.0.)  WRK(3,I) = WRK(3,I)/WRK(4,I)
        WRITE(IOUT06,130) I,WRK(1,I),WRK(3,I)
        WRITE(IOUT02,130) I,WRK(1,I),WRK(3,I)
  40  CONTINUE
C
      RETURN
  110 FORMAT('       NO. OF ATOMS WITH LARGER DEVIATON : ',I6)
  120 FORMAT('0      R.M.S. DEVIATON (ALL ATOMS)=',F8.3)
  130 FORMAT(' ',10X,I5,5X,F10.2,5X,F10.2)
  200 FORMAT('0 *****  DEVIATIONS FROM THE X-RAY DATA  *****'//
     &       '    ATOM LIST THAT DEVIATES FROM X-RAY DATA BY MORE THAN' 
     &      ,F4.1,'(A)'/)
  210 FORMAT('0',10X,'<<MEAN DEVIATON OF EACH RESIDUE>>'/
     &       ' ',10X,'RES.#      ALL ATOM     BACKBONE ONLY')
      END
      SUBROUTINE  BSTFTX (N,CO1,CO2,IFLAG,IMS,RMS)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION  A(3,3)
      DIMENSION  CO1(3,N),CO2(3,N),IFLAG(N)
      DIMENSION  XC1(3),XC2(3)
C
      DO  10  K = 1, 3
        XC1(K) = 0.0
        XC2(K) = 0.0
  10  CONTINUE
C
      NATOM=0
      DO  14  NA = 1, N
        IF (IFLAG(NA).GE.IMS)  THEN
          NATOM=NATOM+1
          DO  12  K = 1, 3
            XC1(K) = XC1(K) + CO1(K,NA)
            XC2(K) = XC2(K) + CO2(K,NA)
  12      CONTINUE
        ENDIF
  14  CONTINUE
C
      DO  18  K = 1, 3
        XC1(K) = XC1(K)/NATOM
        XC2(K) = XC2(K)/NATOM
        DO  16  NA = 1, N
          CO1(K,NA) = CO1(K,NA) - XC1(K)
          CO2(K,NA) = CO2(K,NA) - XC2(K)
  16    CONTINUE
  18  CONTINUE
C
      DO  32  I = 1, 3
      DO  32  J = 1, 3
        A(I,J) = 0.0
        DO  30  NA = 1, N
          IF (IFLAG(NA).GE.IMS)  THEN
            A(I,J) = A(I,J) + CO1(I,NA)*CO2(J,NA)
          ENDIF
  30    CONTINUE
  32  CONTINUE
C
      CALL  BSTFT0 (N,CO2,A)
C
      RMS = 0.D0
      DO  80  NA = 1, N
        IF (IFLAG(NA).GE.IMS)  THEN
          XD = CO2(1,NA) - CO1(1,NA)
          YD = CO2(2,NA) - CO1(2,NA)
          ZD = CO2(3,NA) - CO1(3,NA)
          RMS = RMS + XD*XD + YD*YD + ZD*ZD
        ENDIF
  80  CONTINUE
C
      RMS = SQRT(RMS/NATOM)
C
      RETURN
      END
      SUBROUTINE  BSTFT0 (N,CO2,A)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION  A(3,3),U(3,3),V(3,3),R(3,3),D(3),WK(3),C(3)
      DIMENSION  CO2(3,N)
C
      DETA = A(1,1)*A(2,2)*A(3,3) + A(1,2)*A(2,3)*A(3,1)
     &     + A(1,3)*A(2,1)*A(3,2) - A(3,1)*A(2,2)*A(1,3)
     &     - A(3,2)*A(2,3)*A(1,1) - A(3,3)*A(2,1)*A(1,2)
C
      CALL  SVDD (A,3,3,3,3,D,U,3,V,3,WK,IER)
C
      IF (DETA.GT.0.)  THEN
        DO  60  I = 1, 3
        DO  60  J = 1, 3
  60      R(I,J) = U(I,1)*V(J,1)+U(I,2)*V(J,2)+U(I,3)*V(J,3)
      ELSE IF (DETA.LT.0.)  THEN
        DO  62  I = 1, 3
        DO  62  J = 1, 3
  62      R(I,J) = U(I,1)*V(J,1)+U(I,2)*V(J,2)-U(I,3)*V(J,3)
      ELSE
        PRINT *,'**  ERROR IN CALCULATION OF DETERMINANT. **'
      ENDIF
C
      DO  80  NA = 1, N
          C(1) = R(1,1)*CO2(1,NA)+R(1,2)*CO2(2,NA)+R(1,3)*CO2(3,NA)
          C(2) = R(2,1)*CO2(1,NA)+R(2,2)*CO2(2,NA)+R(2,3)*CO2(3,NA)
          C(3) = R(3,1)*CO2(1,NA)+R(3,2)*CO2(2,NA)+R(3,3)*CO2(3,NA)
          CO2(1,NA) = C(1)
          CO2(2,NA) = C(2)
          CO2(3,NA) = C(3)
  80  CONTINUE
C
      RETURN
      END
C#NUMPAC#SVDD                REVISED ON 1984-11-30
      SUBROUTINE SVDD(A,KA,M,N,ISW,Q,U,KU,V,KV,W,IND)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(KA,N),U(KU,N),V(KV,*),Q(N),W(N)
      IND=30000
      MN=MIN0(M,N)
      IF(MN.LT.1.OR.M.GT.KA.OR.M.GT.KU) GO TO 490
      MU=ISW/2
      MV=MOD(ISW,2)
      IF(MU.LT.0.OR.MU.GT.1.OR.MV.LT.0.OR.MV.GT.1) GO TO 490
      IF(MV.EQ.1.AND.N.GT.KV) GO TO 490
      M1N=MIN0(M+1,N)
      DO 10 J=1,N
      DO 10 I=1,M
   10 U(I,J)=A(I,J)
      ANORM=0.
      G=0.
      DO 100 I=1,M1N
      Q(I)=0.
      W(I)=G
      IF(I.GT.M) GO TO 100
      IP1=I+1
      G=U(I,I)
      IF(I.EQ.M) GO TO 30
      SUM=0.
      DO 20 K=I,M
   20 SUM=U(K,I)*U(K,I)+SUM
      S=SUM
      G=-DSIGN(DSQRT(S),G)
      H=U(I,I)*G-S
      U(I,I)=U(I,I)-G
   30 Q(I)=G
      IF(I.EQ.N) GO TO 100
      IF(S.EQ.0..OR.I.EQ.M) GO TO 60
      DO 50 J=IP1,N
      SUM=0.
      DO 40 K=I,M
   40 SUM=U(K,I)*U(K,J)+SUM
      F=SUM/H
      DO 50 K=I,M
   50 U(K,J)=U(K,I)*F+U(K,J)
   60 G=U(I,IP1)
      IF(IP1.EQ.N) GO TO 100
      SUM=0.
      DO 70 K=IP1,N
   70 SUM=U(I,K)*U(I,K)+SUM
      S=SUM
      G=-DSIGN(DSQRT(S),G)
      H=U(I,IP1)*G-S
      U(I,IP1)=U(I,IP1)-G
      IF(S.EQ.0..OR.I.EQ.M) GO TO 100
      DO 90 J=IP1,M
      SUM=0.
      DO 80 K=IP1,N
   80 SUM=U(I,K)*U(J,K)+SUM
      F=SUM/H
      DO 90 K=IP1,N
   90 U(J,K)=U(I,K)*F+U(J,K)
  100 ANORM=DMAX1(DABS(Q(I))+DABS(W(I)),ANORM)
      TOL=DMACH(TOL)*ANORM
      IF(MV.EQ.0) GO TO 180
      DO 170 II=1,M1N
      I=M1N+1-II
      IF(I.EQ.N) GO TO 170
      IP1=I+1
      IF(I.EQ.M1N) GO TO 150
      IF(IP1.EQ.N.OR.W(IP1).EQ.0.) GO TO 130
      H=U(I,IP1)*W(IP1)
      DO 120 J=IP1,M1N
      SUM=0.
      DO 110 K=IP1,N
  110 SUM=U(I,K)*V(K,J)+SUM
      F=SUM/H
      DO 120 K=IP1,N
  120 V(K,J)=U(I,K)*F+V(K,J)
  130 DO 140 J=IP1,M1N
  140 V(I,J)=0.
  150 DO 160 J=IP1,N
  160 V(J,I)=0.
  170 V(I,I)=1.
  180 IF(MU.EQ.0) GO TO 260
      DO 250 II=1,MN
      I=MN+1-II
      IF(I.EQ.MN) GO TO 200
      IP1=I+1
      DO 190 J=IP1,MN
  190 U(I,J)=0.
  200 IF(Q(I).EQ.0.) GO TO 250
      IF(I.EQ.MN) GO TO 230
      H=U(I,I)*Q(I)
      DO 220 J=IP1,MN
      SUM=0.
      DO 210 K=IP1,M
  210 SUM=U(K,I)*U(K,J)+SUM
      F=SUM/H
      DO 220 K=I,M
  220 U(K,J)=U(K,I)*F+U(K,J)
  230 DO 240 K=I,M
  240 U(K,I)=U(K,I)/Q(I)
  250 IF(I.LT.M.OR.Q(I).EQ.0.) U(I,I)=U(I,I)+1.
  260 IF(ANORM.EQ.0.) GO TO 470
      DO 390 KK=1,M1N
      K=M1N+1-KK
      DO 360 IT=1,30
      DO 270 LL=1,K
      L=K+1-LL
      IF(DABS(W(L)).LT.TOL) GO TO 310
      IF(DABS(Q(L)).LT.TOL) GO TO 280
  270 CONTINUE
  280 C=0.
      S=-1.
      DO 300 II=2,L
      I=L+1-II
      F=-W(I+1)*S
      W(I+1)=W(I+1)*C
      IF(DABS(F).LT.TOL) GO TO 310
      G=Q(I)
      Q(I)=DSQRT(G*G+F*F)
      C=G/Q(I)
      S=F/Q(I)
      IF(MV.EQ.0) GO TO 300
      DO 290 J=1,N
      X=V(J,I)
      V(J,I)=V(J,L)*S+X*C
  290 V(J,L)=V(J,L)*C-X*S
  300 CONTINUE
  310 IF(L.EQ.K) GO TO 370
      G=W(K-1)
      H=W(K)
      X=Q(L)
      Y=Q(K-1)
      Z=Q(K)
      F=((Y-Z)*(Y+Z)+(G-H)*(G+H))/(H*Y*2.)
      F=((X-Z)*(X+Z)+H*(Y/(DSIGN(DSQRT(F*F+1.),F)+F)-H))/X
      C=1.
      S=1.
      LP1=L+1
      DO 350 I=LP1,K
      H=W(I)*S
      G=W(I)*C
      W(I-1)=DSQRT(F*F+H*H)
      C=F/W(I-1)
      S=H/W(I-1)
      F=X*C+G*S
      G=G*C-X*S
      H=Q(I)*S
      Y=Q(I)*C
      IF(MV.EQ.0) GO TO 330
      DO 320 J=1,N
      X=V(J,I-1)
      V(J,I-1)=V(J,I)*S+X*C
  320 V(J,I)=V(J,I)*C-X*S
  330 Q(I-1)=DSQRT(F*F+H*H)
      C=F/Q(I-1)
      S=H/Q(I-1)
      F=G*C+Y*S
      X=Y*C-G*S
      IF(MU.EQ.0) GO TO 350
      DO 340 J=1,M
      Y=U(J,I-1)
      U(J,I-1)=U(J,I)*S+Y*C
  340 U(J,I)=U(J,I)*C-Y*S
  350 CONTINUE
      W(L)=0.
      W(K)=F
  360 Q(K)=X
      GO TO 480
  370 IF(Q(K).GE.0.) GO TO 390
      Q(K)=-Q(K)
      IF(MV.EQ.0) GO TO 390
      DO 380 J=1,N
  380 V(J,K)=-V(J,K)
  390 CONTINUE
      IF(N.EQ.1) GO TO 470
      K=MN
  400 L=1
      II=1
      LL=1
      DO 420 I=2,K
      IF(Q(I).GT.Q(L)) GO TO 410
      L=I
      GO TO 420
  410 II=I
      LL=L
  420 CONTINUE
      IF(II.EQ.LL) GO TO 460
      S=Q(II)
      Q(II)=Q(LL)
      Q(LL)=S
      IF(MV.EQ.0) GO TO 440
      DO 430 J=1,N
      S=V(J,II)
      V(J,II)=V(J,LL)
  430 V(J,LL)=S
  440 IF(MU.EQ.0) GO TO 460
      DO 450 J=1,M
      S=U(J,II)
      U(J,II)=U(J,LL)
  450 U(J,LL)=S
  460 K=II-1
      IF(K.GE.2) GO TO 400
  470 IND=0
      RETURN
  480 IND=20000
  490 RETURN
      END
C#NUMPAC#DMACH               REVISED ON 1984-11-30
      FUNCTION DMACH(X)
      REAL*8 DMACH,X,ONE,EPS
      DATA ONE,IFIRST/1.0D0,1/
      IF(IFIRST.EQ.0) GO TO 20
      IFIRST=0
      EPS=ONE
   10 EPS=EPS*0.5D0
      IF(EPS+ONE.NE.ONE) GO TO 10
      EPS=EPS+EPS
   20 DMACH=EPS
      RETURN
      END
      SUBROUTINE  CNVTDR (INDXV,ANGLES,VAR)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
      PARAMETER (PI=3.141 592 653 589 793D0,RAD=PI/180.D0)
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  INDXV(MAXVAR),ANGLES(10,MAXRES),VAR(MAXVAR)
C
C CONVERT UNITS OF DIHEDRAL ANGLES FROM DEGREE TO RADIAN.
C
      DO  10  I = 1, NUMVAR
        J = INDXV(I)/100
        K = INDXV(I) - 100*J
        VAR(I) = ANGLES(K,J)*RAD
  10  CONTINUE
C
      RETURN
      END
      SUBROUTINE  CRDREF (CO)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (TABLE1)
      INCLUDE 'inc/table1'
CMSP  INCLUDE (ATOM)
      INCLUDE 'inc/atom'
CMSP  INCLUDE (BOND)
      INCLUDE 'inc/bond'
CMSP  INCLUDE (REFRNC)
      INCLUDE 'inc/refrnc'
C     PARAMETER  (MAXATM=3000,MAXVAR=800)
C     PARAMETER  (MXATM1=MAXATM+1,MVAR1=MAXVAR+1)
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/TABLE1/  IFRONT(MAXVAR),NBACK(0:MAXVAR),IBACK(2,0:MAXVAR)
C     COMMON/ATOM00/  KUNIT(MAXATM),KATOM(MXATM1),JATOM(MAXATM)
C     COMMON/ATOM01/  LATOM0(0:MAXVAR),LATOM1(MAXATM)
C     COMMON/BOND00/  DIRCOS(3,MAXVAR),IBND1(MAXVAR),IBND2(0:MVAR1)
C     COMMON/REFRNC/  REFCRD(3,MAXATM),REFANG(MAXVAR)
      DIMENSION  CO(3,MAXATM)
C FOLLOWING LINES ARE MOVED FROM INPUTA
      NATM1 = NUMATM + 1
      NVAR1 = NUMVAR + 1
      NN2 = NUMVAR*(NUMVAR+1)/2
      NPAIR1 = (NUMVAR+1)*(NUMVAR+2)/2
      IBND2(0) = 1
      IBND2(NUMVAR+1) = NUMATM+1
C  KATOM HAS NUMATM+1 ELEMENTS, NUMATM+1TH ELEMENT IS DEFINED AS FOLLOWS
      KATOM(NUMATM+1) = NUMATM+1
C* REFERENCE COORDINATES *
C
C          UNIT 0
C
      J2 = KATOM(IBND2(1))-1
      DO  10  J = 1, J2
        K = JATOM(J)
        CO(1,K) = REFCRD(1,K)
        CO(2,K) = REFCRD(2,K)
        CO(3,K) = REFCRD(3,K)
  10  CONTINUE
C
      IF (NBACK(0).GT.0)  THEN
        DO  20  I = 1, NBACK(0)
          K = IBND2(IBACK(I,0))
          CO(1,K) = REFCRD(1,K)
          CO(2,K) = REFCRD(2,K)
          CO(3,K) = REFCRD(3,K)
  20    CONTINUE
      ENDIF
C
C          UNITS 1 TO NUMVAR
C
      NAT = 0
      LATOM0(NUMVAR) = 1
      DO  50  I = NUMVAR, 1, -1
        IU = IBND2(I)
        REFX0 = REFCRD(1,IU)
        REFY0 = REFCRD(2,IU)
        REFZ0 = REFCRD(3,IU)
C
        J1 = KATOM(IU) + 1
        J2 = KATOM(IBND2(I+1)) - 1
        IF (J1.LE.J2)  THEN
          DO  30  J = J1, J2
            K = JATOM(J)
            NAT = NAT + 1
            LATOM1(NAT) = K
            REFCRD(1,K) = REFCRD(1,K) - REFX0
            REFCRD(2,K) = REFCRD(2,K) - REFY0
            REFCRD(3,K) = REFCRD(3,K) - REFZ0
  30      CONTINUE
        ENDIF
C
        IF (NBACK(I).GT.0)  THEN
          DO  40  J = 1, NBACK(I)
            K = IBND2(IBACK(J,I))
            NAT = NAT + 1
            LATOM1(NAT) = K
            REFCRD(1,K) = REFCRD(1,K) - REFX0
            REFCRD(2,K) = REFCRD(2,K) - REFY0
            REFCRD(3,K) = REFCRD(3,K) - REFZ0
  40      CONTINUE
        ENDIF
        LATOM0(I-1) = NAT + 1
C
  50  CONTINUE
C
      RETURN
      END
      SUBROUTINE  OUT001
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
      CHARACTER  TITLE1*80
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      COMMON/TITLE1/  TITLE1
C
      WRITE(IOUT06,300) TITLE1
      WRITE(IOUT06,310) NUMATM,NUMVAR,NUMRES,NUMINT,NSS
      WRITE(IOUT02,300) TITLE1
      WRITE(IOUT02,310) NUMATM,NUMVAR,NUMRES,NUMINT,NSS
C
  300 FORMAT(//' TITLE1 :  ',A80)
  310 FORMAT('0   NUMATM=',I4,',   NUMVAR=',I4,',   NUMRES=',I3,
     &       ',   NUMINT=',I8,',   NSS=',I2/)
C
      RETURN
      END
      SUBROUTINE  OUT002
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
        ETOTAL = ETOR + EES + ENB + ELOOP + ECYSTR
        WRITE(IOUT06,2000) ETOR,EES,ENB,ELOOP,ECYSTR,ETOTAL
        WRITE(IOUT02,2000) ETOR,EES,ENB,ELOOP,ECYSTR,ETOTAL
 2000   FORMAT('0',10X,'ETOR',10X,'EES',10X,'ENB',8X,
     &         'ELOOP',7X,'ECYSTR',7X,'ETOTAL'/' ',5X,1P6D13.5/)
      RETURN
      END
C---------------------------------------------------------------------
      SUBROUTINE  OUTMIN
C---------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
CMSP  INCLUDE (VARANG)
      INCLUDE 'inc/varang'
C     PARAMETER  (PI=3.141 592 653 589 793D0,DEG=180.D0/PI)
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
C     DIMENSION  VAR(NUMVAR),DF(NUMVAR)
C     DIMENSION  ANGLES(10,NUMRES),INDXV(NUMVAR)
C     DATA  JPUNCH /29/
C
C  OUTPUT THE LATEST VALUES OF VARIABLES.  ANGLES ARE IN UNITS OF
C  DEGREES.  THE ANGLES ARE RANGED BETWEEN -180 TO 180 DEGREES.
C  THIS OUTPUT CAN BE USED AS THE INITIAL DATA OF THE NEXT JOB OF
C  MINIMIZATION.
C
      DO  10  I = 1, NUMVAR
        J = INDXV(I)/100
        K = INDXV(I) - 100*J
C       ANG = VAR(I)*DEG
C       IF (ANG.LE.-180.D0.OR.ANG.GT.180.D0)THEN
C         ANGS = ANG + 180.D0
C         IANG = ANGS/360.D0
C         ANG = ANGS - 360.D0*IANG
C         IF (ANG.GT.0)  THEN
C           ANG = ANG - 180.D0
C         ELSE
C           ANG = ANG + 180.D0
C         ENDIF
C       ENDIF
        ANGRAD(K,J) = VAR(I)
  10  CONTINUE
C
      CALL WTANGL(IOUT32)
C
C  OUTPUT THE ENERGY VALUES, IF THE CONVERGENCE CRITERION IS SATISFIED
C  IN THE SUBROUTINE MINMIZ.
C
C     IF (IOPTN.EQ.0)  RETURN
C
C     WRITE(IOUT06,500) ETOR
C     WRITE(IOUT06,510) EES
C     WRITE(IOUT06,520) ENB
C     WRITE(IOUT06,530) ELOOP
C     WRITE(IOUT06,540) ECYSTR
C     WRITE(IOUT02,500) ETOR
C     WRITE(IOUT02,510) EES
C     WRITE(IOUT02,520) ENB
C     WRITE(IOUT02,530) ELOOP
C     WRITE(IOUT02,540) ECYSTR
C
C     ETOTAL = ETOR+EES+ENB+ELOOP+ECYSTR
C     WRITE(IOUT06,550) ETOTAL
C     WRITE(IOUT02,550) ETOTAL
C
C     WRITE(IOUT06,600) (I,DF(I),I=1,NUMVAR)
C     WRITE(IOUT02,600) (I,DF(I),I=1,NUMVAR)
C
C 500 FORMAT(/'0  CONFORMATIONAL ENERGIES (KCAL/MOL):'/
C    &       '0',5X,'ETOR  ',1PD15.5,3X,'(TORSIONAL)')
C 510 FORMAT('0',5X,'EES   ',1PD15.5,3X,'(ELECTROSTATIC)')
C 520 FORMAT('0',5X,'ENB   ',1PD15.5,3X,'(NONBONDED)')
C 530 FORMAT('0',5X,'ELOOP ',1PD15.5,3X,'(LOOP-CLOSING)')
C 540 FORMAT('0',5X,'ECYSTR',1PD15.5,3X,'(CYSTINE TORSIONAL)')
C 550 FORMAT('0',5X,'ETOTAL',1PD15.5,3X,'(TOTAL)')
C 600 FORMAT('0'//'    GRADIENT (KCAL/MOL/RADIAN)'/
C    &      (' ',7(I5,1PD12.3,:':')))
      RETURN
      END
C-----------------------------------------------------------------------
      SUBROUTINE  OUTFMT(F0)
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
CMSP  INCLUDE (FMATRIX)
      INCLUDE 'inc/fmatrix'
C     DIMENSION  DF(MAXVAR),G(MXPAIR)
C
C  OUTPUT THE FIRST AND SECOND DERIVATIVES.
C  THIS OUTPUT CAN BE USED AS AN INPUT DATA OF THE NORMAL MODE
C  ANALYSIS.
C
      WRITE(IOUT36) NUMVAR,NN2,F0
      WRITE(IOUT36) (DF(I),I=1,NUMVAR)
      WRITE(IOUT36) (G(I),I=1,NN2)
C
      WRITE(IOUT06,600) (I,DF(I),I=1,NUMVAR)
      WRITE(IOUT02,600) (I,DF(I),I=1,NUMVAR)
C
  600 FORMAT('0'//'    GRADIENT (KCAL/MOL/RADIAN)'/
     &      (' ',7(I5,1PD12.3,:':')))
      RETURN
      END
C-----------------------------------------------------------------------
      SUBROUTINE  OUTSTD(ISF,CO,ANGLES,KSSPER,TITLE1,SEQATM,
     &                   SEQAA,ISEQRS)
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER    TITLE1*80,PROTID*72
      CHARACTER*4  SEQATM(NUMATM),SEQAA(NUMATM)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
C     INTEGER OUTFIL
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  CO(3,NUMATM),ANGLES(10,NUMRES),KSSPER(6,2,NSS)
      DIMENSION  ISEQRS(NUMATM)
C
C   LINKAGE AREA FOR INFORMATION
        COMMON /UNTCHN/ NEWUNT,NEWCHN,OLDUNT,OLDCHN
        CHARACTER*8     NEWUNT,NEWCHN,OLDUNT,OLDCHN
        CHARACTER*8 IDENT,ATTRIB
        CHARACTER*8 KHI(7),EKHI(7)
        CHARACTER*8 UNTID,CHNID
        CHARACTER   INFORM*24,RECS*1600
C   LINKAGE AREA  FOR CALCULATION
        CHARACTER*4 LAAN,LATN
        CHARACTER*8 CKEY,SKEY,MNCH
C
C   CONSTANT  FOR STATUS
        DATA LEV4/4/,LEV5/5/
C   CONSTANT  FOR LINKAGE
        DATA CKEY/'COODT   '/
        DATA SKEY/'SSBCNN3 '/
        DATA MNCH/'DIHDMNCH'/
        DATA EKHI/'EKHI1','EKHI2','EKHI3','EKHI4',
     &            'EKHI5','EKHI6','EKHI7'/
        OLDUNT=' '
        OLDCHN=' '
C
C  PROCESS
C
C* LEVEL 0 *     <TITLE1>
C* LEVEL 1 *     <PROTEIN>
        PROTID(1:72)=TITLE1(1:72)
        CALL HDLV0 (IOUT34,ISF,PROTID)
C* LEVEL 2 *     <UNIT>
        UNTID=OLDUNT
        CALL HDUNIT(IOUT34,UNTID)
C* LEVEL 3 *     <CHAIN>
        CHNID=OLDCHN
        CALL HDCHN (IOUT34,CHNID)
C
      DO 120 L=1,7
  120   KHI(L)=EKHI(L)
      IR0=0
      N=0
C
  150 N=N+1
      IF(N.GT.NUMATM) GO TO 300
      IR=ISEQRS(N)
      IF(IR.EQ.0) GO TO 150
      IF(IR.GT.NUMRES) GO TO 300
      IF(IR.EQ.IR0) GO TO 200
      IR0=IR
      IF(ISF.LE.0 .OR. ISF.GT.3) GO TO 300
C
C* LEVEL 4 *
C     <RESIDUE>  AMINO ACID NAME, RESIDUE NUMBER, DIHEDRAL ANGLE
C
        LEVEL=LEV4
        NR=0
        WRITE(IDENT,'(I4.4)') IR
       LAAN=SEQAA(N)
C
      CALL SETLMX(LMAX,LAAN)
C
       ATTRIB=' '
       RECS(1:1600)=' '
       ATTRIB(1:4)=LAAN(1:4)
       IF(ISF.EQ.3) GO TO 190
            WRITE(INFORM,'(3F8.3)') (ANGLES(L,IR+1),L=1,3)
            CALL ADINFO(MNCH, 24,INFORM,NR,RECS)
        IF(LMAX.GT.0) THEN
          DO 400 L=1,LMAX
            WRITE(INFORM,'(F8.3)')  ANGLES(3+L,IR+1)
            CALL ADINFO(KHI(L),8,INFORM,NR,RECS)
  400     CONTINUE
        END IF
  190 CONTINUE
        CALL WRSTD(IOUT34,LEVEL,IDENT,ATTRIB,NR,RECS)
  200 CONTINUE
C
C* LEVEL5 *
C     <ATOM>  ATOM NAME, COORDINATE, S-S BOND
C
      LEVEL=LEV5
        NR=0
        IDENT=' '
       LATN=SEQATM(N)
       IDENT(1:4)=LATN(1:4)
       ATTRIB=' '
       ATTRIB(1:1)=LATN(1:1)
       IF(ISF.NE.1) THEN
            WRITE(INFORM,'(3F8.3)') (CO(J,N),J=1,3)
            CALL ADINFO(CKEY,24,INFORM,NR,RECS)
       ENDIF
C
C * S-S BOND *
      NSGO=0
C
       IF(NSS.GE.1)  THEN
       IF(LAAN(1:3).EQ.'CYS' .AND. LATN(1:2).EQ.'SG') THEN
         DO 160 LSSB=1,NSS
           IF(NSGO.NE.0) GO TO 170
           KSS1=KSSPER(1,1,LSSB)
           KSS2=KSSPER(1,2,LSSB)
           IF(N.EQ.KSS1) THEN
             NSGO=KSS2
           ELSE IF(N.EQ.KSS2) THEN
             NSGO=KSS1
           END IF
  160    CONTINUE
         IF(NSGO.EQ.0) GO TO 180
  170    CONTINUE
         WRITE(INFORM,'(A4,4X,I4.4,12X)') SEQATM(NSGO),ISEQRS(NSGO)
         CALL ADINFO(SKEY,24,INFORM,NR,RECS)
       END IF
       END IF
C
  180  CONTINUE
C
       IF(.NOT.(ISF.EQ.1 .AND. NSGO.EQ.0))
     &        CALL WRSTD(IOUT34,LEVEL,IDENT,ATTRIB,NR,RECS)
C
           GO TO 150
C
  300  CALL OTSEND(IOUT34)
C
      RETURN
      END
      SUBROUTINE SETLMX(KMAX,MAAN)
      CHARACTER   MAAN*4,LAAN*3
      CHARACTER*3 IGLY,IALA,IVAL,ILEU,IILE,IMET,ISER,ITHR,IASN,IGLN
      CHARACTER*3 IPHE,ITRP,IPRO,IASP,IGLU,ILYS,IHIS,IARG,ITYR,ICYS
      DATA IGLY/'GLY'/,IALA/'ALA'/,IVAL/'VAL'/,ILEU/'LEU'/
      DATA IILE/'ILE'/,IMET/'MET'/
      DATA ISER/'SER'/,ITHR/'THR'/,IASN/'ASN'/,IGLN/'GLN'/
      DATA IPHE/'PHE'/,ITRP/'TRP'/,IPRO/'PRO'/
      DATA IASP/'ASP'/,IGLU/'GLU'/,ILYS/'LYS'/,IHIS/'HIS'/
      DATA IARG/'ARG'/,ITYR/'TYR'/,ICYS/'CYS'/
C
        KMAX=0
        LAAN(1:3)=MAAN(1:3)
C
        IF(LAAN.EQ.IGLY) THEN
          KMAX=0
        ELSE IF(LAAN.EQ.IALA) THEN
          KMAX=1
        ELSE IF(LAAN.EQ.IVAL) THEN
          KMAX=3
        ELSE IF(LAAN.EQ.ILEU) THEN
          KMAX=4
        ELSE IF(LAAN.EQ.IILE) THEN
          KMAX=4
        ELSE IF(LAAN.EQ.ISER) THEN
          KMAX=2
        ELSE IF(LAAN.EQ.ITHR) THEN
          KMAX=3
        ELSE IF(LAAN.EQ.IASN) THEN
          KMAX=3
        ELSE IF(LAAN.EQ.IGLN) THEN
          KMAX=4
        ELSE IF(LAAN.EQ.IMET) THEN
          KMAX=4
        ELSE IF(LAAN.EQ.IPHE) THEN
          KMAX=2
        ELSE IF(LAAN.EQ.ITRP) THEN
          KMAX=2
        ELSE IF(LAAN.EQ.IPRO) THEN
          KMAX=0
        ELSE IF(LAAN.EQ.IASP) THEN
          KMAX=3
        ELSE IF(LAAN.EQ.IGLU) THEN
          KMAX=4
        ELSE IF(LAAN.EQ.ILYS) THEN
          KMAX=5
        ELSE IF(LAAN.EQ.IARG) THEN
          KMAX=7
        ELSE IF(LAAN.EQ.IHIS) THEN
          KMAX=2
        ELSE IF(LAAN.EQ.ITYR) THEN
          KMAX=3
        ELSE IF(LAAN.EQ.ICYS) THEN
          KMAX=1
        END IF
      RETURN
      END
C
      SUBROUTINE OTSEND(OUTFIL)
      INTEGER OUTFIL
C
C  CONSTANT  FOR SUBCMD
      CHARACTER IDENT*8/' '/,ATTRIB*8/' '/
      CHARACTER RECS*800
C
C  PROCESS
C
      LEVEL=-1
        CALL WRSTD(OUTFIL,LEVEL,IDENT,ATTRIB,NR,RECS)
      RETURN
      END
C
C
      SUBROUTINE HDUNIT(OUTFIL,UNTID)
      INTEGER*4 OUTFIL
      CHARACTER UNTID*8,IDENT*8,ATTRIB*8,RECS*800
      DATA LEV2/2/
      NR=0
      RECS=' '
      LEVEL  = LEV2
      IDENT  = UNTID
      ATTRIB=' '
        CALL WRSTD(OUTFIL,LEVEL,IDENT,ATTRIB,NR,RECS)
      RETURN
      END
C
C
      SUBROUTINE  HDCHN(OUTFIL,CHNID)
      INTEGER*4 OUTFIL
      CHARACTER*8 IDENT,ATTRIB,CHNID
      CHARACTER*80 RECS
      DATA  LEV3/3/
      LEVEL = LEV3
      NR=0
      RECS=' '
      IDENT=CHNID
      ATTRIB = ' '
      RECS=' '
        CALL WRSTD(OUTFIL,LEVEL,IDENT,ATTRIB,NR,RECS)
      RETURN
      END
C
      SUBROUTINE HDLV0(OUTFIL,ISF,PROTID)
        INTEGER*4 OUTFIL,KM,ISF
        CHARACTER IDENT*8,ATTRIB*8,RECS*1600
        CHARACTER*8 EKHI,KEYKEY
C       CHARACTER*8 CKEY,MNCH,KEYKHI
        CHARACTER INFORM*32
        CHARACTER IDATE*7,MDATE*10,IKM*1
        CHARACTER TIME*10,ZONE*10
        integer t(8)
CMSP    CHARACTER IDATE*6,MDATE*8,IKM*1
        CHARACTER*8 METHOD,ECEPP/'ECEPP'/
        CHARACTER*8 MODIFY/'MODIFIED'/
        CHARACTER*72 PROTID
        CHARACTER KHI*4,KHIS*5
C     CONSTANT  FOR STATUS
        DATA LEV0/0/,LEV1/1/
C     CONSTANT  FOR LINKAGE
        DATA KEYKEY/'KEY     '/
        DATA EKHI/'EKHI'/
C
C  PROCESS
C
      IDENT='FEDEROUT'
!     CALL DATE(MDATE)
      CALL date_and_time(mdate,time,zone,t)
      IDATE(1:7)=MDATE(1:2)//MDATE(4:6)//MDATE(8:9)
CMSP  IDATE(1:6)=MDATE(1:2)//MDATE(4:5)//MDATE(7:8)
C
      LEVEL = LEV0
      RECS(1:1600)=' '
      ATTRIB = ' '
      NR=0
C
      INFORM=' '//IDATE//' FEDER '
      CALL ADINFO(MODIFY,24,INFORM,NR,RECS)
C
      RECS(NR*80+1:NR*80+8)=' ***    '
      RECS(NR*80+9:NR*80+80)=PROTID
      NR=NR+1
C
      IF(ISF.EQ.3) GO TO 9000
      INFORM='DIHDMNCH4 PHI,PSI,OMEGA 3F8.3'
      CALL ADINFO(KEYKEY,32,INFORM,NR,RECS)
C
      RECS(NR*80+1:NR*80+80)=' ***    DIHEDRAL ANGLES OF MAIN CHAIN'
      NR=NR+1
C
        KHI=EKHI
        METHOD=ECEPP
C
      DO 50 KM=1,7
        WRITE(IKM,'(I1)') KM
        KHIS=KHI//IKM
        INFORM=' '
        INFORM(1:8)=KHIS
        INFORM(9:10)='4 '
        INFORM(11:16)=KHIS(2:5)
        INFORM(17:24)=METHOD
        INFORM(25:32)='F8.3'
        CALL ADINFO(KEYKEY,32,INFORM,NR,RECS)
   50 CONTINUE
C
        RECS(NR*80+1:NR*80+80)=' ***    DIHEDRAL ANGLES OF SIDE CHAIN '
     &                         //'  BY '//METHOD//' FORMAT'
        NR=NR+1
C
 9000 CONTINUE
      IF(ISF.NE.1) THEN
        INFORM='COODT   5 ATOM CO-ORDTS 3F8.3'
        CALL ADINFO(KEYKEY,32,INFORM,NR,RECS)
C
        RECS(NR*80+1:NR*80+80)=' ***    CARTESIAN CO-ORDINATES OF ATOMS'
        NR=NR+1
      END IF
C
        INFORM='SSBCNN3 5 S-S BOND      2A8,8X'
        CALL ADINFO(KEYKEY,32,INFORM,NR,RECS)
C
        RECS(NR*80+1:NR*80+80)=' ***    DISULPHIDE BOND INSIDE A CHAIN'
        NR=NR+1
C
C
 9900 CONTINUE
        CALL WRSTD(OUTFIL,LEV0,IDENT,ATTRIB,NR,RECS)
C
        LEVEL = LEV1
        IDENT=' '
        NR=0
        ATTRIB=' '
        RECS=' '
          CALL WRSTD(OUTFIL,LEVEL,IDENT,ATTRIB,NR,RECS)
C
C
      RETURN
      END
C
C
      SUBROUTINE WRSTD(FL,LEVEL,IDENT,ATTRIB,NR,RECS)
      CHARACTER IDENT*8, ATTRIB*8, RECS*(*)
      INTEGER FL, LEVEL, NR
      CHARACTER*8 LEV0,LEV1,LEV2,LEV3,LEV4,LEV5,ENDL
      DATA LEV0 /'0       '/, LEV1 /'1       '/, LEV2 /'2       '/
      DATA LEV3 /'3       '/, LEV4 /'4       '/, LEV5 /'5       '/
      DATA ENDL /'END     '/
      IF(NR .EQ. 0)  NR=1
C
      IF(LEVEL .LT. 0)  THEN
        RECS = ENDL
        NR = 1
      ELSE
        IF (LEVEL .EQ. 0)  THEN
          RECS(1:8) = LEV0
        ELSE IF (LEVEL .EQ. 1)  THEN
          RECS(1:8) = LEV1
        ELSE IF (LEVEL .EQ. 2)  THEN
          RECS(1:8) = LEV2
        ELSE IF (LEVEL .EQ. 3)  THEN
          RECS(1:8) = LEV3
        ELSE IF (LEVEL .EQ. 4)  THEN
          RECS(1:8) = LEV4
        ELSE IF (LEVEL .EQ. 5)  THEN
          RECS(1:8) = LEV5
        ENDIF
C
        RECS( 9:16) = IDENT
        RECS(17:24) = ATTRIB
        RECS(25:40) = ' '
C
      ENDIF
C
      DO  10  I = 1, NR
  10    WRITE (FL,'(A80)') RECS(80*(I-1)+1:80*I)
C
      RETURN
      END
C
C
      SUBROUTINE ADINFO(KEY,NI,INFORM,NR,RECS)
      CHARACTER KEY*8, INFORM*(*), RECS*(*)
      INTEGER NI, NR
      CHARACTER*8 CONT,SPCE
      DATA CONT/'-       '/, SPCE/'        '/
      IF(.NOT.(NR .EQ. 0))  THEN
        IF(.NOT.(NR .EQ. 1))  THEN
          IF((RECS(80*(NR-1)+1 :80*(NR-1)+8)  .EQ. SPCE) .AND.
     &       (RECS(80*(NR-1)+41:80*(NR-1)+48) .EQ. SPCE)) THEN
              I=NR
              GO TO 2
          ELSE
              I=NR+1
              GO TO 1
          ENDIF
        ELSE IF(.NOT.(RECS(41:48) .EQ. SPCE))  THEN
           I=2
           GO TO 1
        ENDIF
      ENDIF
           I=1
           GO TO 2
C
 1    RECS(80*(I-1)+ 1:80*(I-1)+80) = ' '
      RECS(80*(I-1)+ 9:80*(I-1)+16) = KEY
      RECS(80*(I-1)+17:80*(I-1)+40) = INFORM
      NNI = 25
        GO TO 4
 2    RECS(80*(I-1)+41:80*(I-1)+48) = KEY
      RECS(80*(I-1)+49:80*(I-1)+72) = INFORM
      NNI = 25
      I = I+1
C
 3     IF(NNI .GT. NI)  GOTO  3012
      RECS(80*(I-1)+ 1:80*(I-1)+80) = ' '
      RECS(80*(I-1)+ 9:80*(I-1)+16) = CONT
      RECS(80*(I-1)+17:80*(I-1)+40) = INFORM(NNI:NI)
      NNI = NNI + 24
 4     IF(.NOT.(NNI .GT. NI))GOTO  3015
          I=I+1
          GOTO  3012
C
 3015 RECS(80*(I-1)+41:80*(I-1)+48) = CONT
      RECS(80*(I-1)+49:80*(I-1)+72) = INFORM(NNI:NI)
      NNI = NNI + 24
      I=I+1
      IF(I.LE.LEN(RECS)/80) GOTO  3
C
 3012 NR = I-1
      RETURN
      END
C
      SUBROUTINE  WRIT32 (VAR,CO,DF,G)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMVAR/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  VAR(NUMVAR),CO(3,NUMATM),DF(NUMVAR),G(NN2)
            WRITE(32)   (VAR(K),K=1,NUMVAR)
            WRITE(32)   ((CO(L,K),L=1,3),K=1,NUMATM)
            WRITE(32)   (DF(K),K=1,NUMVAR)
            WRITE(32)   (G(K),K=1,NN2)
      RETURN
      END
      SUBROUTINE  RMSDEV (VAR,CO,COX,COWRK,LFLAG)
C
C  CALCULATE R.M.S. DEVIATION
C
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  VAR(NUMVAR),CO(3,NUMATM)
      DIMENSION  COX(3,NUMATM),COWRK(3,NUMATM),LFLAG(NUMATM)
C
        CALL  GENRA (VAR,CO)
        DO  10  L = 1, 3
        DO  10  I = 1, NUMATM
  10      COWRK(L,I) = CO(L,I)
C
C ALL ATOMS
C
        CALL  BSTFTX (NUMATM,COX,COWRK,LFLAG,1,RMS)
        WRITE(IOUT06,450) RMS
        WRITE(IOUT02,450) RMS
C
C BACKBONE ATOMS ONLY
C
        CALL  BSTFTX (NUMATM,COX,COWRK,LFLAG,2,RMS)
        WRITE(IOUT06,452) RMS
        WRITE(IOUT02,452) RMS
C
  450 FORMAT('0 R.M.S. DEVIATION (ALL ATOMS)     =',F8.3)
  452 FORMAT('0 R.M.S. DEVIATION (BACKBONE ATOMS)=',F8.3)
C
      RETURN
      END
      SUBROUTINE  MINMZ2 (N,NN2,F0,X,DF,G,G0,P,Y,WRK1,WRK2,IPERM,LD,
     &                 MAXITR,AMBDA,CONV,FUNC,DERVTV,ICONV,CO,CHARGE)
C
C* MINIMIZER *
C
C   DOES NOT USE EXTRA-STORAGE OF SUPERCOMPUTER
C
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL  FUNC,DERVTV
      REAL*4 TIME,TLIMIT
CMSP  INCLUDE(MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
C
C        ***  PARAMETER DESCRIPTION  ***
C
C   N         INPUT   THE NUMBER OF VARIABLES
C   NN2       INPUT   N*(N+1)/2.  THE DIMENSION OF G.
C   X(N)      IN/OUT  IN: THE INITIAL GUESS OF THE MINIMIZER.
C                     OUT: THE LATEST APPROXI. TO THE MINIMIZER.
C   DF(N)     OUTPUT  THE GRADIENT AT THE LATEST POINT X.
C   G(NN2)    OUTPUT  THE HESSIAN AT THE LATEST POINT X.  THE (I,J)-TH
C                     ELEMENT OF THE HESSIAN IS IN THE (I*(I-1)/2+J)-TH
C                     ELEMENT OF G.
C
C   G0(NN2)        WORKING ARRAY.
C   P(N)           WORKING ARRAY.
C   Y(N)           WORKING ARRAY.
C   WRK1(N)        WORKING ARRAY.
C   WRK2(N)        WORKING ARRAY.
C   IPERM(N)       WORKING ARRAY.
C   LD(N)          WORKING ARRAY.
C
C   MAXITR    INPUT   MAXIMUM NUMBER OF ITERATION.
C   AMBDA     INPUT
C   CONV      INPUT   TOLERENCE ON THE DIFFERENCE IN THE FUNCTION
C                     VALUES OF THE TWO CONSECUTIVE ITERATIONS.
C   FUNC      INPUT   SUBROUTINE NAME THAT CALCULATES THE FUNCTION.
C   DERVTV    INPUT   SUBROUTINE NAME THET CALCULATES THE GRAD. AND HESS
C   ICONV     OUTPUT  FLAG WHETHER THE CONVERGENCE CRITERION IS
C                     SATISFIED.  IF SATISFIED, ICONV=1.
C
C
      COMMON/CCTIME/  ITIME,TLIMIT,LOUT,ITRS,LAMBDA,IREST
      DIMENSION  X(MAXVAR),DF(MAXVAR),G(MXPAIR),G0(MXPAIR),
     &           P(MAXVAR),Y(MAXVAR),IPERM(MAXVAR)
      DIMENSION  WRK1(MAXVAR),WRK2(MAXVAR),LD(MAXVAR)
      DIMENSION  CO(3,*),CHARGE(*)
      DATA  ZERO, ONE, HALF /0.D0, 1.D0, .5D0/
      PARAMETER (IGRMAX=100)
      DIMENSION  GX(IGRMAX),GY(IGRMAX)
C
      DELTA = 1.0D-3
      ESTM = 2.D0
      DO  10  L = 1, N
  10  LD(L) = L*(L+1)/2
      ICONV = 0
      ITIME = 0
      IGRPH  = ITRS
      IGRPH0 = ITRS-1
C
  1   CALL  DERVTV (X,F00,DF,G,CO,CHARGE)
      CALL  FUNC (X,F0,CO,CHARGE)
      if(F0 /= F00) then !CAK temtative
         write(iout06,'(a,2e)')'F0 and F00 are different',F0,F00
         write(iout02,'(a,2e)')'F0 and F00 are different',F0,F00
      endif
      WRITE(IOUT06,200) ITRS, F0
      WRITE(IOUT02,200) ITRS, F0
      GX(IGRPH-IGRPH0)=DBLE(IGRPH)
      GY(IGRPH-IGRPH0)=F0
      IGRPH = IGRPH + 1
      IF ((IGRPH - IGRPH0).GT.IGRMAX) THEN
        CALL FOUTGR(IOUT06, 70,20,IGRPH - IGRPH0 - 1,GX,GY)
        CALL FOUTGR(IOUT02,100,30,IGRPH - IGRPH0 - 1,GX,GY)
        IGRPH0 = IGRPH - 1
      END IF
C
C--------- ITERATION BEGINS ------------------------------------------
C
      NITR = MAXITR
      DO  1000  K = 1, NITR
C
        CALL  SVEC2 (N,NN2,DF,G,G0,P,Y,WRK1,WRK2,IPERM,LD,DELTA,AMBDA)
C
C    ------ LINE SEARCH ----------------------------
C
        STEP = ZERO
        DO  25  IJ = 1, N
  25      STEP = STEP + P(IJ)*P(IJ)
        STEP = ONE / DSQRT(STEP) * HALF
        IF (STEP.LT.HALF)  THEN
          DO  40  IJ = 1, N
  40        P(IJ) = P(IJ) * STEP
        ENDIF
C
        FPRE = F0
        CALL  KLINE (FUNC,N,F0,X,Y,P,ESTM,CO,CHARGE)
        JTRS = ITRS + K
        WRITE(IOUT06,200) JTRS,F0
        WRITE(IOUT02,200) JTRS,F0
        GX(IGRPH-IGRPH0)=DBLE(IGRPH)
        GY(IGRPH-IGRPH0)=F0
        IGRPH = IGRPH + 1
        IF ((IGRPH - IGRPH0).GT.IGRMAX) THEN
          CALL FOUTGR(IOUT06, 70,20,IGRPH - IGRPH0 - 1,GX,GY)
          CALL FOUTGR(IOUT02,100,30,IGRPH - IGRPH0 - 1,GX,GY)
          IGRPH0 = IGRPH - 1
        END IF
C
C    ---- CHECK CONVERGENCE ------------------------
C
        IF (FPRE-F0.LT.CONV)  THEN
          IF (.NOT.(AMBDA.EQ.ZERO.OR.LAMBDA.EQ.0))  THEN
            AMBDA = ZERO
            GOTO  1
          ENDIF
          IF (IREST.EQ.1) THEN
            CALL  PTANGL (IOUT40,X,JTRS)
          END IF
          ICONV = 1
          MAXITR = K
          CALL  DERVTV (X,F00,DF,G,CO,CHARGE)
          GOTO 2000
        ENDIF
C
C    ---- CHECK CPU TIME ---------------------------
C
        CALL  SECOND(TIME)
CKM     CALL  CLOCK(TIME,5)
!       IF (TIME.GE.TLIMIT)  THEN
!         IF (IREST.EQ.1) THEN
!           CALL  PTANGL (IOUT40,X,JTRS)
!         END IF
!         ITIME=1
!         GOTO 2000
!       ENDIF
C
C    ---- CHECK OUTPUT OPTION ----------------------
C
        IF (MOD(JTRS,LOUT).EQ.0.OR.K.EQ.NITR) THEN
          IF (IREST.EQ.1) THEN
            CALL  PTANGL (IOUT40,X,JTRS)
          END IF
        END IF
C
C    ---- CALCULATE DERIVATIVES --------------------
C
        CALL  DERVTV (X,F00,DF,G,CO,CHARGE)
C
 1000 CONTINUE
C
C--------- ITERATION ENDS --------------------------------------------
C
  200 FORMAT(' ',75X,'ITERATION NO.',I5,',  F0=',1PD20.12/
     &       ' ',17X,'*******')
C
 2000 IF ((IGRPH - IGRPH0 - 1).GT.0) THEN
        CALL FOUTGR(IOUT06, 70,20,IGRPH - IGRPH0 - 1,GX,GY)
        CALL FOUTGR(IOUT02,100,30,IGRPH - IGRPH0 - 1,GX,GY)
      END IF
      RETURN
      END
      SUBROUTINE  SVEC2 (N,NN2,GRAD,DIA,DIA0,XDEL,DIAGM,WRK1,WRK2,
     &                  IPERM,LD,DELTA,AMBDA)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (UNITNUMS)
      INCLUDE 'inc/unitnums'
      DIMENSION  GRAD(N),DIA(NN2),XDEL(N),DIAGM(N)
      DIMENSION  WRK1(N),WRK2(N),IPERM(N),LD(N)
      DIMENSION  DIA0(NN2)
C
        DO  10  I = 1, NN2
  10      DIA0(I) = DIA(I)
C   -----------------------------------------------------------------
      DO  1000  ML = 1, 99
C
        CALL  MODCH (N,NN2,DIA,DIAGM,WRK1,WRK2,IPERM,LD,DELTA,AMBDA)
C
        DMAX = 0.D0
        DO  20  IL = 1, N
  20    DMAX = DMAX1(DMAX,DIAGM(IL))
C
        IF (DMAX.NE.0.D0)  THEN
C         WRITE(IOUT06,2010) 'NEG',ML,DMAX,AMBDA
          IF (AMBDA.EQ.0.D0)  GOTO  2000
          AMBDA = 4.D0*AMBDA
           DO  12  I = 1, NN2
  12         DIA(I) = DIA0(I)
        ELSE
C         WRITE(IOUT06,2010) 'POS',ML,DMAX,AMBDA
          AMBDA = 0.5D0*AMBDA
          CALL  INV (N,NN2,DIA,GRAD,XDEL,IPERM,LD,WRK1)
          RETURN
        ENDIF
 1000 CONTINUE
C   -----------------------------------------------------------------
      WRITE(IOUT06,2020)
      WRITE(IOUT02,2020)
      STOP
 2000 WRITE(IOUT06,2030)
      WRITE(IOUT02,2030)
      STOP
 2010 FORMAT(' SVEC:  SHIFT HESS IS ',A3,' AT TRIAL=',I2,':   DMAX=',
     &     1PD10.3,',  AMBDA=',D10.3)
 2020 FORMAT('0    ***  SVEC HAS EXHAUSTED ]]]   ***')
 2030 FORMAT('0    ***  AMBDA=0.0,  BUT NOT CONVERGED ]]]      ***'/
     &       '     ***  CHECK THE CALCULATION OF DERIVATIVES   ***')
C     DEBUG SUBCHK
      END
      SUBROUTINE  MODCH (N,NN2,AD,DIAGM,TEMP,CDIAG,IPERM,LD,DELTA,AMBDA)
C*******************************************************************
C                ROUTINE FOR CHOLESKY
C*******************************************************************
C
C
C VERSION WITH COLUMN AND ROW EXCHANGE
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION  AD(NN2),DIAGM(N),TEMP(N),CDIAG(N),IPERM(N),LD(N)
C
C ADD AMBDA TO DIAGONAL ELEMENTS AND INITIALIZE IPERM.
C
*VOPTION VEC
      DO  2  L = 1, N
        AD(LD(L)) = AD(LD(L)) + AMBDA
        IPERM(L) = L
   2  CONTINUE
C
C IPERM(L)=K MEANS L NEW ORDER AND K OLD ORDER
C AD IS CHANGED IN PLACE
C
C MBOUND CALCULATES THE UPPER BOUND ON THE ELEMENTS OF THE
C D(K)*L(I,K)**2 < BSQ
C
      CALL  MBOUND (N,NN2,AD,BSQ,CDIAG,JQ,DM)
C
C EXCHANGE JQ AND 1 IN AD AND CDIAG
C
      IF (JQ.EQ.1)  GOTO  10
      IPERM(JQ) = 1
      IPERM(1) = JQ
      T = CDIAG(JQ)
      CDIAG(JQ) = CDIAG(1)
      CDIAG(1) = T
      INDJQ = JQ*(JQ+1)/2
      T = AD(INDJQ)
      AD(INDJQ) = AD(1)
      AD(1) = T
C
      DO  4  I = 2, N
        IND1 = LD(I-1)+1
        TEMP(I) = AD(IND1)
   4  CONTINUE
      IF (JQ.EQ.2)  GOTO  7
        IND2 = INDJQ - JQ + 1
*VOPTION VEC
      DO  5  I = 2, JQ-1
        IND1 = LD(I-1)+1
        IND2 = IND2+1
        AD(IND1) = AD(IND2)
   5  CONTINUE
        IND2 = INDJQ - JQ + 1
      DO  6  I = 2, JQ-1
        IND2 = IND2+1
        AD(IND2) = TEMP(I)
   6  CONTINUE
   7  IF (JQ.EQ.N)  GOTO  10
*VOPTION VEC
      DO  8  I = JQ+1, N
        IND1 = LD(I-1)+1
        IND2 = LD(I-1)+JQ
        AD(IND1) = AD(IND2)
   8  CONTINUE
      DO  9  I = JQ+1, N
        IND2 = LD(I-1)+JQ
        AD(IND2) = TEMP(I)
   9  CONTINUE
C
C CYCLE WITH J=1 EXTRA
C
C
C FIND MAX ON C(I,1)
C
  10  THETA = 0.D0
      DO  12  I = 1, N-1
        TC = DABS(AD(LD(I)+1))
        THETA = DMAX1 (THETA,TC)
  12  CONTINUE
C
C FIND NEW D1
C
      D1 = DMAX1 (DABS(AD(1)), DELTA, THETA*THETA/BSQ)
C
C DEFINE FIRST DIAGONAL ELEMENT
C
      DIAGM(1) = D1-AD(1)
      DINV = 1.D0/D1
      AD(1) = DINV
C
C UPDATE
C
      DO  20  I = 2, N
        IND = LD(I-1)+1
        TC1 = AD(IND)
        CDIAG(I) = CDIAG(I) - TC1*TC1*DINV
  20  CONTINUE
C
C LOOP OVER ALL COLUMNS FROM 2 TO N
C
C INDJ IS INDEX OF (J,J)
C
      INDJ=1
      DO  100  J = 2, N
        INDJ = INDJ+J
        J1 = J-1
C
C FIND INDEX JQ WITH MAX CDIAG
C
      IF (J.EQ.N)  GOTO  112
      JQ=J
      DM = DABS(CDIAG(J))
      DO  101  I = J+1, N
        TST = DABS(CDIAG(I))
        IF (TST.LE.DM)  GOTO  101
        DM = TST
        JQ = I
  101 CONTINUE
      IF (JQ.EQ.J)  GOTO  112
C
C EXCHANGE CDIAG AND AD AT JQ AND DEFINE IPERM
C INDJQ IS INDEX OF JQ
C
      INDJQ = JQ*(JQ+1)/2
      T = CDIAG(JQ)
      CDIAG(JQ) = CDIAG(J)
      CDIAG(J) = T
      T = AD(INDJQ)
      AD(INDJQ) = AD(INDJ)
      AD(INDJ) = T
      IT = IPERM(J)
      IPERM(J) = IPERM(JQ)
      IPERM(JQ) = IT
C
C EXCHANGE OFFDIAGONAL ELEMENTS OF AD
C
      IND1 = INDJ-J
      DO  102  IS = 1, J-1
        IND1 = IND1 + 1
        TEMP(IS) = AD(IND1)
  102 CONTINUE
      DO  103  IS = J, N
        IND1 = LD(IS-1) + J
        TEMP(IS) = AD(IND1)
  103 CONTINUE
      IND1 = INDJ-J
      IND2 = INDJQ-JQ
*VOPTION VEC
      DO  104  IS = 1, J-1
        IND1 = IND1 + 1
        IND2 = IND2 + 1
        AD(IND1) = AD(IND2)
  104 CONTINUE
      IND2 = INDJQ-JQ
      DO  105  IS = 1, J-1
        IND2 = IND2 + 1
        AD(IND2) = TEMP(IS)
  105 CONTINUE
      IND1 = INDJ+J
      IND20 = IND2+1
      IND2 = IND20
      IF (JQ.EQ.J+1)  GOTO  108
*VOPTION VEC
      DO  106  IS = J+1, JQ-1
        IND1 = LD(IS-1)+J
        IND2 = IND2+1
        AD(IND1) = AD(IND2)
  106 CONTINUE
      IND2 = IND20
      DO  107  IS = J+1, JQ-1
        IND2 = IND2 + 1
        AD(IND2) = TEMP(IS)
  107 CONTINUE
  108 IF (JQ.EQ.N)  GOTO  112
*VOPTION VEC
      DO  109  IS = JQ+1, N
        IND1 = LD(IS-1) + J
        IND2 = LD(IS-1) + JQ
        AD(IND1) = AD(IND2)
  109 CONTINUE
      DO  110  IS = JQ+1, N
        IND2 = LD(IS-1) + JQ
        AD(IND2) = TEMP(IS)
  110 CONTINUE
C
C CALCULATE L(J,IS)  IS=1,J-1  SAVE AND STORE
C
  112 IND1 = INDJ-J
      DO  113  IS = 1, J1
        IND0 = LD(IS)
        IND1 = IND1+1
  113   TEMP(IS) = AD(IND0)*AD(IND1)
      IND1 = INDJ-J
      DO  114  IS = 1, J1
        IND1 = IND1 + 1
        AD(IND1) = TEMP(IS)
  114 CONTINUE
C
C CALCULATE NEW C(I,J) AND STORE IN AD(IND0)
C
C IND0 IS INDEX OF(I,J)
C IND0 IS INDEX OF(I,IS), IS=1, J1
C FIND MAX OF C(I,J) STORED IN THETA
C
      THETA = 0.D0
      IF (J.EQ.N)  GOTO  200
      IND0 = INDJ
      DO  120  I = J, N-1
C
        IND0 = IND0+I
        IND1 = IND0-J
C
        TC = AD(IND0)
        DO  121  IS = 1, J1
          IND1 = IND1+1
  121     TC = TC - TEMP(IS)*AD(IND1)
        AD(IND0) = TC
        THETA = DMAX1 (DABS(TC), THETA)
  120 CONTINUE
C
C FIND NEW DJ
C
  200 DJ = DMAX1 (DABS(CDIAG(J)), DELTA, THETA*THETA/BSQ)
C
C DEFINE NEW DIAGONAL ELEMENT
C
      DIAGM(J) = DJ-CDIAG(J)
      DINV = 1.D0 /DJ
      AD(INDJ) = DINV
      IF (J.EQ.N)  GOTO  100
C
C UPDATE NEW DIAG
C
      DO  130  I = J+1, N
        IND0 = LD(I-1) + J
        TC1 = AD(IND0)
        CDIAG(I) = CDIAG(I) - TC1*TC1*DINV
  130 CONTINUE
  100 CONTINUE
C     WRITE(IOUT06,9000) BSQ
C9000 FORMAT(' MODCH:   BSQ=',1PD10.3)
      RETURN
      END
      SUBROUTINE  MBOUND (N,NN2,AD,BSQ,CDIAG,JQ,GAMMA)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION  AD(NN2),CDIAG(N)
      DATA  EPSLM/1.D-14/
C
C FIND MAX OF DIAGONAL ELEMENTS (GAMMA) AND MAX OF
C OFFDIAGONAL ELEMENTS (XI).
C
      GAMMA = DABS(AD(1))
      XI = 0.D0
      IND = 1
      JQ = 1
      CDIAG(1) = AD(1)
      DO  100  I = 2, N
        IND = IND + 1
        INDE = IND + I - 2
        DO  110  J = IND, INDE
          XI = DMAX1(XI,DABS(AD(IND)))
  110   CONTINUE
      IND = INDE+1
      CDIAG(I) = AD(IND)
      TC = DABS(AD(IND))
      IF (TC.LE.GAMMA)  GOTO  100
        JQ = I
        GAMMA = TC
  100 CONTINUE
      BSQ = DMAX1 (XI/N, GAMMA, EPSLM)
      RETURN
      END
      SUBROUTINE  KLINE (FUNC,N,VFUNC,VAR,VAR0,XDEL,ESTM0,CO,CHARGE)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
      DIMENSION  VAR(MAXVAR),VAR0(MAXVAR),XDEL(MAXVAR),
     &           CO(3,*),CHARGE(*)
      DATA  ZERO,HALF /0.D0,0.5D0/
      EA=VFUNC
      ESTM = ESTM0
      IC1 = 0
      IC2 = 0
      IC3 = 0
      IC4 = 0
      DO  1  L = 1, N
   1  VAR0(L) = VAR(L)
      STEP = ZERO
      DO  2  L = 1, N
   2  STEP = STEP + XDEL(L)*XDEL(L)
      STEP = DSQRT(STEP)
      EPSLM = 1.D-7/STEP
      HALFES = HALF*ESTM
      DO  10  L = 1, N
  10  VAR(L) = VAR0(L) + HALFES*XDEL(L)
      CALL  FUNC (VAR,EB,CO,CHARGE)
      IF (EA.LE.EB)  GOTO  3000
      DO  20  L = 1, N
  20  VAR(L) = VAR0(L) + ESTM*XDEL(L)
      CALL  FUNC (VAR,EC,CO,CHARGE)
C
C*******   SHIFT 1
C
 1500 IF (EA.GE.EB.AND.EB.GE.EC)  THEN
      IC1 = IC1+1
        EB = EC
        ESTM = ESTM+ESTM
        DO  30  L = 1, N
  30    VAR(L) = VAR0(L) + ESTM*XDEL(L)
        CALL  FUNC (VAR,EC,CO,CHARGE)
        GOTO  1500
      ENDIF
C
C*******   SHIFT 2
C
 1800 ESTMP = ESTM*HALF
 2000 IF (EA.LE.EC)  THEN
      IC2 = IC2+1
        ESTMP = HALF*ESTMP
        ESTM = ESTM - ESTMP
        IF (ESTMP.LT.EPSLM)  GOTO  5000
        DO  40  L = 1, N
  40    VAR(L) = VAR0(L) + ESTM*XDEL(L)
        CALL  FUNC (VAR,EC,CO,CHARGE)
        GOTO  2000
      ENDIF
C
C*******   SHIFT 3
C
 2500 IF (EB.GE.EC)  THEN
      IC3 = IC3+1
        ESTMP = HALF*ESTMP
        ESTM = ESTM + ESTMP
        IF (ESTMP.LT.EPSLM)  GOTO  5000
        DO  50  L = 1, N
  50    VAR(L) = VAR0(L) + ESTM*XDEL(L)
        CALL  FUNC (VAR,EC,CO,CHARGE)
        GOTO  2500
      ENDIF
          GOTO  5000
C
C*******   SHIFT 4
C
 3000 IF (EA.LE.EB)  THEN
      IC4 = IC4+1
        EC=EB
        ESTM = ESTM*HALF
        ESTMB = ESTM*HALF
        IF (ESTMB.LT.EPSLM)  RETURN
        DO  60  L = 1, N
  60    VAR(L) = VAR0(L) + ESTMB*XDEL(L)
        CALL  FUNC (VAR,EB,CO,CHARGE)
        GOTO  3000
      ENDIF
      IF (EA.LE.EC)  GOTO  1800
C
 5000 A = ZERO
      B = ESTM*HALF
      C = ESTM
C     WRITE(IOUT06,100) IC1,IC2,IC3,IC4
      IF (IC1+IC2+IC3+IC4.EQ.0)  GOTO  6000
      DO  70  L = 1, N
  70  VAR(L) = VAR0(L) + B*XDEL(L)
      CALL  FUNC (VAR,EB,CO,CHARGE)
      IF (EB.GE.EA)  GOTO  3000
 6000 D = 0.5D0*((B*B-C*C)*EA+(C*C-A*A)*EB+(A*A-B*B)*EC)/
     &    ((B-C)*EA+(C-A)*EB+(A-B)*EC)
      DO  80  L = 1, N
  80  VAR(L) = VAR0(L) + D*XDEL(L)
      CALL  FUNC (VAR,VFUNC,CO,CHARGE)
      IF (VFUNC.LT.EB)  THEN
C       WRITE(IOUT06,300) 'D',A,D,C
      ELSE
        VFUNC = EB
        DO  90  L = 1, N
  90    VAR(L) = VAR0(L) + B*XDEL(L)
C       WRITE(IOUT06,300) 'B',A,B,C
      ENDIF
C     WRITE(IOUT06,310) EA,VFUNC,EC
      RETURN
  100 FORMAT(' KLINE:    SHIFT1  SHIFT2  SHIFT3  SHIFT4'/' ',6X,4I8)
  300 FORMAT(' ',15X,'A',14X,A1,14X,'C'/' ',8X,1P3D15.7)
  310 FORMAT(' ',8X,1P3D15.7)
      END
      SUBROUTINE  INV (N,NN2,AD,GRAD,ST,IPERM,LD,STN)
C
C INV CALCULATES THE NEWTON STEP BY INVERTING AD
C AD*STN = -GRAD
C AD IS THE CHOLESKY DECOMPOSITION STORED IN COMPRESSED WAY
C THE DIAGONAL ELEMENTS OF AD ARE THE INVERSE OF D
C THE OFFDIAGNAL ELEMENTS ARE L
C STORAGE MODE: (1,1),(2,1),(2,2),(3,1),(3,2),...
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION  AD(NN2),GRAD(N),ST(N),IPERM(N),LD(N),STN(N)
C
C FIRST STEP INVERT L
C
      STN(1) = -GRAD(IPERM(1))
      IND = 0
      DO  20  I = 2, N
        TC = -GRAD(IPERM(I))
        IND = IND+1
        DO  10  J = 1, I-1
          IND = IND+1
  10      TC = TC - AD(IND)*STN(J)
        STN(I) = TC
  20  CONTINUE
C
C INVERT D
C
      DO  30  I = 1, N
  30    STN(I) = AD(LD(I))*STN(I)
C
C INVERT L TRANSPOSE
C
      DO  50  J = N-1, 1, -1
        TC = STN(J)
        DO  40  I = J+1, N
          IND = LD(I-1)+J
          TC = TC - AD(IND)*STN(I)
  40    CONTINUE
        STN(J) = TC
  50  CONTINUE
C
C PERM TO OLD ORDER
C
      DO  60  I = 1, N
  60    ST(IPERM(I)) = STN(I)
      RETURN
      END
      SUBROUTINE  GENRA (VAR,CO)
C
C  THIS SUBROUTINE GENERATES THE ATOMIC COORDINATES.
C
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXATM=3000,MAXVAR=800,MAXSTC=3)
      PARAMETER  (MAXSTC=3)
C     PARAMETER  (MXATM1=MAXATM+1,MVAR1=MAXVAR+1)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (ATOM)
      INCLUDE 'inc/atom'
CMSP  INCLUDE (BOND)
      INCLUDE 'inc/bond'
CMSP  INCLUDE (REFRNC)
      INCLUDE 'inc/refrnc'
CMSP  INCLUDE (TABLE1)
      INCLUDE 'inc/table1'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/ATOM00/  KUNIT(MAXATM),KATOM(MXATM1),JATOM(MAXATM)
C     COMMON/ATOM01/  LATOM0(0:MAXVAR),LATOM1(MAXATM)
C     COMMON/BOND00/  DIRCOS(3,MAXVAR),IBND1(MAXVAR),IBND2(0:MVAR1)
C     COMMON/REFRNC/  REFCRD(3,MAXATM),REFANG(MAXVAR)
C     COMMON/TABLE1/  IFRONT(MAXVAR),NBACK(0:MAXVAR),IBACK(2,0:MAXVAR)
      DIMENSION  VAR(NUMVAR),CO(3,NUMATM),LCYCL(3,3)
      DIMENSION  R(3,3),WR(3,3),WRR(9),RRST(9,MAXSTC),EMATRX(9)
      DIMENSION  CS(MAXVAR),SN(MAXVAR),CS1(MAXVAR)
      EQUIVALENCE  (WR,WRR)
      DATA  ZERO, ONE /0.D0, 1.D0/
      DATA  LCYCL /1,3,2,2,1,3,3,2,1/
      DATA  EMATRX /1.D0, 3*0.D0, 1.D0, 3*0.D0, 1.D0/
C*******************************
C     UNIT 0
C*******************************
      IMAXST = NBACK(0)
      DO  12  K = 1, IMAXST
        DO  10  I = 1, 9
  10      RRST(I,K) = EMATRX(I)
  12  CONTINUE
C*******************************
C     UNITS 1 TO NUMVAR
C*******************************
C
      DO  20  I = 1, NUMVAR
        ANG = VAR(I) - REFANG(I)
        CS(I) = DCOS(ANG)
        SN(I) = DSIN(ANG)
        CS1(I) = ONE - CS(I)
  20  CONTINUE
C
C   ----- DO LOOP 100 BEGINS -----
C
      DO  100  I = 1, NUMVAR
        L1 = IBND1(I)
        L2 = IBND2(I)
C
C  DIRECTION COSINE OF THE I-TH BOND.
C
        AB = ZERO
        DO  30  L = 1, 3
        DIRCOS(L,I) = CO(L,L2) - CO(L,L1)
  30    AB = AB + DIRCOS(L,I)*DIRCOS(L,I)
          AB = ONE / DSQRT(AB)
        DO  35  L = 1, 3
  35    DIRCOS(L,I) = DIRCOS(L,I)*AB
C
C  CONSTRUCT A ROTAIONAL MATRIX.
C
*VOPTION VEC
        DO  40  L = 1, 3
          LC1 = LCYCL(L,1)
          LC2 = LCYCL(L,2)
          U1 = CS1(I) * DIRCOS(LC1,I) * DIRCOS(LC2,I)
          U2 = SN(I)  * DIRCOS(LCYCL(L,3),I)
          R(LC1,LC2) = U1 - U2
          R(LC2,LC1) = U1 + U2
          R(L,L) = CS(I) + CS1(I)*DIRCOS(L,I)*DIRCOS(L,I)
  40    CONTINUE
        DO  50  L = 1, 3
          WR(L,1) = R(L,1)*RRST(1,IMAXST) + R(L,2)*RRST(2,IMAXST)
     &                 + R(L,3)*RRST(3,IMAXST)
          WR(L,2) = R(L,1)*RRST(4,IMAXST) + R(L,2)*RRST(5,IMAXST)
     &                 + R(L,3)*RRST(6,IMAXST)
          WR(L,3) = R(L,1)*RRST(7,IMAXST) + R(L,2)*RRST(8,IMAXST)
     &                 + R(L,3)*RRST(9,IMAXST)
  50    CONTINUE
C
C  ROTATE THE ATOMS JI TO JE AND ATTATCH THEM ON THE END OF THE I-TH
C  BOND (Q1,Q2,Q3).
C
        Q1 = CO(1,L2)
        Q2 = CO(2,L2)
        Q3 = CO(3,L2)
        JI = LATOM0(I)
        JE = LATOM0(I-1)-1
*VOPTION VEC
          DO  55  J = JI, JE
            K = LATOM1(J)
            CO(1,K)=WRR(1)*REFCRD(1,K)+WRR(4)*REFCRD(2,K)
     &                + WRR(7)*REFCRD(3,K) + Q1
            CO(2,K)=WRR(2)*REFCRD(1,K)+WRR(5)*REFCRD(2,K)
     &                + WRR(8)*REFCRD(3,K) + Q2
            CO(3,K)=WRR(3)*REFCRD(1,K)+WRR(6)*REFCRD(2,K)
     &                + WRR(9)*REFCRD(3,K) + Q3
  55      CONTINUE
C
C  UPDATE RRST
C
        IF (NBACK(I)-1)  80, 60, 70
  60      DO  65  L = 1, 9
  65      RRST(L,IMAXST) = WRR(L)
            GOTO  80
  70      DO  75  L = 1, 9
          RRST(L,IMAXST) = WRR(L)
  75      RRST(L,IMAXST+1) = WRR(L)
  80        IMAXST = IMAXST + NBACK(I) - 1
 100  CONTINUE
C
C   ----- DO LOOP 100 ENDS -------
C
      RETURN
      END
C     SUBROUTINE  ENRGYA (VAR,ETOTAL,NUMVAR,CO,CHARGE)
      SUBROUTINE  ENRGYA (VAR,ETOTAL,CO,CHARGE)
C
C  THIS SUBROUTINE COMPUTES THE CONFORMATIONAL ENERGY.
C
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXATM=3000,MAXVAR=800,MAXSS =5,MAXLEN=3500)
C     PARAMETER  (MAXSS2=MAXSS*2)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (INTER0)
      INCLUDE 'inc/inter0'
CMSP  INCLUDE (NBTYPE)
      INCLUDE 'inc/nbtype'
CMSP  INCLUDE (TORSN0)
      INCLUDE 'inc/torsn0'
CMSP  INCLUDE (SSPAIR)
      INCLUDE 'inc/sspair'
C     COMMON/NUMBER/  NUMATM,MUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/INTER0/  INTER(MAXATM),INTATM(3,MAXLEN)
C     COMMON/NBTYPE/  NBTYPE(MAXATM)
C     COMMON/TORSN0/  A(MAXVAR),NB(MAXVAR),NS(MAXVAR),IFTOR(MAXVAR)
C     COMMON/SSPAIR/  KSSPER(6,2,MAXSS),JSS(3,MAXSS),KSS(MAXSS2),
C    &                LSS(MAXSS2)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      DIMENSION  VAR(MAXVAR),CO(3,*),CHARGE(*)
      DIMENSION  WRK1(MAXATM),WRK2(MAXATM)
C
C  GENERATE THE ATOMIC COORDINATES.
C
      CALL  GENRA (VAR,CO)
C
C  INITIALIZE THE PARAMETERS.
C
      CALL  EZERO
C
C---  COMPUTE THE ENERGIES --------------------------------------
C
C <ENB & EES>
      CALL  ECALA (INTATM,CO,CHARGE,NBTYPE,WRK1,WRK2)
C
C <ETOR>
      CALL  ETORSN (A,NB,NS,IFTOR,VAR)
C
C <ELOOP & ECYSTR>
      IF (NSS.GE.1)  THEN
        DO  160  I = 1, NSS
          CALL  ECALSS (KSSPER(1,1,I),KSSPER(1,2,I),CO)
  160   CONTINUE
      ENDIF
C
C           <ETOTAL>
C
      ETOTAL = ETOR + EES + ENB + ELOOP + ECYSTR
C
      RETURN
      END
      SUBROUTINE  ECALA (INTATM,CO,CHARGE,NBTYPE,ENB00,RI)
C
C  THIS SUBROUTINE COMPUTES THE NONBONDED AND ELECTROSTATIC ENERGIES.
C
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/EPARAM/  PNB(28,56)
      DIMENSION   CO(3,NUMATM),CHARGE(NUMATM),NBTYPE(NUMATM)
      DIMENSION   INTATM(3,NUMINT)
      DIMENSION   ENB00(NUMATM),RI(NUMATM)
      DATA  ZERO,HALF,ONE,TWO /0.D0,0.5D0,1.D0,2.D0/
C
      MA = 1
C
      DO  100  L = 1, NUMINT
        QA  = CHARGE(MA)
        NBA = NBTYPE(MA)
        IATMI = MA + INTATM(1,L)
        NUM4 = INTATM(2,L)
        IATMF = IATMI + NUM4 - 1
        IF (NUM4.EQ.0)  GOTO  20
C
C  1-4 INTERACTION
C
        DO  10  MB = IATMI, IATMF
!         if(MA==MB)cycle !CAK temtative
          RI2 = ONE / ((CO(1,MA)-CO(1,MB))**2 + (CO(2,MA)-CO(2,MB))**2
     &                  + (CO(3,MA)-CO(3,MB))**2)
          RI(MB) = DSQRT(RI2)
          K = NBTYPE(MB)*2
          RO2 = PNB(NBA,K)*RI2
          IF (PNB(NBA,K-1).GE.ZERO)  THEN
            RO6 = RO2*RO2*RO2
            ENB00(MB) = PNB(NBA,K-1)*RO6*(HALF*RO6 - TWO)
          ELSE
            RO4 = RO2*RO2
            RO6 = RO2*RO4
            ENB00(MB) = -PNB(NBA,K-1)*RO6*(RO6 - TWO*RO4)
          ENDIF
  10    CONTINUE
C
        DO  12  MB = IATMI, IATMF
!         if(MA==MB)cycle !CAK temtative
            EES = EES + QA*CHARGE(MB)*RI(MB)
  12        ENB = ENB + ENB00(MB)
C
  20    KEY = INTATM(3,L)
        IF (KEY.EQ.0)  GOTO  40
        IATMI = IATMF + 1
        IATMF = NUMATM
        IF (KEY.GT.0)  IATMF = IATMI + KEY - 1
C
C  1-5 INTERACTION
C
        DO  30  MB = IATMI, IATMF
!         if(MA==MB)cycle !CAK temtative
          DUM001 =    ((CO(1,MA)-CO(1,MB))**2 + (CO(2,MA)-CO(2,MB))**2
     &                     + (CO(3,MA)-CO(3,MB))**2)
          IF (DUM001.EQ.0.D0) THEN
          ENDIF
          RI2 = ONE / ((CO(1,MA)-CO(1,MB))**2 + (CO(2,MA)-CO(2,MB))**2
     &                     + (CO(3,MA)-CO(3,MB))**2)
          RI(MB) = DSQRT(RI2)
          K = NBTYPE(MB)*2
          RO2 = PNB(NBA,K)*RI2
          IF (PNB(NBA,K-1).GE.ZERO)  THEN
            RO6 = RO2*RO2*RO2
            ENB00(MB) = PNB(NBA,K-1)*RO6*(RO6 - TWO)
          ELSE
            RO4 = RO2*RO2
            RO6 = RO2*RO4
            ENB00(MB) = - PNB(NBA,K-1)*RO6*(RO6 - TWO*RO4)
          ENDIF
  30    CONTINUE
C
        DO  32  MB = IATMI, IATMF
!         if(MA==MB)cycle !CAK temtative
          EES = EES + QA*CHARGE(MB)*RI(MB)
  32      ENB = ENB + ENB00(MB)
C
  40    IF (NUM4.EQ.0.AND.KEY.EQ.0)  MA = MA + 1
        IF (KEY.LT.0)  MA = MA + 1
  100 CONTINUE
      RETURN
      END
C     SUBROUTINE  ENRGYZ (VAR,ETOTAL,NUMVAR,CO,CHARGE)
      SUBROUTINE  ENRGYZ (VAR,ETOTAL,CO,CHARGE)
C
C  THIS SUBROUTINE COMPUTES THE CONFORMATIONAL ENERGY & PENALTY FUNCTION
C
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXATM=3000,MAXVAR=800,MAXINT=60000,MAXSS =5)
C     PARAMETER  (MAXPER=10000,MAXCNS=900)
C     PARAMETER  (MXATM1=MAXATM+1,MVAR1=MAXVAR+1)
C     PARAMETER  (MXPAIR=MAXVAR*(MAXVAR+1)/2)
C     PARAMETER  (MXPAR1=(MAXVAR+1)*(MAXVAR+2)/2)
C     PARAMETER  (MAXJ=2*MAXVAR,MAXSS2=MAXSS*2)
C     PARAMETER  (MAXI1=MAXINT/2,MAXI2=MAXINT-MAXI1)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (ATOM)
      INCLUDE 'inc/atom'
CMSP  INCLUDE (BOND)
      INCLUDE 'inc/bond'
CMSP  INCLUDE (TABLE1)
      INCLUDE 'inc/table1'
CMSP  INCLUDE (TORSN0)
      INCLUDE 'inc/torsn0'
CMSP  INCLUDE (SSPAIR)
      INCLUDE 'inc/sspair'
CMSP  INCLUDE (NBTYPE)
      INCLUDE 'inc/nbtype'
CMSP  INCLUDE (WKENRG)
      INCLUDE 'inc/wkenrg'
C     COMMON/NUMBER/  NUMATM,JUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/ATOM00/  KUNIT(MAXATM),KATOM(MXATM1),JATOM(MAXATM)
C     COMMON/BOND00/  DIRCOS(3,MAXVAR),IBND1(MAXVAR),IBND2(0:MVAR1)
      COMMON/INTR14/  NO14(-1:MAXVAR),LIST14(100),
     &                NO12(-1:MAXVAR),LIST12(100)
C     COMMON/TABLE1/  IFRONT(MAXVAR),NBACK(0:MAXVAR),IBACK(2,0:MAXVAR)
      COMMON/TABLE3/  NINT,IPAIR1(MAXI1),IPAIR2(MAXI2),LINT(-1:MAXVAR)
      COMMON/TABLE4/  KMAX,LISTK(-1:MAXVAR),JANGLE(MXPAIR),
     &                 KANGLE(0:MXPAR1)
C     COMMON/TORSN0/  A(MAXVAR),NB(MAXVAR),NS(MAXVAR),IFTOR(MAXVAR)
C     COMMON/SSPAIR/  KSSPER(6,2,MAXSS),JSS(3,MAXSS),KSS(MAXSS2),
C    &                LSS(MAXSS2)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/ENE001/  ERRR,WVLTN
      COMMON/ENE002/  COX(3,MAXATM),NFLAG(MAXATM)
      COMMON/RANGE/   KRANGE
C     COMMON/NBTYPE/  NBTYPE(MAXATM)
      DIMENSION  VAR(MAXVAR),CO(3,*),CHARGE(*)
C     DIMENSION  JPAIR1(MAXPER),JPAIR2(MAXPER)
C     DIMENSION  JAA(MAXJ),JBB(MAXJ),JBF(MAXJ)
C
C  GENERATES THE ATOMIC COORDINATES.
C
      CALL  GENRA (VAR,CO)
C
C  INITIALIZE THE PARAMETERS.
C
      CALL  EZERO
      MSS = 1
C
C------ COMPUTE THE ENERGIES AND PENALTY FUNCTION ------------
C
      DO  100  K = KRANGE, 0, -1
C
        CALL  ENRSET (K,JK,JFIN,LI,LFIN,LISTK,KANGLE,IFRONT,LINT,
     &                JAA,JBB,JBF)
C
        IF (LFIN.EQ.0)  GOTO  100
C
        IF (K.LE.2)  THEN
          LI = LINT(K) - LINT(2) + 1
          CALL  ECALZ (K,LFIN,IPAIR1(LI),IPAIR2(LI),CO,CHARGE,NBTYPE,
     &                 COX,NFLAG)
C
          IF (NSS.EQ.0)  GOTO  100
          IF (MSS.LT.0)  GOTO  100
  20      IF (KSS(LSS(MSS)).NE.K)  GOTO  100
            LS = (LSS(MSS)+1)/2
            CALL  ECALSD (KSSPER(1,1,LS),KSSPER(1,2,LS),CO,
     &                                            MOD(LSS(MSS)+1,2)+1)
            MSS = MSS+1
            IF (MSS.LE.2*NSS)  GOTO  20
            MSS = -MSS
C
        ELSE
          MFLAG = -1
          LI14 = NO14(K)
          LF14 = NO14(K-1)-1
          MI12 = NO12(K)
          MF12 = NO12(K-1)-1
C
          IF (NSS.EQ.0)  GOTO   40
          IF (MSS.LT.0)  GOTO   40
   30     IF (KSS(LSS(MSS)).NE.K)  GOTO   40
            LS = (LSS(MSS)+1)/2
            CALL  ECALSD (KSSPER(1,1,LS),KSSPER(1,2,LS),CO,
     &                                            MOD(LSS(MSS)+1,2)+1)
            MSS = MSS + 1
            MFLAG = K
            IF (MSS.LE.2*NSS)  GOTO   30
              MSS = - MSS
C
   40     CALL  PAIR15 (JPAIR1,JPAIR2,JAA,JBF,JFIN,KATOM,JATOM,
     &             IBND2,LI14,LF14,LIST14,MI12,MF12,LIST12,MFLAG)
          CALL  ECALZ (MFLAG,LFIN,JPAIR1,JPAIR2,CO,CHARGE,NBTYPE,
     &                 COX,NFLAG)
        ENDIF
C
  100 CONTINUE
C
C-- TORSIONAL ENERGY  ---------------------------
C
          CALL  ETORSN (A,NB,NS,IFTOR,VAR)
C
C-- TOTAL ---------------------------------------
C
      ETTL   = ETOR + EES + ENB + ELOOP + ECYSTR
      ETOTAL = ETTL + ERRR*WVLTN
C
      RETURN
      END
      SUBROUTINE  ECALZ (KFLAG,LFIN,IPAIR1,IPAIR2,
     &                   CO,CHARGE,NBTYPE,COX,NFLAG)
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXPER=10000)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (WKCAL1)
      INCLUDE 'inc/wkcal1'
CMSP  INCLUDE (WKCAL2)
      INCLUDE 'inc/wkcal2'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      COMMON/EPARAM/  PNB(1568)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/ENE001/  ERRR,WVLTN
      DIMENSION  IPAIR1(LFIN),IPAIR2(LFIN)
      DIMENSION  CO(3,NUMATM),CHARGE(NUMATM),NBTYPE(NUMATM)
      DIMENSION  COX(3,NUMATM),NFLAG(NUMATM)
C     DIMENSION  IPB(MAXPER),MFLAGX(MAXPER)
C     DIMENSION  RO2(MAXPER),R(MAXPER),R2X(MAXPER),ENB00(MAXPER)
      DIMENSION  RO2(MAXPER),ENB00(MAXPER)
      EQUIVALENCE (R,ENB00)
      DATA  HALF,ONE,TWO /0.5D0,1.D0,2.D0/
C
      II = 0
      DO  10  L = 1, LFIN
        JPA = IABS(IPAIR1(L))
        JPB = IPAIR2(L)
        R2 = (CO(1,JPA)-CO(1,JPB))**2 + (CO(2,JPA)-CO(2,JPB))**2
     &            + (CO(3,JPA)-CO(3,JPB))**2
        RI2 = ONE / R2
        EES = EES + CHARGE(JPA)*CHARGE(JPB)*DSQRT(RI2)
        IPB(L) = (NBTYPE(JPB)-1)*56 + NBTYPE(JPA)
        RO2(L) = PNB(IPB(L)+28)*RI2
        R(L) = DSQRT(R2)
        IF (NFLAG(JPA).EQ.1.AND.NFLAG(JPB).EQ.1) THEN
          II = II+1
          MFLAGX(II) = L
          R2X(II) = (COX(1,JPA)-COX(1,JPB))**2
     &      + (COX(2,JPA)-COX(2,JPB))**2 + (COX(3,JPA)-COX(3,JPB))**2
        ENDIF
  10  CONTINUE
C
      DO  12  I = 1, II
        ERRR = ERRR + (R(MFLAGX(I)) - DSQRT(R2X(I)))**2/R2X(I)
  12  CONTINUE
C
      IF (KFLAG.GE.0)  THEN
        DO  20  L = 1, LFIN
          IF (PNB(IPB(L)).GE.0)  THEN
            IF (IPAIR1(L).LT.0)  THEN
              RO6 = RO2(L)*RO2(L)*RO2(L)
              ENB00(L) = PNB(IPB(L))*RO6*(HALF*RO6 - TWO)
            ELSE
              RO6 = RO2(L)*RO2(L)*RO2(L)
              ENB00(L) = PNB(IPB(L))*RO6*(RO6 - TWO)
            ENDIF
          ELSE
              RO4 = RO2(L)*RO2(L)
              RO6 = RO2(L)*RO4
              ENB00(L) = - PNB(IPB(L))*RO6*(RO6 - TWO*RO4)
          ENDIF
  20    CONTINUE
      ELSE
        DO  22  L = 1, LFIN
          IF (PNB(IPB(L)).GE.0)  THEN
              RO6 = RO2(L)*RO2(L)*RO2(L)
              ENB00(L) = PNB(IPB(L))*RO6*(RO6 - TWO)
          ELSE
              RO4 = RO2(L)*RO2(L)
              RO6 = RO2(L)*RO4
              ENB00(L) = - PNB(IPB(L))*RO6*(RO6 - TWO*RO4)
          ENDIF
  22    CONTINUE
      ENDIF
C
      DO  30  L = 1, LFIN
        ENB = ENB + ENB00(L)
  30  CONTINUE
C
      RETURN
      END
C     SUBROUTINE  ENRGYX (VAR,ETOTAL,NUMVAR,CO,CHARGE)
      SUBROUTINE  ENRGYX (VAR,ETOTAL,CO,CHARGE)
C
C  THIS SUBROUTINE COMPUTES THE CONFORMATIONAL ENERGY & PENALTY FUNCTION
C
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXATM=3000,MAXVAR=800,MAXINT=60000,MAXSS =5)
C     PARAMETER  (MAXPER=10000,MAXCNS=900)
C     PARAMETER  (MXATM1=MAXATM+1,MVAR1=MAXVAR+1)
C     PARAMETER  (MXPAIR=MAXVAR*(MAXVAR+1)/2)
C     PARAMETER  (MXPAR1=(MAXVAR+1)*(MAXVAR+2)/2)
C     PARAMETER  (MAXJ=2*MAXVAR,MAXSS2=MAXSS*2)
C     PARAMETER  (MAXI1=MAXINT/2,MAXI2=MAXINT-MAXI1)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (ATOM)
      INCLUDE 'inc/atom'
CMSP  INCLUDE (BOND)
      INCLUDE 'inc/bond'
CMSP  INCLUDE (TABLE1)
      INCLUDE 'inc/table1'
CMSP  INCLUDE (TORSN0)
      INCLUDE 'inc/torsn0'
CMSP  INCLUDE (SSPAIR)
      INCLUDE 'inc/sspair'
CMSP  INCLUDE (WKENRG)
      INCLUDE 'inc/wkenrg'
C     COMMON/NUMBER/  NUMATM,JUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/ATOM00/  KUNIT(MAXATM),KATOM(MXATM1),JATOM(MAXATM)
C     COMMON/BOND00/  DIRCOS(3,MAXVAR),IBND1(MAXVAR),IBND2(0:MVAR1)
      COMMON/INTR14/  NO14(-1:MAXVAR),LIST14(100),
     &                NO12(-1:MAXVAR),LIST12(100)
C     COMMON/TABLE1/  IFRONT(MAXVAR),NBACK(0:MAXVAR),IBACK(2,0:MAXVAR)
      COMMON/TABLE3/  NINT,IPAIR1(MAXI1),IPAIR2(MAXI2),LINT(-1:MAXVAR)
      COMMON/TABLE4/  KMAX,LISTK(-1:MAXVAR),JANGLE(MXPAIR),
     &                 KANGLE(0:MXPAR1)
C     COMMON/TORSN0/  A(MAXVAR),NB(MAXVAR),NS(MAXVAR),IFTOR(MAXVAR)
C     COMMON/SSPAIR/  KSSPER(6,2,MAXSS),JSS(3,MAXSS),KSS(MAXSS2),
C    &                LSS(MAXSS2)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/ENE001/  ERRR,WVLTN
      COMMON/ENE002/  COX(3,MAXATM),NFLAG(MAXATM)
      COMMON/RANGE/   KRANGE
      DIMENSION  VAR(MAXVAR),CO(3,*),CHARGE(*)
C     DIMENSION  JPAIR1(MAXPER),JPAIR2(MAXPER)
C     DIMENSION  JAA(MAXJ),JBB(MAXJ),JBF(MAXJ)
C
C  GENERATES THE ATOMIC COORDINATES.
C
      CALL  GENRA (VAR,CO)
C
C  INITIALIZE THE PARAMETERS.
C
      CALL  EZERO
      MSS = 1
C
C------ COMPUTE THE ENERGIES AND PENALTY FUNCTION ------------
C
      DO  100  K = KRANGE, 0, -1
C
        CALL  ENRSET (K,JK,JFIN,LI,LFIN,LISTK,KANGLE,IFRONT,LINT,
     &                JAA,JBB,JBF)
C
        IF (LFIN.EQ.0)  GOTO  100
C
        IF (K.LE.2)  THEN
          LI = LINT(K) - LINT(2) + 1
          CALL  ECALX (LFIN,IPAIR1(LI),IPAIR2(LI),CO,COX,NFLAG)
C
          IF (NSS.EQ.0)  GOTO  100
          IF (MSS.LT.0)  GOTO  100
  20      IF (KSS(LSS(MSS)).NE.K)  GOTO  100
            LS = (LSS(MSS)+1)/2
            CALL  ECALSD (KSSPER(1,1,LS),KSSPER(1,2,LS),CO,
     &                                            MOD(LSS(MSS)+1,2)+1)
            MSS = MSS+1
            IF (MSS.LE.2*NSS)  GOTO  20
            MSS = -MSS
C
        ELSE
          MFLAG = -1
          LI14 = NO14(K)
          LF14 = NO14(K-1)-1
          MI12 = NO12(K)
          MF12 = NO12(K-1)-1
C
          IF (NSS.EQ.0)  GOTO   40
          IF (MSS.LT.0)  GOTO   40
   30     IF (KSS(LSS(MSS)).NE.K)  GOTO   40
            LS = (LSS(MSS)+1)/2
            CALL  ECALSD (KSSPER(1,1,LS),KSSPER(1,2,LS),CO,
     &                                            MOD(LSS(MSS)+1,2)+1)
            MSS = MSS + 1
            MFLAG = K
            IF (MSS.LE.2*NSS)  GOTO   30
              MSS = - MSS
C
   40     CALL  PAIR15 (JPAIR1,JPAIR2,JAA,JBF,JFIN,KATOM,JATOM,
     &             IBND2,LI14,LF14,LIST14,MI12,MF12,LIST12,MFLAG)
          CALL  ECALX (LFIN,JPAIR1,JPAIR2,CO,COX,NFLAG)
        ENDIF
C
  100 CONTINUE
C
C-- TORSIONAL ENERGY  ---------------------------
C
          CALL  ETORSN (A,NB,NS,IFTOR,VAR)
C
C-- TOTAL ---------------------------------------
C
      ETTL   = ETOR + ELOOP + ECYSTR
      ETOTAL = ETTL + ERRR*WVLTN
C
      RETURN
      END
      SUBROUTINE  ECALX (LFIN,IPAIR1,IPAIR2,CO,COX,NFLAG)
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXPER=10000)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (WKCAL1)
      INCLUDE 'inc/wkcal1'
CMSP  INCLUDE (WKCAL2)
      INCLUDE 'inc/wkcal2'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/ENE001/  ERRR,WVLTN
      DIMENSION  IPAIR1(LFIN),IPAIR2(LFIN)
      DIMENSION  CO(3,NUMATM)
C     DIMENSION  COX(3,NUMATM),NFLAG(NUMATM),MFLAGX(MAXPER)
      DIMENSION  COX(3,NUMATM),NFLAG(NUMATM)
C     DIMENSION  R(MAXPER),R2X(MAXPER)
C
      II = 0
      DO  10  L = 1, LFIN
        JPA = IABS(IPAIR1(L))
        JPB = IPAIR2(L)
        R2 = (CO(1,JPA)-CO(1,JPB))**2 + (CO(2,JPA)-CO(2,JPB))**2
     &            + (CO(3,JPA)-CO(3,JPB))**2
        R(L) = DSQRT(R2)
        IF (NFLAG(JPA).EQ.1.AND.NFLAG(JPB).EQ.1) THEN
          II = II+1
          MFLAGX(II) = L
          R2X(II) = (COX(1,JPA)-COX(1,JPB))**2
     &      + (COX(2,JPA)-COX(2,JPB))**2 + (COX(3,JPA)-COX(3,JPB))**2
        ENDIF
  10  CONTINUE
C
      DO  12  I = 1, II
        ERRR = ERRR + (R(MFLAGX(I)) - DSQRT(R2X(I)))**2/R2X(I)
  12  CONTINUE
C
      RETURN
      END
      SUBROUTINE  ENRSET (K,JK,JFIN,LI,LFIN,LISTK,KANGLE,IFRONT,LINT,
     &                    JAA,JBB,JBF)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBR1/  NATM1,NVAR1,NPAIR1
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  LISTK(-1:NUMVAR),KANGLE(0:NPAIR1),IFRONT(NUMVAR)
      DIMENSION  LINT(-1:NUMVAR),JAA(*),JBB(*),JBF(*)
C
        JK   = LISTK(K)
        JFIN = LISTK(K-1) - LISTK(K)
C
        DO  10  J = JK, JK+JFIN-1
          I = J-JK+1
          KA = IABS(KANGLE(J))
          JAA(I) = KA/10000
          JBB(I) = KA - JAA(I)*10000
          JBF(I) = JBB(I)
          IF (KANGLE(J).LT.0)  JBF(I) = IFRONT(JBB(I))
   10   CONTINUE
C
        LI = LINT(K)
        LFIN = LINT(K-1) - LINT(K)
C
        RETURN
        END
      SUBROUTINE  ETORSN (A,NB,NS,IFTOR,VAR)
C
C  THIS SUBROUTINE COMPUTES THE TORSIONAL POTENTIAL.
C
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  A(NUMVAR),NB(NUMVAR),NS(NUMVAR),IFTOR(NUMVAR)
      DIMENSION  VAR(NUMVAR)
      DATA  ONE /1.D0/
C
      DO  10  I = 1, NUMVAR
        IF (IFTOR(I).EQ.1)
     &          ETOR = ETOR + A(I)*(ONE+NS(I)*DCOS(NB(I)*VAR(I)))
  10  CONTINUE
C
      RETURN
      END
      SUBROUTINE  EZERO
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/ENE001/  ERRR,WVLTN
      DATA  ZERO /0.D0/
C
C  INITIALIZE THE FOLLOWING PARAMETERS.
C
      ETOR   = ZERO
      EES    = ZERO
      ENB    = ZERO
      ELOOP  = ZERO
      ECYSTR = ZERO
C
      ERRR   = ZERO
C
      RETURN
      END
      SUBROUTINE  ECALSS (IPAIR1,IPAIR2,CO)
C
C  THIS SUBROUTINE COMPUTES THE ENERGIES OF DISULFIDE BRIDGES
C
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/DISULF/  RSS(4),ASS(4),BSS(9)
      DIMENSION  CO(3,*),IPAIR1(6),IPAIR2(6),RMAG(6),RI1(6)
C
      DO  10  L = 1, 6
        JPA = IPAIR1(L)
        JPB = IPAIR2(L)
        RMAG(L) = (CO(1,JPA)-CO(1,JPB))**2 + (CO(2,JPA)-CO(2,JPB))**2
     &               + (CO(3,JPA)-CO(3,JPB))**2
        RI1(L) = DSQRT(RMAG(L))
  10  CONTINUE
C
        DO  20  L = 1, 3
          ELOOP = ELOOP + ASS(L)*(RI1(L)-RSS(L))**2
  20    CONTINUE
C
        ECYSTR = ECYSTR + ASS(4)*(RI1(4)-RSS(4))**2
C
C  DOES NOT CARRY OUT THE FOLLOWINGS AT PRESENT
C
C 21    DO  22  L = 5, 6
C         IF (RI1(L).LT.BSS(8))  THEN
C         ECYSTR = ECYSTR + ((BSS(1)*RMAG(L) + BSS(3))*RMAG(L) + BSS(5))
C    &           *RMAG(L) + ((BSS(2)*RMAG(L) + BSS(4))*RMAG(L) + BSS(6))
C    &            *RI1(L) + BSS(7)
C         ELSE
C         ECYSTR = ECYSTR + BSS(9)*(RI1(L)-BSS(8))**2
C         ENDIF
C 22    CONTINUE
C
      RETURN
      END
      SUBROUTINE  ECALSD (IPAIR1,IPAIR2,CO,IFLAG)
C
C  THIS SUBROUTINE COMPUTES THE ENERGIES OF DISULFIDE BRIDGES
C
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/DISULF/  RSS(4),ASS(4),BSS(9)
      DIMENSION  IPAIR1(6),IPAIR2(6),CO(3,*)
      DIMENSION  RMAG(6),RI1(6)
      DIMENSION  LSTRT(2),LFIN(2)
      DATA  LSTRT/1,5/
      DATA  LFIN /4,6/
C
       IF (IFLAG.EQ.2)  RETURN
C
      DO  10  L = LSTRT(IFLAG), LFIN(IFLAG)
        JPA = IPAIR1(L)
        JPB = IPAIR2(L)
        RMAG(L) = (CO(1,JPA)-CO(1,JPB))**2 + (CO(2,JPA)-CO(2,JPB))**2
     &              + (CO(3,JPA)-CO(3,JPB))**2
        RI1(L) = DSQRT(RMAG(L))
  10  CONTINUE
C
C     IF (IFLAG.EQ.1)  THEN
        DO  20  L = 1, 3
          ELOOP = ELOOP + ASS(L)*(RI1(L)-RSS(L))**2
  20    CONTINUE
        ECYSTR = ECYSTR + ASS(4)*(RI1(4)-RSS(4))**2
C
C  NOT CARRY OUT THE FOLLOWINGS AT PRESENT.
C
C     ELSE
C       DO  22  L = LSTRT(IFLAG), LFIN(IFLAG)
C         IF (RI1(L).LT.BSS(8))  THEN
C         ECYSTR = ECYSTR + ((BSS(1)*RMAG(L) + BSS(3))*RMAG(L) + BSS(5))
C    &           *RMAG(L) + ((BSS(2)*RMAG(L) + BSS(4))*RMAG(L) + BSS(6))
C    &            *RI1(L) + BSS(7)
C          ELSE
C          ECYSTR = ECYSTR + BSS(9)*(RI1(L)-BSS(8))**2
C          ENDIF
C 22    CONTINUE
C     ENDIF
C
      RETURN
      END
C     SUBROUTINE  DRVTVA(NUMVAR,NN2,VAR,ETOTAL,F,G,CO,CHARGE)
      SUBROUTINE  DRVTVA(VAR,ETOTAL,F,G,CO,CHARGE)
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXATM=3000,MAXVAR=800,MAXINT=60000)
C     PARAMETER  (MXATM1=MAXATM+1,MVAR1=MAXVAR+1)
C     PARAMETER  (MXPAIR=MAXVAR*(MAXVAR+1)/2)
C     PARAMETER  (MXPAR1=(MAXVAR+1)*(MAXVAR+2)/2)
C     PARAMETER  (MAXJ=2*MAXVAR)
C     PARAMETER  (MAXSS =5,MAXSS2=MAXSS*2)
C     PARAMETER  (MAXI1=MAXINT/2,MAXI2=MAXINT-MAXI1)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (ATOM)
      INCLUDE 'inc/atom'
CMSP  INCLUDE (BOND)
      INCLUDE 'inc/bond'
CMSP  INCLUDE (NBTYPE)
      INCLUDE 'inc/nbtype'
CMSP  INCLUDE (TABLE1)
      INCLUDE 'inc/table1'
CMSP  INCLUDE (TORSN0)
      INCLUDE 'inc/torsn0'
CMSP  INCLUDE (SSPAIR)
      INCLUDE 'inc/sspair'
CMSP  INCLUDE (WKENRG)
      INCLUDE 'inc/wkenrg'
CMSP  INCLUDE (WKDRVTV)
      INCLUDE 'inc/wkdrvtv'
C     COMMON/NUMBER/  NUMATM,JUMVAR,MM2,NUMINT,NSS,NUMRES
C     COMMON/ATOM00/  KUNIT(MAXATM),KATOM(MXATM1),JATOM(MAXATM)
C     COMMON/BOND00/  DIRCOS(3,MAXVAR),IBND1(MAXVAR),IBND2(0:MVAR1)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/INTR14/  NO14(-1:MAXVAR),LIST14(100),
     &                NO12(-1:MAXVAR),LIST12(100)
C     COMMON/NBTYPE/  NBTYPE(MAXATM)
C     COMMON/TABLE1/  IFRONT(MAXVAR),NBACK(0:MAXVAR),IBACK(2,0:MAXVAR)
      COMMON/TABLE3/  NINT,IPAIR1(MAXI1),IPAIR2(MAXI2),LINT(-1:MAXVAR)
      COMMON/TABLE4/  KMAX,LISTK(-1:MAXVAR),JANGLE(MXPAIR),
     &                 KANGLE(0:MXPAR1)
C     COMMON/TORSN0/  A(MAXVAR),NB(MAXVAR),NS(MAXVAR),IFTOR(MAXVAR)
C     COMMON/SSPAIR/  KSSPER(6,2,MAXSS),JSS(3,MAXSS),KSS(MAXSS2),
C    &                LSS(MAXSS2)
      COMMON/RAB/     R(30*MAXJ,3)
C     DIMENSION  VAR(MAXVAR),F(MAXVAR),G(MXPAIR),EF(6*MAXVAR)
      DIMENSION  VAR(MAXVAR),F(MAXVAR),G(MXPAIR)
C     DIMENSION  CO(3,*),CHARGE(*),VECPRD(3,MAXVAR)
      DIMENSION  CO(3,*),CHARGE(*)
C     DIMENSION  JAA(MAXJ),JBB(MAXJ),JBF(MAXJ),LAB(MAXJ)
C
C     PARAMETER  (MAXPER=10000)
C     DIMENSION  JPAIR1(MAXPER),JPAIR2(MAXPER)
C
C
C  GENERATE THE ATOMIC COORDINATES.
C
      CALL  GENRA (VAR,CO)
C
C  INITIALIZE THE PARAMETERS.
C
      CALL  DRVINI (CO,DIRCOS,VECPRD,IBND2,KADD1,KADD2,KADD3,EF,G)
      MSS = 1
C
C************************************************************
C  THIS SECTION CALCULATES THE FIRST AND SECOND DERIVATIVES.
C************************************************************
C
      DO  100  K = KMAX, 0, -1
C
        CALL  DRVSET (K,JK,JFIN,LI,LFIN,LISTK,KANGLE,IFRONT,LINT,
     &                JAA,JBB,JBF,LAB,R(1,KADD1))
C
        IF (LFIN.EQ.0)  GOTO  5
C
        IF (K.LE.2)  THEN
          LI = LINT(K) - LINT(2) + 1
          CALL  DCALA (K,LFIN,JFIN,IPAIR1(LI),IPAIR2(LI),R(1,KADD1),
     &                 JANGLE(JK),JAA,JBF,EF,CO,CHARGE,NBTYPE)
C
          IF (NSS.EQ.0)  GOTO  5
          IF (MSS.LT.0)  GOTO  5
C
  20      IF (KSS(LSS(MSS)).NE.K)  GOTO  5
            LS = (LSS(MSS)+1)/2
            CALL  DCALSS (KSSPER(1,1,LS),KSSPER(1,2,LS),R(1,KADD1),
     &          JSS(1,LS),KANGLE(JK),EF,MOD(LSS(MSS)+1,2)+1,IFRONT,CO)
            MSS = MSS+1
            IF (MSS.LE.2*NSS)  GOTO  20
C
            MSS = -MSS
C
        ELSE
          MFLAG = -K
          LI14 = NO14(K)
          LF14 = NO14(K-1)-1
          MI12 = NO12(K)
          MF12 = NO12(K-1)-1
C
          IF (NSS.EQ.0)  GOTO  40
          IF (MSS.LT.0)  GOTO  40
C
  30      IF (KSS(LSS(MSS)).NE.K)  GOTO  40
            LS = (LSS(MSS)+1)/2
            CALL  DCALSS (KSSPER(1,1,LS),KSSPER(1,2,LS),R(1,KADD1),
     &          JSS(1,LS),KANGLE(JK),EF,MOD(LSS(MSS)+1,2)+1,IFRONT,CO)
            MSS = MSS+1
            MFLAG = K
            IF (MSS.LE.2*NSS)  GOTO  30
C
            MSS = -MSS
C
  40        CALL  PAIR15 (JPAIR1,JPAIR2,JAA,JBF,JFIN,KATOM,JATOM,
     &              IBND2,LI14,LF14,LIST14,MI12,MF12,LIST12,MFLAG)
            CALL  DCALA (MFLAG,LFIN,JFIN,JPAIR1,JPAIR2,R(1,KADD1),
     &                   JANGLE(JK),JAA,JBF,EF,CO,CHARGE,NBTYPE)
        ENDIF
C
   5    CALL  DRCRNT (K,JK,JFIN,JAA,JBB,LAB,KADD1,KADD2,KADD3,
     &                DIRCOS,VECPRD,G)
C
        KA1 = KADD1
        KADD1 = KADD3
        KADD3 = KADD2
        KADD2 = KA1
C
  100 CONTINUE
C
C-------------------------------------------------------------------
C
      CALL  DFRCRT (NBACK,IBACK,EF,F,DIRCOS,VECPRD)
C
      CALL  DTORSN (A,NB,NS,IFTOR,VAR,F,G)
C
      ETOTAL = ETOR + EES + ENB + ELOOP + ECYSTR
C
      CALL  OUT002
C
      RETURN
      END
      SUBROUTINE  DCALA (KFLAG,LFIN,JFIN,IPAIR1,IPAIR2,EL,NOPAIR,
     &                   JAA,JBF,EF,CO,CHARGE,NBTYPE)
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXPER=10000)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (WKCAL1)
      INCLUDE 'inc/wkcal1'
CMSP  INCLUDE (WKCAL2)
      INCLUDE 'inc/wkcal2'
CMSP  INCLUDE (WKCAL3)
      INCLUDE 'inc/wkcal3'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      COMMON/EPARAM/  PNB(1568)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      DIMENSION  IPAIR1(LFIN),IPAIR2(LFIN)
      DIMENSION  EL(30,JFIN),NOPAIR(JFIN),JAA(JFIN),JBF(JFIN)
      DIMENSION  EF(6,NUMVAR),CO(3,*),CHARGE(*),NBTYPE(NUMATM)
C     DIMENSION  IPA(MAXPER),IPB(MAXPER)
C     DIMENSION  CAB(MAXPER),DAB(MAXPER)
C     DIMENSION  XA(MAXPER)  ,YA(MAXPER)  ,ZA(MAXPER)
C     DIMENSION  XB(MAXPER)  ,YB(MAXPER)  ,ZB(MAXPER)
C     DIMENSION  XAB(MAXPER) ,YAB(MAXPER) ,ZAB(MAXPER)
C     DIMENSION  XAXB(MAXPER),YAXB(MAXPER),ZAXB(MAXPER)
      DIMENSION  ENB00(MAXPER),RO2(MAXPER),RI2(MAXPER)
      EQUIVALENCE  (ENB00,XAXB),(RO2,YAXB),(RI2,ZAXB)
      DATA  HALF,ONE,TWO,THREE /0.5D0,1.D0,2.D0,3.D0/
      DATA  C6,C12,C20,C84,C96 /6.D0,12.D0,20.D0,84.D0,96.D0/
      DATA  C168,C240 /168.D0,240.D0/
C
      DO  10  L = 1, LFIN
        JPA = IABS(IPAIR1(L))
        JPB = IPAIR2(L)
        XA(L) = CO(1,JPA)
        YA(L) = CO(2,JPA)
        ZA(L) = CO(3,JPA)
        XB(L) = CO(1,JPB)
        YB(L) = CO(2,JPB)
        ZB(L) = CO(3,JPB)
        XAB(L) = XA(L)-XB(L)
        YAB(L) = YA(L)-YB(L)
        ZAB(L) = ZA(L)-ZB(L)
        RI2(L) = ONE / (XAB(L)*XAB(L)+YAB(L)*YAB(L)+ZAB(L)*ZAB(L))
        Q = CHARGE(JPA)*CHARGE(JPB)*DSQRT(RI2(L))
        EES = EES + Q
        CAB(L) = - Q*RI2(L)
        DAB(L) = THREE*(Q*RI2(L)*RI2(L))
        IPB(L) = (NBTYPE(JPB)-1)*56 + NBTYPE(JPA)
        RO2(L) = PNB(IPB(L)+28)*RI2(L)
  10  CONTINUE
C
      IF (KFLAG.GE.0)  THEN
        DO  20  L = 1, LFIN
          IF (PNB(IPB(L)).GE.0)  THEN
            IF (IPAIR1(L).LT.0)  THEN
              RO6 = RO2(L)*RO2(L)*RO2(L)
              U1 = PNB(IPB(L))*RO6
              U2 = U1*RI2(L)
              ENB00(L) = U1*(HALF*RO6 - TWO)
              CAB(L) = CAB(L) - U2*(C6*RO6 - C12)
              DAB(L) = DAB(L) + U2*RI2(L)*(C84*RO6 - C96)
            ELSE
              RO6 = RO2(L)*RO2(L)*RO2(L)
              U1 = PNB(IPB(L))*RO6
              U2 = U1*RI2(L)
              ENB00(L) = U1*(RO6 - TWO)
              CAB(L) = CAB(L) - U2*(C12*RO6 - C12)
              DAB(L) = DAB(L) + U2*RI2(L)*(C168*RO6 - C96)
            ENDIF
          ELSE
              RO4 = RO2(L)*RO2(L)
              RO6 = RO2(L)*RO4
              U1 = PNB(IPB(L))*RO6
              U2 = U1*RI2(L)
              ENB00(L) = - U1*(RO6 - TWO*RO4)
              CAB(L) = CAB(L) + U2*(C12*RO6 - C20*RO4)
              DAB(L) = DAB(L) - U2*RI2(L)*(C168*RO6 - C240*RO4)
          ENDIF
  20    CONTINUE
      ELSE
        DO  22  L = 1, LFIN
          IF (PNB(IPB(L)).GE.0)  THEN
            RO6 = RO2(L)*RO2(L)*RO2(L)
            U1 = PNB(IPB(L))*RO6
            U2 = U1*RI2(L)
            ENB00(L) = U1*(RO6 - TWO)
            CAB(L) = CAB(L) - U2*(C12*RO6 - C12)
            DAB(L) = DAB(L) + U2*RI2(L)*(C168*RO6 - C96)
          ELSE
            RO4 = RO2(L)*RO2(L)
            RO6 = RO2(L)*RO4
            U1 = PNB(IPB(L))*RO6
            U2 = U1*RI2(L)
            ENB00(L) = - U1*(RO6 - TWO*RO4)
            CAB(L) = CAB(L) + U2*(C12*RO6 - C20*RO4)
            DAB(L) = DAB(L) - U2*RI2(L)*(C168*RO6 - C240*RO4)
          ENDIF
  22    CONTINUE
      ENDIF
C
      DO  30  L = 1, LFIN
  30    ENB = ENB + ENB00(L)
C
      CALL  DRMTRX (LFIN,JFIN,IPA,IPB,EL,EF,NOPAIR,JAA,JBF,CAB,DAB,
     &              XAXB,YAXB,ZAXB,XAB,YAB,ZAB,XA,YA,ZA,XB,YB,ZB)
C
      RETURN
      END
C     SUBROUTINE  DRVTVZ (NUMVAR,NN2,VAR,ETOTAL,F,G,CO,CHARGE)
      SUBROUTINE  DRVTVZ (VAR,ETOTAL,F,G,CO,CHARGE)
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXATM=3000,MAXVAR=800,MAXINT=60000)
C     PARAMETER  (MAXCNS=900,MAXPER=10000)
C     PARAMETER  (MXATM1=MAXATM+1,MVAR1=MAXVAR+1)
C     PARAMETER  (MXPAIR=MAXVAR*(MAXVAR+1)/2)
C     PARAMETER  (MXPAR1=(MAXVAR+1)*(MAXVAR+2)/2)
C     PARAMETER  (MAXJ=2*MAXVAR)
C     PARAMETER  (MAXSS =5,MAXSS2=MAXSS*2)
C     PARAMETER  (MAXI1=MAXINT/2,MAXI2=MAXINT-MAXI1)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (ATOM)
      INCLUDE 'inc/atom'
CMSP  INCLUDE (BOND)
      INCLUDE 'inc/bond'
CMSP  INCLUDE (NBTYPE)
      INCLUDE 'inc/nbtype'
CMSP  INCLUDE (TABLE1)
      INCLUDE 'inc/table1'
CMSP  INCLUDE (TORSN0)
      INCLUDE 'inc/torsn0'
CMSP  INCLUDE (SSPAIR)
      INCLUDE 'inc/sspair'
CMSP  INCLUDE (WKENRG)
      INCLUDE 'inc/wkenrg'
CMSP  INCLUDE (WKDRVTV)
      INCLUDE 'inc/wkdrvtv'
C     COMMON/NUMBER/  NUMATM,JUMVAR,MM2,NUMINT,NSS,NUMRES
C     COMMON/ATOM00/  KUNIT(MAXATM),KATOM(MXATM1),JATOM(MAXATM)
C     COMMON/BOND00/  DIRCOS(3,MAXVAR),IBND1(MAXVAR),IBND2(0:MVAR1)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/ENE001/  ERRR,WVLTN
      COMMON/ENE002/  COX(3,MAXATM),NFLAG(MAXATM)
      COMMON/RANGE/   KRANGE
      COMMON/INTR14/  NO14(-1:MAXVAR),LIST14(100),
     &                NO12(-1:MAXVAR),LIST12(100)
C     COMMON/NBTYPE/  NBTYPE(MAXATM)
C     COMMON/TABLE1/  IFRONT(MAXVAR),NBACK(0:MAXVAR),IBACK(2,0:MAXVAR)
      COMMON/TABLE3/  NINT,IPAIR1(MAXI1),IPAIR2(MAXI2),LINT(-1:MAXVAR)
      COMMON/TABLE4/  KMAX,LISTK(-1:MAXVAR),JANGLE(MXPAIR),
     &                 KANGLE(0:MXPAR1)
C     COMMON/TORSN0/  A(MAXVAR),NB(MAXVAR),NS(MAXVAR),IFTOR(MAXVAR)
C     COMMON/SSPAIR/  KSSPER(6,2,MAXSS),JSS(3,MAXSS),KSS(MAXSS2),
C    &                LSS(MAXSS2)
      COMMON/RAB/     R(30*MAXJ,3)
C     DIMENSION  VAR(MAXVAR),F(MAXVAR),G(MXPAIR),EF(6*MAXVAR)
C     DIMENSION  CO(3,*),CHARGE(*),VECPRD(3,MAXVAR)
      DIMENSION  VAR(MAXVAR),F(MAXVAR),G(MXPAIR)
      DIMENSION  CO(3,*),CHARGE(*)
C     DIMENSION  JAA(MAXJ),JBB(MAXJ),JBF(MAXJ),LAB(MAXJ)
C     DIMENSION  JPAIR1(MAXPER),JPAIR2(MAXPER)
C
      DATA  ZERO /0.D0/
C
C  GENERATE THE ATOMIC COORDINATES.
C
      CALL  GENRA (VAR,CO)
C
C  INITIALIZE THE PARAMETERS.
C
      CALL  DRVINI (CO,DIRCOS,VECPRD,IBND2,KADD1,KADD2,KADD3,EF,G)
      MSS = 1
      DO  2  KADD = 1, 3
      DO  2  J01  = 1, 30*MAXJ
  2     R(J01,KADD) = ZERO
C
C************************************************************
C  THIS SECTION CALCULATES THE FIRST AND SECOND DERIVATIVES.
C************************************************************
C----------- START OF DO LOOP 100 ------------------------------------
C
      DO  100  K = KRANGE, 0, -1
C
        CALL  DRVSET (K,JK,JFIN,LI,LFIN,LISTK,KANGLE,IFRONT,LINT,
     &                JAA,JBB,JBF,LAB,R(1,KADD1))
C
        IF (LFIN.EQ.0)  GOTO  5
C
        IF (K.LE.2)  THEN
          LI = LINT(K) - LINT(2) + 1
          CALL  DCALZ (K,LFIN,JFIN,IPAIR1(LI),IPAIR2(LI),R(1,KADD1),
     &               JANGLE(JK),JAA,JBF,EF,CO,CHARGE,NBTYPE,COX,NFLAG)
C
          IF (NSS.EQ.0)  GOTO  5
          IF (MSS.LT.0)  GOTO  5
C
  20      IF (KSS(LSS(MSS)).NE.K)  GOTO  5
            LS = (LSS(MSS)+1)/2
            CALL  DCALSS (KSSPER(1,1,LS),KSSPER(1,2,LS),R(1,KADD1),
     &          JSS(1,LS),KANGLE(JK),EF,MOD(LSS(MSS)+1,2)+1,IFRONT,CO)
            MSS = MSS+1
            IF (MSS.LE.2*NSS)  GOTO  20
C
            MSS = -MSS
C
        ELSE
          MFLAG = -1
          LI14 = NO14(K)
          LF14 = NO14(K-1)-1
          MI12 = NO12(K)
          MF12 = NO12(K-1)-1
C
          IF (NSS.EQ.0)  GOTO  40
          IF (MSS.LT.0)  GOTO  40
C
  30      IF (KSS(LSS(MSS)).NE.K)  GOTO  40
            LS = (LSS(MSS)+1)/2
            CALL  DCALSS (KSSPER(1,1,LS),KSSPER(1,2,LS),R(1,KADD1),
     &          JSS(1,LS),KANGLE(JK),EF,MOD(LSS(MSS)+1,2)+1,IFRONT,CO)
            MSS = MSS+1
            MFLAG = K
            IF (MSS.LE.2*NSS)  GOTO  30
C
            MSS = -MSS
C
  40        CALL  PAIR15 (JPAIR1,JPAIR2,JAA,JBF,JFIN,KATOM,JATOM,
     &              IBND2,LI14,LF14,LIST14,MI12,MF12,LIST12,MFLAG)
            CALL  DCALZ (MFLAG,LFIN,JFIN,JPAIR1,JPAIR2,R(1,KADD1),
     &                 JANGLE(JK),JAA,JBF,EF,CO,CHARGE,NBTYPE,COX,NFLAG)
        ENDIF
C
   5    CALL  DRCRNT (K,JK,JFIN,JAA,JBB,LAB,KADD1,KADD2,KADD3,
     &                DIRCOS,VECPRD,G)
C
        KA1 = KADD1
        KADD1 = KADD3
        KADD3 = KADD2
        KADD2 = KA1
C
  100 CONTINUE
C
C---------- END OF DO LOOP 100 -------------------------------------
C
      CALL  DFRCRT (NBACK,IBACK,EF,F,DIRCOS,VECPRD)
C
      CALL  DTORSN (A,NB,NS,IFTOR,VAR,F,G)
C
      ETTL = ETOR + EES + ENB + ELOOP + ECYSTR
      ETOTAL = ETTL + ERRR*WVLTN
C
      CALL  OUT002
C
      RETURN
      END
      SUBROUTINE  DCALZ (KFLAG,LFIN,JFIN,IPAIR1,IPAIR2,EL,NOPAIR,
     &                  JAA,JBF,EF,CO,CHARGE,NBTYPE,COX,NFLAG)
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXPER=10000)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (WKCAL1)
      INCLUDE 'inc/wkcal1'
CMSP  INCLUDE (WKCAL2)
      INCLUDE 'inc/wkcal2'
CMSP  INCLUDE (WKCAL3)
      INCLUDE 'inc/wkcal3'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      COMMON/EPARAM/  PNB(1568)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/ENE001/  ERRR,WVLTN
      DIMENSION  EL(30,JFIN),NOPAIR(JFIN),JAA(JFIN),JBF(JFIN)
      DIMENSION  EF(6,NUMVAR),CO(3,*),CHARGE(*),NBTYPE(NUMATM)
      DIMENSION  IPAIR1(LFIN),IPAIR2(LFIN)
      DIMENSION  COX(3,NUMATM),NFLAG(NUMATM)
C     DIMENSION  CAB(MAXPER),DAB(MAXPER)
C     DIMENSION  IPA(MAXPER),IPB(MAXPER)  ,MFLAGX(MAXPER)
C     DIMENSION  XA(MAXPER)  ,YA(MAXPER)  ,ZA(MAXPER)
C     DIMENSION  XB(MAXPER)  ,YB(MAXPER)  ,ZB(MAXPER)
C     DIMENSION  XAB(MAXPER) ,YAB(MAXPER) ,ZAB(MAXPER)
C     DIMENSION  XAXB(MAXPER),YAXB(MAXPER),ZAXB(MAXPER)
      DIMENSION  ENB00(MAXPER),RO2(MAXPER),RI2(MAXPER)
C     DIMENSION  R(MAXPER),RX(MAXPER),WGHT(MAXPER)
      DIMENSION  RX(MAXPER),WGHT(MAXPER)
      EQUIVALENCE  (ENB00,XAXB),(RO2,YAXB),(RI2,ZAXB),(WGHT,XAXB)
      DATA  HALF,ONE,TWO,THREE /0.5D0,1.D0,2.D0,3.D0/
      DATA  C6,C12,C20,C84,C96 /6.D0,12.D0,20.D0,84.D0,96.D0/
      DATA  C168,C240 /168.D0,240.D0/
C
      II = 0
      DO  10  L = 1, LFIN
        JPA = IABS(IPAIR1(L))
        JPB = IPAIR2(L)
        XA(L) = CO(1,JPA)
        YA(L) = CO(2,JPA)
        ZA(L) = CO(3,JPA)
        XB(L) = CO(1,JPB)
        YB(L) = CO(2,JPB)
        ZB(L) = CO(3,JPB)
        XAB(L) = XA(L)-XB(L)
        YAB(L) = YA(L)-YB(L)
        ZAB(L) = ZA(L)-ZB(L)
        R2 = XAB(L)*XAB(L)+YAB(L)*YAB(L)+ZAB(L)*ZAB(L)
        R(L) = DSQRT(R2)
        RI2(L) = ONE / R2
        Q = CHARGE(JPA)*CHARGE(JPB)/R(L)
        EES = EES + Q
        CAB(L) = - Q*RI2(L)
        DAB(L) = THREE*(Q*RI2(L)*RI2(L))
        IPB(L) = (NBTYPE(JPB)-1)*56 + NBTYPE(JPA)
        RO2(L) = PNB(IPB(L)+28)*RI2(L)
        IF (NFLAG(JPA).EQ.1 .AND. NFLAG(JPB).EQ.1)  THEN
          II = II+1
          MFLAGX(II) = L
          R2XXX = (COX(1,JPA)-COX(1,JPB))**2 +
     &       (COX(2,JPA)-COX(2,JPB))**2 + (COX(3,JPA)-COX(3,JPB))**2
          RX(II) = DSQRT(R2XXX)
          WGHT(II) = ONE / R2XXX * WVLTN
        ENDIF
  10  CONTINUE
C
      DO  12  I = 1, II
        L = MFLAGX(I)
        ERRR = ERRR + WGHT(I)*(R(L) - RX(I))**2
        AR = RX(I)/R(L)
        CAB(L) = CAB(L) + TWO*WGHT(I)*(ONE-AR)
        DAB(L) = DAB(L) + TWO*WGHT(I)*AR*RI2(L)
  12  CONTINUE
C
      IF (KFLAG.GE.0)  THEN
        DO  20  L = 1, LFIN
          IF (PNB(IPB(L)).GE.0)  THEN
            IF (IPAIR1(L).LT.0)  THEN
              RO6 = RO2(L)*RO2(L)*RO2(L)
              U1 = PNB(IPB(L))*RO6
              U2 = U1*RI2(L)
              ENB00(L) = U1*(HALF*RO6 - TWO)
              CAB(L) = CAB(L) - U2*(C6*RO6 - C12)
              DAB(L) = DAB(L) + U2*RI2(L)*(C84*RO6 - C96)
            ELSE
              RO6 = RO2(L)*RO2(L)*RO2(L)
              U1 = PNB(IPB(L))*RO6
              U2 = U1*RI2(L)
              ENB00(L) = U1*(RO6-TWO)
              CAB(L) = CAB(L) - U2*(C12*RO6 - C12)
              DAB(L) = DAB(L) + U2*RI2(L)*(C168*RO6 - C96)
            ENDIF
          ELSE
              RO4 = RO2(L)*RO2(L)
              RO6 = RO2(L)*RO4
              U1 = PNB(IPB(L))*RO6
              U2 = U1*RI2(L)
              ENB00(L) = - U1*(RO6 - TWO*RO4)
              CAB(L) = CAB(L) + U2*(C12*RO6 - C20*RO4)
              DAB(L) = DAB(L) - U2*RI2(L)*(C168*RO6 - C240*RO4)
          ENDIF
  20    CONTINUE
      ELSE
        DO  22  L = 1, LFIN
          IF (PNB(IPB(L)).GE.0)  THEN
              RO6 = RO2(L)*RO2(L)*RO2(L)
              U1 = PNB(IPB(L))*RO6
              U2 = U1*RI2(L)
              ENB00(L) = U1*(RO6-TWO)
              CAB(L) = CAB(L) - U2*(C12*RO6 - C12)
              DAB(L) = DAB(L) + U2*RI2(L)*(C168*RO6 - C96)
          ELSE
              RO4 = RO2(L)*RO2(L)
              RO6 = RO2(L)*RO4
              U1 = PNB(IPB(L))*RO6
              U2 = U1*RI2(L)
              ENB00(L) = - U1*(RO6 - TWO*RO4)
              CAB(L) = CAB(L) + U2*(C12*RO6 - C20*RO4)
              DAB(L) = DAB(L) - U2*RI2(L)*(C168*RO6 - C240*RO4)
          ENDIF
  22    CONTINUE
      ENDIF
C
      DO  30  L = 1, LFIN
  30    ENB = ENB + ENB00(L)
C
      CALL  DRMTRX (LFIN,JFIN,IPA,IPB,EL,EF,NOPAIR,JAA,JBF,CAB,DAB,
     &              XAXB,YAXB,ZAXB,XAB,YAB,ZAB,XA,YA,ZA,XB,YB,ZB)
C
      RETURN
      END
C     SUBROUTINE  DRVTVX (NUMVAR,NN2,VAR,ETOTAL,F,G,CO,CHARGE)
      SUBROUTINE  DRVTVX (VAR,ETOTAL,F,G,CO,CHARGE)
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXATM=3000,MAXVAR=800,MAXINT=60000)
C     PARAMETER  (MAXCNS=900,MAXPER=10000)
C     PARAMETER  (MXATM1=MAXATM+1,MVAR1=MAXVAR+1)
C     PARAMETER  (MXPAIR=MAXVAR*(MAXVAR+1)/2)
C     PARAMETER  (MXPAR1=(MAXVAR+1)*(MAXVAR+2)/2)
C     PARAMETER  (MAXJ=2*MAXVAR)
C     PARAMETER  (MAXSS =5,MAXSS2=MAXSS*2)
C     PARAMETER  (MAXI1=MAXINT/2,MAXI2=MAXINT-MAXI1)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (ATOM)
      INCLUDE 'inc/atom'
CMSP  INCLUDE (BOND)
      INCLUDE 'inc/bond'
CMSP  INCLUDE (NBTYPE)
      INCLUDE 'inc/nbtype'
CMSP  INCLUDE (TABLE1)
      INCLUDE 'inc/table1'
CMSP  INCLUDE (TORSN0)
      INCLUDE 'inc/torsn0'
CMSP  INCLUDE (SSPAIR)
      INCLUDE 'inc/sspair'
CMSP  INCLUDE (WKENRG)
      INCLUDE 'inc/wkenrg'
CMSP  INCLUDE (WKDRVTV)
      INCLUDE 'inc/wkdrvtv'
C     COMMON/NUMBER/  NUMATM,JUMVAR,MM2,NUMINT,NSS,NUMRES
C     COMMON/ATOM00/  KUNIT(MAXATM),KATOM(MXATM1),JATOM(MAXATM)
C     COMMON/BOND00/  DIRCOS(3,MAXVAR),IBND1(MAXVAR),IBND2(0:MVAR1)
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/ENE001/  ERRR,WVLTN
      COMMON/ENE002/  COX(3,MAXATM),NFLAG(MAXATM)
      COMMON/RANGE/   KRANGE
      COMMON/INTR14/  NO14(-1:MAXVAR),LIST14(100),
     &                NO12(-1:MAXVAR),LIST12(100)
C     COMMON/NBTYPE/  NBTYPE(MAXATM)
C     COMMON/TABLE1/  IFRONT(MAXVAR),NBACK(0:MAXVAR),IBACK(2,0:MAXVAR)
      COMMON/TABLE3/  NINT,IPAIR1(MAXI1),IPAIR2(MAXI2),LINT(-1:MAXVAR)
      COMMON/TABLE4/  KMAX,LISTK(-1:MAXVAR),JANGLE(MXPAIR),
     &                 KANGLE(0:MXPAR1)
C     COMMON/TORSN0/  A(MAXVAR),NB(MAXVAR),NS(MAXVAR),IFTOR(MAXVAR)
C     COMMON/SSPAIR/  KSSPER(6,2,MAXSS),JSS(3,MAXSS),KSS(MAXSS2),
C    &                LSS(MAXSS2)
      COMMON/RAB/     R(30*MAXJ,3)
C     DIMENSION  VAR(MAXVAR),F(MAXVAR),G(MXPAIR),EF(6*MAXVAR)
      DIMENSION  VAR(MAXVAR),F(MAXVAR),G(MXPAIR)
C     DIMENSION  CO(3,*),CHARGE(*),VECPRD(3,MAXVAR)
      DIMENSION  CO(3,*),CHARGE(*)
C     DIMENSION  JAA(MAXJ),JBB(MAXJ),JBF(MAXJ),LAB(MAXJ)
C     DIMENSION  JPAIR1(MAXPER),JPAIR2(MAXPER)
C
      DATA  ZERO /0.D0/
C
C  GENERATE THE ATOMIC COORDINATES.
C
      CALL  GENRA (VAR,CO)
C
C  INITIALIZE THE PARAMETERS.
C
      CALL  DRVINI (CO,DIRCOS,VECPRD,IBND2,KADD1,KADD2,KADD3,EF,G)
      MSS = 1
      DO  2  KADD = 1, 3
      DO  2  J01  = 1, 30*MAXJ
  2     R(J01,KADD) = ZERO
C
C************************************************************
C  THIS SECTION CALCULATES THE FIRST AND SECOND DERIVATIVES.
C************************************************************
C----------- START OF DO LOOP 100 ------------------------------------
C
      DO  100  K = KRANGE, 0, -1
C
        CALL  DRVSET (K,JK,JFIN,LI,LFIN,LISTK,KANGLE,IFRONT,LINT,
     &                JAA,JBB,JBF,LAB,R(1,KADD1))
C
        IF (LFIN.EQ.0)  GOTO  5
C
        IF (K.LE.2)  THEN
          LI = LINT(K) - LINT(2) + 1
          CALL  DCALX (LFIN,JFIN,IPAIR1(LI),IPAIR2(LI),R(1,KADD1),
     &                 JANGLE(JK),JAA,JBF,EF,CO,COX,NFLAG)
C
          IF (NSS.EQ.0)  GOTO  5
          IF (MSS.LT.0)  GOTO  5
C
  20      IF (KSS(LSS(MSS)).NE.K)  GOTO  5
            LS = (LSS(MSS)+1)/2
            CALL  DCALSS (KSSPER(1,1,LS),KSSPER(1,2,LS),R(1,KADD1),
     &          JSS(1,LS),KANGLE(JK),EF,MOD(LSS(MSS)+1,2)+1,IFRONT,CO)
            MSS = MSS+1
            IF (MSS.LE.2*NSS)  GOTO  20
C
            MSS = -MSS
C
        ELSE
          MFLAG = -1
          LI14 = NO14(K)
          LF14 = NO14(K-1)-1
          MI12 = NO12(K)
          MF12 = NO12(K-1)-1
C
          IF (NSS.EQ.0)  GOTO  40
          IF (MSS.LT.0)  GOTO  40
C
  30      IF (KSS(LSS(MSS)).NE.K)  GOTO  40
            LS = (LSS(MSS)+1)/2
            CALL  DCALSS (KSSPER(1,1,LS),KSSPER(1,2,LS),R(1,KADD1),
     &          JSS(1,LS),KANGLE(JK),EF,MOD(LSS(MSS)+1,2)+1,IFRONT,CO)
            MSS = MSS+1
            MFLAG = K
            IF (MSS.LE.2*NSS)  GOTO  30
C
            MSS = -MSS
C
  40        CALL  PAIR15 (JPAIR1,JPAIR2,JAA,JBF,JFIN,KATOM,JATOM,
     &              IBND2,LI14,LF14,LIST14,MI12,MF12,LIST12,MFLAG)
            CALL  DCALX (LFIN,JFIN,JPAIR1,JPAIR2,R(1,KADD1),
     &                 JANGLE(JK),JAA,JBF,EF,CO,COX,NFLAG)
        ENDIF
C
   5    CALL  DRCRNT (K,JK,JFIN,JAA,JBB,LAB,KADD1,KADD2,KADD3,
     &                DIRCOS,VECPRD,G)
C
        KA1 = KADD1
        KADD1 = KADD3
        KADD3 = KADD2
        KADD2 = KA1
C
  100 CONTINUE
C
C---------- END OF DO LOOP 100 -------------------------------------
C
      CALL  DFRCRT (NBACK,IBACK,EF,F,DIRCOS,VECPRD)
C
      CALL  DTORSN (A,NB,NS,IFTOR,VAR,F,G)
C
      ETTL = ETOR + ELOOP + ECYSTR
      ETOTAL = ETTL + ERRR*WVLTN
C
      CALL  OUT002
C
      RETURN
      END
      SUBROUTINE  DCALX (LFIN,JFIN,IPAIR1,IPAIR2,EL,NOPAIR,
     &                  JAA,JBF,EF,CO,COX,NFLAG)
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXPER=10000)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (WKCAL1)
      INCLUDE 'inc/wkcal1'
CMSP  INCLUDE (WKCAL2)
      INCLUDE 'inc/wkcal2'
CMSP  INCLUDE (WKCAL3)
      INCLUDE 'inc/wkcal3'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/ENE001/  ERRR,WVLTN
      DIMENSION  EL(30,JFIN),NOPAIR(JFIN),JAA(JFIN),JBF(JFIN)
      DIMENSION  EF(6,NUMVAR),CO(3,*),COX(3,NUMATM),NFLAG(NUMATM)
C     INCLUDE (COORD)
      DIMENSION  IPAIR1(LFIN),IPAIR2(LFIN)
C     DIMENSION  CAB(MAXPER),DAB(MAXPER)
C     DIMENSION  MFLAGX(MAXPER)
C     DIMENSION  IWRKA(MAXPER),IWRKB(MAXPER)
C     DIMENSION  XA(MAXPER)  ,YA(MAXPER)  ,ZA(MAXPER)
C     DIMENSION  XB(MAXPER)  ,YB(MAXPER)  ,ZB(MAXPER)
C     DIMENSION  XAB(MAXPER) ,YAB(MAXPER) ,ZAB(MAXPER)
C     DIMENSION  XAXB(MAXPER),YAXB(MAXPER),ZAXB(MAXPER)
C     DIMENSION  R(MAXPER),RI2(MAXPER),RX(MAXPER),WGHT(MAXPER)
      DIMENSION  RI2(MAXPER),RX(MAXPER),WGHT(MAXPER)
      EQUIVALENCE  (RI2,XAXB),(RX,YAXB),(WGHT,ZAXB)
      DATA  ZERO,ONE,TWO /0.D0,1.D0,2.D0/
C
      II = 0
      DO  10  L = 1, LFIN
        JPA = IABS(IPAIR1(L))
        JPB = IPAIR2(L)
        XA(L) = CO(1,JPA)
        YA(L) = CO(2,JPA)
        ZA(L) = CO(3,JPA)
        XB(L) = CO(1,JPB)
        YB(L) = CO(2,JPB)
        ZB(L) = CO(3,JPB)
        XAB(L) = XA(L)-XB(L)
        YAB(L) = YA(L)-YB(L)
        ZAB(L) = ZA(L)-ZB(L)
        R2 = XAB(L)*XAB(L)+YAB(L)*YAB(L)+ZAB(L)*ZAB(L)
        R(L) = DSQRT(R2)
        RI2(L) = ONE / R2
        CAB(L) = ZERO
        DAB(L) = ZERO
        IF (NFLAG(JPA).EQ.1.AND.NFLAG(JPB).EQ.1)  THEN
          II = II+1
          MFLAGX(II) = L
          R2XXX = (COX(1,JPA)-COX(1,JPB))**2 +
     &       (COX(2,JPA)-COX(2,JPB))**2 + (COX(3,JPA)-COX(3,JPB))**2
          RX(II) = DSQRT(R2XXX)
          WGHT(II) = ONE/R2XXX*WVLTN
        ENDIF
  10  CONTINUE
C
      DO  12  I = 1, II
          L = MFLAGX(I)
          ERRR = ERRR + WGHT(I)*(R(L) - RX(I))**2
          AR = RX(I)/R(L)
          CAB(L) = CAB(L) + TWO*WGHT(I)*(ONE-AR)
          DAB(L) = DAB(L) + TWO*WGHT(I)*AR*RI2(L)
  12  CONTINUE
C
      CALL  DRMTRX (LFIN,JFIN,IWRKA,IWRKB,EL,EF,NOPAIR,JAA,JBF,CAB,DAB,
     &              XAXB,YAXB,ZAXB,XAB,YAB,ZAB,XA,YA,ZA,XB,YB,ZB)
C
      RETURN
      END
      SUBROUTINE  DRVINI(CO,DIRCOS,VECPRD,IBND2,KADD1,KADD2,KADD3,EF,G)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/NUMBR1/  NATM1,NVAR1,NPAIR1
      DIMENSION  CO(3,*),DIRCOS(3,NUMVAR),VECPRD(3,NUMVAR)
      DIMENSION  IBND2(0:NVAR1),G(NN2),EF(6*NUMVAR)
C
      DATA  ZERO /0.D0/
C
C  INITIALIZE THE FOLLOWING PARAMETERS.
C
      DO  10  I = 1, NUMVAR
        JBND2 = IBND2(I)
        VECPRD(1,I) = DIRCOS(2,I)*CO(3,JBND2)-DIRCOS(3,I)*CO(2,JBND2)
        VECPRD(2,I) = DIRCOS(3,I)*CO(1,JBND2)-DIRCOS(1,I)*CO(3,JBND2)
        VECPRD(3,I) = DIRCOS(1,I)*CO(2,JBND2)-DIRCOS(2,I)*CO(1,JBND2)
 10   CONTINUE
C
        KADD1 = 1
        KADD2 = 2
        KADD3 = 3
C
        CALL  EZERO
C
      DO  20  J = 1, 6*NUMVAR
  20    EF(J) = ZERO
C
      DO  30  I = 1, NN2
  30    G(I) = ZERO
C
      RETURN
      END
C
      SUBROUTINE  DRVSET (K,JK,JFIN,LI,LFIN,LISTK,KANGLE,IFRONT,LINT,
     &                    JAA,JBB,JBF,LAB,R)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/NUMBR1/  NATM1,NVAR1,NPAIR1
      DIMENSION  LISTK(-1:NUMVAR),KANGLE(0:NPAIR1),IFRONT(NUMVAR)
      DIMENSION  LINT(-1:NUMVAR),JAA(*),JBB(*),JBF(*),LAB(*),R(*)
      DATA  ZERO /0.D0/
C
        JK   = LISTK(K)
        JFIN = LISTK(K-1) - LISTK(K)
C
        DO  10  J = JK, JK+JFIN-1
          I = J-JK+1
          KA = IABS(KANGLE(J))
          JAA(I) = KA/10000
          JBB(I) = KA - JAA(I)*10000
          JBF(I) = JBB(I)
          IF (KANGLE(J).LT.0)  JBF(I) = IFRONT(JBB(I))
          LAB(I) = JAA(I)*(JAA(I)-1)/2 + JBB(I)
  10    CONTINUE
C
        DO  20  J = 1, 30*JFIN
  20      R(J) = ZERO
C
        LI = LINT(K)
        LFIN = LINT(K-1) - LINT(K)
C
        RETURN
        END
      SUBROUTINE  DRMTRX (LFIN,JFIN,IPA,IPB,EL,EF,NOPAIR,JAA,JBF,
     &            CAB,DAB,XAXB,YAXB,ZAXB,XAB,YAB,ZAB,XA,YA,ZA,XB,YB,ZB)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  EL(30,JFIN),NOPAIR(JFIN),JAA(JFIN),JBF(JFIN)
      DIMENSION  EF(6,NUMVAR)
      DIMENSION  CAB(LFIN),DAB(LFIN),IPA(LFIN),IPB(LFIN)
      DIMENSION  XA(LFIN)  ,YA(LFIN)  ,ZA(LFIN)
      DIMENSION  XB(LFIN)  ,YB(LFIN)  ,ZB(LFIN)
      DIMENSION  XAB(LFIN) ,YAB(LFIN) ,ZAB(LFIN)
      DIMENSION  XAXB(LFIN),YAXB(LFIN),ZAXB(LFIN)
C
      DO  10  L = 1, LFIN
        XAXB(L) = YA(L)*ZB(L) - ZA(L)*YB(L)
        YAXB(L) = ZA(L)*XB(L) - XA(L)*ZB(L)
        ZAXB(L) = XA(L)*YB(L) - YA(L)*XB(L)
  10  CONTINUE
C
      DO  20  L = 1, LFIN
        XA(L) = XA(L)*CAB(L)
        YA(L) = YA(L)*CAB(L)
        ZA(L) = ZA(L)*CAB(L)
  20  CONTINUE
C
      LMAX = NOPAIR(JFIN)/10000
      IPB(JFIN) = LMAX
      IPA(1) = 0
      IF (JFIN.GT.1)  THEN
        DO  30  J = 1, JFIN-1
          IPB(J) = NOPAIR(J)/10000
          IPA(J+1) = IPA(J) + IPB(J)
  30      LMAX = MAX(LMAX,IPB(J))
      ENDIF
      LMIN = MIN(LMAX,6)
C
C CALCULATIONS ARE DIVIDED INTO TWO PARTS (DO LOOPS 50 AND 70),
C BECAUSE OF SPEED-UP IN SUPERCOMPUTER.
C
      DO  50  I = 1, LMIN
      I10000=10000*I
      DO  40  JST = 1, JFIN, 500
        JFN = MIN (JST+499, JFIN)
C
*VOPTION LOOP(500)
      DO  42  J = JST, JFN
      IF (NOPAIR(J).LT.I10000)  GOTO  42
      L = IPA(J) + I
      TX = DAB(L)*XAXB(L)
       EL(1,J) = EL(1,J) + YA(L)*YB(L)+ZA(L)*ZB(L)+TX*XAXB(L)
       EL(2,J) = EL(2,J) - XA(L)*YB(L)            +TX*YAXB(L)
       EL(3,J) = EL(3,J) - XA(L)*ZB(L)            +TX*ZAXB(L)
       EL(4,J) = EL(4,J)                          +TX*XAB(L)
       EL(5,J) = EL(5,J) + CAB(L)*ZB(L)           +TX*YAB(L)
       EL(6,J) = EL(6,J) - CAB(L)*YB(L)           +TX*ZAB(L)
      TY = DAB(L)*YAXB(L)
       EL(7,J) = EL(7,J) - YA(L)*XB(L)            +TY*XAXB(L)
       EL(8,J) = EL(8,J) + XA(L)*XB(L)+ZA(L)*ZB(L)+TY*YAXB(L)
       EL(9,J) = EL(9,J) - YA(L)*ZB(L)            +TY*ZAXB(L)
       EL(10,J)= EL(10,J)- CAB(L)*ZB(L)           +TY*XAB(L)
       EL(11,J)= EL(11,J)                         +TY*YAB(L)
       EL(12,J)= EL(12,J)+ CAB(L)*XB(L)           +TY*ZAB(L)
      TZ = DAB(L)*ZAXB(L)
       EL(13,J)= EL(13,J)- ZA(L)*XB(L)            +TZ*XAXB(L)
       EL(14,J)= EL(14,J)- ZA(L)*YB(L)            +TZ*YAXB(L)
       EL(15,J)= EL(15,J)+ XA(L)*XB(L)+YA(L)*YB(L)+TZ*ZAXB(L)
       EL(16,J)= EL(16,J)+ CAB(L)*YB(L)           +TZ*XAB(L)
       EL(17,J)= EL(17,J)- CAB(L)*XB(L)           +TZ*YAB(L)
       EL(18,J)= EL(18,J)                         +TZ*ZAB(L)
  42  CONTINUE
C
*VOPTION LOOP(500)
      DO  43  J = JST, JFN
      IF (NOPAIR(J).LT.I10000)  GOTO  43
      L = IPA(J) + I
      TX = DAB(L)*XAB(L)
       EL(19,J)= EL(19,J)- ZA(L)                +TX*YAXB(L)
       EL(20,J)= EL(20,J)+ YA(L)                +TX*ZAXB(L)
       EL(21,J)= EL(21,J)+ CAB(L)               +TX*XAB(L)
       EL(22,J)= EL(22,J)                       +TX*YAB(L)
       EL(23,J)= EL(23,J)                       +TX*ZAB(L)
      TY = DAB(L)*YAB(L)
       EL(24,J)= EL(24,J)+ ZA(L)                +TY*XAXB(L)
       EL(25,J)= EL(25,J)- XA(L)                +TY*ZAXB(L)
       EL(26,J)= EL(26,J)+ CAB(L)               +TY*YAB(L)
       EL(27,J)= EL(27,J)                       +TY*ZAB(L)
      TZ = DAB(L)*ZAB(L)
       EL(28,J)= EL(28,J)- YA(L)                +TZ*XAXB(L)
       EL(29,J)= EL(29,J)+ XA(L)                +TZ*YAXB(L)
       EL(30,J)= EL(30,J)+ CAB(L)               +TZ*ZAB(L)
  43  CONTINUE
C
 40   CONTINUE
 50   CONTINUE
C
      IF (LMAX.EQ.LMIN)  GOTO  80
      IFIN=0
      DO  70  J = 1, JFIN
      ISTRT = IFIN + 7
      IFIN = IFIN + IPB(J)
      IF(ISTRT.GT.IFIN)  GOTO  70
C
      DO  60  L = ISTRT, IFIN
      TX = DAB(L)*XAXB(L)
       EL(1,J) = EL(1,J) + YA(L)*YB(L)+ZA(L)*ZB(L)+TX*XAXB(L)
       EL(2,J) = EL(2,J) - XA(L)*YB(L)            +TX*YAXB(L)
       EL(3,J) = EL(3,J) - XA(L)*ZB(L)            +TX*ZAXB(L)
       EL(4,J) = EL(4,J)                          +TX*XAB(L)
       EL(5,J) = EL(5,J) + CAB(L)*ZB(L)           +TX*YAB(L)
       EL(6,J) = EL(6,J) - CAB(L)*YB(L)           +TX*ZAB(L)
      TY = DAB(L)*YAXB(L)
       EL(7,J) = EL(7,J) - YA(L)*XB(L)            +TY*XAXB(L)
       EL(8,J) = EL(8,J) + XA(L)*XB(L)+ZA(L)*ZB(L)+TY*YAXB(L)
       EL(9,J) = EL(9,J) - YA(L)*ZB(L)            +TY*ZAXB(L)
       EL(10,J)= EL(10,J)- CAB(L)*ZB(L)           +TY*XAB(L)
       EL(11,J)= EL(11,J)                         +TY*YAB(L)
       EL(12,J)= EL(12,J)+ CAB(L)*XB(L)           +TY*ZAB(L)
      TZ = DAB(L)*ZAXB(L)
       EL(13,J)= EL(13,J)- ZA(L)*XB(L)            +TZ*XAXB(L)
       EL(14,J)= EL(14,J)- ZA(L)*YB(L)            +TZ*YAXB(L)
       EL(15,J)= EL(15,J)+ XA(L)*XB(L)+YA(L)*YB(L)+TZ*ZAXB(L)
       EL(16,J)= EL(16,J)+ CAB(L)*YB(L)           +TZ*XAB(L)
       EL(17,J)= EL(17,J)- CAB(L)*XB(L)           +TZ*YAB(L)
       EL(18,J)= EL(18,J)                         +TZ*ZAB(L)
      TX = DAB(L)*XAB(L)
       EL(19,J)= EL(19,J)- ZA(L)                  +TX*YAXB(L)
       EL(20,J)= EL(20,J)+ YA(L)                  +TX*ZAXB(L)
       EL(21,J)= EL(21,J)+ CAB(L)                 +TX*XAB(L)
       EL(22,J)= EL(22,J)                         +TX*YAB(L)
       EL(23,J)= EL(23,J)                         +TX*ZAB(L)
      TY = DAB(L)*YAB(L)
       EL(24,J)= EL(24,J)+ ZA(L)                  +TY*XAXB(L)
       EL(25,J)= EL(25,J)- XA(L)                  +TY*ZAXB(L)
       EL(26,J)= EL(26,J)+ CAB(L)                 +TY*YAB(L)
       EL(27,J)= EL(27,J)                         +TY*ZAB(L)
      TZ = DAB(L)*ZAB(L)
       EL(28,J)= EL(28,J)- YA(L)                 +TZ*XAXB(L)
       EL(29,J)= EL(29,J)+ XA(L)                  +TZ*YAXB(L)
       EL(30,J)= EL(30,J)+ CAB(L)                 +TZ*ZAB(L)
  60  CONTINUE
C
  70  CONTINUE
C
  80  IFIN = 0
      DO  82  L = 1, LFIN
        XAXB(L) = CAB(L)*XAXB(L)
        YAXB(L) = CAB(L)*YAXB(L)
        ZAXB(L) = CAB(L)*ZAXB(L)
        XAB(L) = CAB(L)*XAB(L)
        YAB(L) = CAB(L)*YAB(L)
        ZAB(L) = CAB(L)*ZAB(L)
  82  CONTINUE
C
      DO  90  J = 1, JFIN
      IF (IPB(J).LE.0)  GOTO  90
      ISTRT = IFIN + 1
      IFIN = IFIN + IPB(J)
      IA = JAA(J)
        DO  84  L = ISTRT, IFIN
          EF(1,IA) = EF(1,IA) + XAXB(L)
          EF(2,IA) = EF(2,IA) + YAXB(L)
          EF(3,IA) = EF(3,IA) + ZAXB(L)
          EF(4,IA) = EF(4,IA) + XAB(L)
          EF(5,IA) = EF(5,IA) + YAB(L)
          EF(6,IA) = EF(6,IA) + ZAB(L)
  84    CONTINUE
C
      IB = JBF(J)
      IF (IB.EQ.0)  GOTO  90
        DO  86  L = ISTRT, IFIN
          EF(1,IB) = EF(1,IB) - XAXB(L)
          EF(2,IB) = EF(2,IB) - YAXB(L)
          EF(3,IB) = EF(3,IB) - ZAXB(L)
          EF(4,IB) = EF(4,IB) - XAB(L)
          EF(5,IB) = EF(5,IB) - YAB(L)
          EF(6,IB) = EF(6,IB) - ZAB(L)
  86    CONTINUE
  90  CONTINUE
      RETURN
      END
      SUBROUTINE  DRCRNT(K,JK,JFIN,JAA,JBB,LAB,KADD1,KADD2,KADD3,
     &                   DIRCOS,VECPRD,G)
C
C  CALCULATE RECURRENT EQUATION OF MATRIX R AND SECOND DERIVATIVES G.
C
      IMPLICIT REAL*8 (A-H,O-Z)
C     PARAMETER  (MAXVAR=800)
C     PARAMETER  (MXPAIR=MAXVAR*(MAXVAR+1)/2)
C     PARAMETER  (MXPAR1=(MAXVAR+1)*(MAXVAR+2)/2)
C     PARAMETER  (MAXJ=2*MAXVAR)
CMSP  INCLUDE (MAXSIZE)
      INCLUDE 'inc/maxsize'
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
CMSP  INCLUDE (TABLE1)
      INCLUDE 'inc/table1'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
C     COMMON/TABLE1/  IFRONT(MAXVAR),NBACK(0:MAXVAR),IBACK(2,0:MAXVAR)
      COMMON/TABLE4/  KMAX,LISTK(-1:MAXVAR),JANGLE(MXPAIR),
     &                 KANGLE(0:MXPAR1)
      COMMON/RAB/     R(30,MAXJ,3)
      DIMENSION  DIRCOS(3,NUMVAR),VECPRD(3,NUMVAR),G(NN2)
      DIMENSION  JAA(JFIN),JBB(JFIN),LAB(JFIN)
C
      DIMENSION  LIST(30)
      DATA  LIST /1,7,13,4,24,28,2,8,14,19,11,29,3,9,15,20,25,18,10,
     &            16,21,22,23,5,17,26,27,6,12,30/
C
        IF (K.EQ.KMAX)  GOTO  60
C
      DO  600  J = JK, JK+JFIN-1
        JJ = J-JK+1
        IA = JAA(JJ)
        IB = JBB(JJ)
        IFLAG = NBACK(IA)-1
C
        IF (KANGLE(J))  300, 600, 200
C
C --- KANGLE(J) > 0  ---
C
  200     IF (NBACK(IB)-1)  210, 220, 230
C
C** NBACK(IB)=0 **
C
  210       IF(IFLAG)  600, 212, 214
C
C  NBACK(IB)=0, NBACK(IA)=1
C
  212         IA1 = IBACK(1,IA)
              MA = (IA1*(IA1-1))/2
              J1 = MOD(JANGLE(MA+IB),10000)
                  GOTO  410
C
C  NBACK(IB)=0, NBACK(IA)=2
C
  214         IA1 = IBACK(1,IA)
              MA = (IA1*(IA1-1))/2
              J1 = MOD(JANGLE(MA+IB),10000)
              IA2 = IBACK(2,IA)
              MA = (IA2*(IA2-1))/2
              J2 = MOD(JANGLE(MA+IB),10000)
                  GOTO  420
C
C** NBACK(IB)=1 **
C
  220     IB1 = IBACK(1,IB)
  222     MA = (IA*(IA-1))/2
          J1 = MOD(JANGLE(MA+IB1),10000)
          IF(IFLAG)  410, 224, 226
C
C  NBACK(IB)=1, NBACK(IA)=1
C
  224       IA1 = IBACK(1,IA)
            MA = (IA1*(IA1-1))/2
            J2 = MOD(JANGLE(MA+IB),10000)
            J5 = MOD(JANGLE(MA+IB1),10000)
                GOTO  430
C
C  NBACK(IB)=1, NBACK(IA)=2
C
  226       IA1 = IBACK(1,IA)
            MA = (IA1*(IA1-1))/2
            J2 = MOD(JANGLE(MA+IB),10000)
            J5 = MOD(JANGLE(MA+IB1),10000)
            IA2 = IBACK(2,IA)
            MA = (IA2*(IA2-1))/2
            J3 = MOD(JANGLE(MA+IB),10000)
            J6 = MOD(JANGLE(MA+IB1),10000)
                GOTO  440
C
C** NBACK(IB)=2 **
C
  230     IB1 = IBACK(1,IB)
          IB2 = IBACK(2,IB)
  232     MA = (IA*(IA-1))/2
          J1 = MOD(JANGLE(MA+IB1),10000)
          J2 = MOD(JANGLE(MA+IB2),10000)
          IF(IFLAG)  420, 234, 236
C
C  NBACK(IB)=2, NBACK(IA)=1
C
  234       IA1 = IBACK(1,IA)
            MA = (IA1*(IA1-1))/2
            J3 = MOD(JANGLE(MA+IB),10000)
            J5 = MOD(JANGLE(MA+IB1),10000)
            J6 = MOD(JANGLE(MA+IB2),10000)
                GOTO  440
C
C  NBACK(IB)=2, NBACK(IA)=2
C
  236       IA1 = IBACK(1,IA)
            MA = (IA1*(IA1-1))/2
            J3 = MOD(JANGLE(MA+IB),10000)
            J5 = MOD(JANGLE(MA+IB1),10000)
            J6 = MOD(JANGLE(MA+IB2),10000)
            IA2 = IBACK(2,IA)
            MA = (IA2*(IA2-1))/2
            J4 = MOD(JANGLE(MA+IB),10000)
            J7 = MOD(JANGLE(MA+IB1),10000)
            J8 = MOD(JANGLE(MA+IB2),10000)
                GOTO  450
C
C --- KANGLE(J) < 0  ---
C
  300   IFRB = IFRONT(IB)
        IF(IFRB)  600, 310, 330
C
C** IFRONT(IB)=1 **
C
  310     IF(NBACK(IFRB)-1)  600, 210, 320
C
C**** CONSIDER THE CASE OF NBACK(IFRONT(IB))=2 ONLY **
C
  320       IB1 = IBACK(1,IFRB)
            IF(IB1.EQ.IB)  IB1 = IBACK(2,IFRB)
            IF(IB1.LT.IA)  GOTO  222
            MB = (IB1*(IB1-1))/2
            J2 = MOD(JANGLE(MB+IA),10000)
            IF(IFLAG)  460, 322, 324
C
C  NBACK(IFRONT(IB))=2, NBACK(IA)=1
C
  322         IA1 = IBACK(1,IA)
              MA = (IA1*(IA1-1))/2
              J1 = MOD(JANGLE(MA+IB),10000)
              J5 = MOD(JANGLE(MB+IA1),10000)
                  GOTO  480
C
C  NBACK(IFRONT(IB))=2, NBACK(IA)=2
C
  324         IA1 = IBACK(1,IA)
              MA = (IA1*(IA1-1))/2
              J1 = MOD(JANGLE(MA+IB),10000)
              J5 = MOD(JANGLE(MB+IA1),10000)
              IA2 = IBACK(2,IA)
              MA = (IA2*(IA2-1))/2
              J3 = MOD(JANGLE(MA+IB),10000)
              J6 = MOD(JANGLE(MB+IA2),10000)
                  GOTO  490
C
C** IFRONT(IB)=2 **
C
  330     IB1 = IFRB
          IF(NBACK(IFRB)-1)  600, 222, 332
C
C**** CONSIDER THE CASE OF NBACK(IFRONT(IB))=2 ONLY **
C
  332       IB2 = IBACK(1,IFRB)
            IF(IB2.EQ.IB)  IB2 = IBACK(2,IFRB)
            IF(IB2.LT.IA)  GOTO  232
            MA = (IA*(IA-1))/2
            J1 = MOD(JANGLE(MA+IB1),10000)
            MB = (IB2*(IB2-1))/2
            J2 = MOD(JANGLE(MB+IA),10000)
            IF(IFLAG)  470, 334, 336
C
C  NBACK(IFRONT(IB))=2, NBACK(IA)=1
C
  334         IA1 = IBACK(1,IA)
              MA = (IA1*(IA1-1))/2
              J3 = MOD(JANGLE(MA+IB),10000)
              J5 = MOD(JANGLE(MA+IB1),10000)
              J6 = MOD(JANGLE(MB+IA1),10000)
                  GOTO  500
C
C  NBACK(IFRONT(IB))=2, NBACK(IA)=2
C
  336         IA1 = IBACK(1,IA)
              MA = (IA1*(IA1-1))/2
              J3 = MOD(JANGLE(MA+IB),10000)
              J5 = MOD(JANGLE(MA+IB1),10000)
              J6 = MOD(JANGLE(MB+IA1),10000)
              IA2 = IBACK(2,IA)
              MA = (IA2*(IA2-1))/2
              J4 = MOD(JANGLE(MA+IB),10000)
              J7 = MOD(JANGLE(MA+IB1),10000)
              J8 = MOD(JANGLE(MB+IA2),10000)
                  GOTO  510
C
C-------- RECURRENT EQUATION OF R -------------------------------------
C
  410 DO  412  I = 1, 30
  412 R(I,JJ,KADD1)=R(I,JJ,KADD1) + R(I,J1,KADD2)
        GOTO  600
C
  420 DO  422  I = 1, 30
  422 R(I,JJ,KADD1)=R(I,JJ,KADD1) + R(I,J1,KADD2) + R(I,J2,KADD2)
        GOTO  600
C
  430 DO  432  I = 1, 30
  432 R(I,JJ,KADD1)=R(I,JJ,KADD1) + R(I,J1,KADD2) + R(I,J2,KADD2)
     &              - R(I,J5,KADD3)
        GOTO  600
C
  440 DO  442  I = 1, 30
  442 R(I,JJ,KADD1)=R(I,JJ,KADD1) + R(I,J1,KADD2) + R(I,J2,KADD2)
     &            + R(I,J3,KADD2) - R(I,J5,KADD3) - R(I,J6,KADD3)
        GOTO  600
C
  450 DO  452  I = 1, 30
  452 R(I,JJ,KADD1)=R(I,JJ,KADD1) + R(I,J1,KADD2) + R(I,J2,KADD2)
     &            + R(I,J3,KADD2) + R(I,J4,KADD2) - R(I,J5,KADD3)
     &            - R(I,J6,KADD3) - R(I,J7,KADD3) - R(I,J8,KADD3)
        GOTO  600
C
*VOPTION VEC
  460 DO  462  I = 1, 30
  462 R(I,JJ,KADD1)=R(I,JJ,KADD1) + R(LIST(I),J2,KADD2)
        GOTO  600
C
*VOPTION VEC
  470 DO  472  I = 1, 30
  472 R(I,JJ,KADD1)=R(I,JJ,KADD1) + R(I,J1,KADD2) + R(LIST(I),J2,KADD2)
        GOTO  600
C
*VOPTION VEC
  480 DO  482  I = 1, 30
  482 R(I,JJ,KADD1)=R(I,JJ,KADD1) + R(I,J1,KADD2) + R(LIST(I),J2,KADD2)
     &            - R(LIST(I),J5,KADD3)
        GOTO  600
C
*VOPTION VEC
  490 DO  492  I = 1, 30
  492 R(I,JJ,KADD1)=R(I,JJ,KADD1) + R(I,J1,KADD2) + R(LIST(I),J2,KADD2)
     &     + R(I,J3,KADD2) - R(LIST(I),J5,KADD3) - R(LIST(I),J6,KADD3)
        GOTO  600
C
*VOPTION VEC
  500 DO  502  I = 1, 30
  502 R(I,JJ,KADD1)=R(I,JJ,KADD1) + R(I,J1,KADD2) + R(LIST(I),J2,KADD2)
     &            + R(I,J3,KADD2) - R(I,J5,KADD3) - R(LIST(I),J6,KADD3)
        GOTO  600
C
*VOPTION VEC
  510 DO  512  I = 1, 30
  512 R(I,JJ,KADD1)=R(I,JJ,KADD1) + R(I,J1,KADD2) + R(LIST(I),J2,KADD2)
     &              + R(I,J3,KADD2) + R(I,J4,KADD2) - R(I,J5,KADD3)
     &      - R(LIST(I),J6,KADD3) - R(I,J7,KADD3) - R(LIST(I),J8,KADD3)
C
C----------------------------------------------------------------------
C
  600 CONTINUE
C
C << SECOND DERIVATIVES >>
C
*VOPTION VEC,NOFVAL
  60  DO  70  I = 1, JFIN
        IA = JAA(I)
        IB = JBB(I)
      G(LAB(I)) =
     &        + DIRCOS(1,IA)*(R(1,I,KADD1)*DIRCOS(1,IB)+R(7,I,KADD1)*
     &DIRCOS(2,IB)+R(13,I,KADD1)*DIRCOS(3,IB)+R(4,I,KADD1)*VECPRD(1,IB)
     &+R(24,I,KADD1)*VECPRD(2,IB)+R(28,I,KADD1)*VECPRD(3,IB))
     &        + DIRCOS(2,IA)*(R(2,I,KADD1)*DIRCOS(1,IB)+R(8,I,KADD1)*
     &DIRCOS(2,IB)+R(14,I,KADD1)*DIRCOS(3,IB)+R(19,I,KADD1)*VECPRD(1,IB)
     &+R(11,I,KADD1)*VECPRD(2,IB)+R(29,I,KADD1)*VECPRD(3,IB))
     &        + DIRCOS(3,IA)*(R(3,I,KADD1)*DIRCOS(1,IB)+R(9,I,KADD1)*
     &DIRCOS(2,IB)+R(15,I,KADD1)*DIRCOS(3,IB)+R(20,I,KADD1)*VECPRD(1,IB)
     &+R(25,I,KADD1)*VECPRD(2,IB)+R(18,I,KADD1)*VECPRD(3,IB))
     &        + VECPRD(1,IA)*(R(4,I,KADD1)*DIRCOS(1,IB)+R(10,I,KADD1)*
     &DIRCOS(2,IB)+R(16,I,KADD1)*DIRCOS(3,IB)+R(21,I,KADD1)*VECPRD(1,IB)
     &+R(22,I,KADD1)*VECPRD(2,IB)+R(23,I,KADD1)*VECPRD(3,IB))
     &        + VECPRD(2,IA)*(R(5,I,KADD1)*DIRCOS(1,IB)+R(11,I,KADD1)*
     &DIRCOS(2,IB)+R(17,I,KADD1)*DIRCOS(3,IB)+R(22,I,KADD1)*VECPRD(1,IB)
     &+R(26,I,KADD1)*VECPRD(2,IB)+R(27,I,KADD1)*VECPRD(3,IB))
     &        + VECPRD(3,IA)*(R(6,I,KADD1)*DIRCOS(1,IB)+R(12,I,KADD1)*
     &DIRCOS(2,IB)+R(18,I,KADD1)*DIRCOS(3,IB)+R(23,I,KADD1)*VECPRD(1,IB)
     &+R(27,I,KADD1)*VECPRD(2,IB)+R(30,I,KADD1)*VECPRD(3,IB))
  70  CONTINUE
C
*VOPTION VEC,NOFVAL
      DO  80  J = JK, JK+JFIN-1
        NADD = LAB(J-JK+1)
        IF (KANGLE(J).GT.0)  G(NADD) = -G(NADD)
  80  CONTINUE
C
      RETURN
      END
      SUBROUTINE  DFRCRT (NBACK,IBACK,EF,F,DIRCOS,VECPRD)
C
C  CALCULATE THE GRADIENT F(I)
C
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      DIMENSION  NBACK(0:NUMVAR),IBACK(2,0:NUMVAR),EF(6,NUMVAR)
      DIMENSION  F(NUMVAR),DIRCOS(3,NUMVAR),VECPRD(3,NUMVAR)
C
C <RECURRENT EQUATION>
C
      DO  130  I = NUMVAR-1, 1, -1
C
        IF (NBACK(I)-1)  130, 110, 120
C
C    NBACK(I)=1
C
*VOPTION VEC
  110     DO  112  J = 1, 6
  112       EF(J,I) = EF(J,I) + EF(J,IBACK(1,I))
              GOTO  130
C
C    NBACK(I)=2
C
*VOPTION VEC
  120     DO  122  J = 1, 6
  122       EF(J,I) = EF(J,I) + EF(J,IBACK(1,I)) + EF(J,IBACK(2,I))
C
  130 CONTINUE
C
C <GRADIENT>
C
      DO  140  I = 1, NUMVAR
      F(I)=-DIRCOS(1,I)*EF(1,I)-DIRCOS(2,I)*EF(2,I)-DIRCOS(3,I)*EF(3,I)
     &     -VECPRD(1,I)*EF(4,I)-VECPRD(2,I)*EF(5,I)-VECPRD(3,I)*EF(6,I)
  140 CONTINUE
C
      RETURN
      END
      SUBROUTINE  DTORSN (A,NB,NS,IFTOR,VAR,F,G)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      DIMENSION  A(NUMVAR),NB(NUMVAR),NS(NUMVAR),IFTOR(NUMVAR)
      DIMENSION  VAR(NUMVAR),F(NUMVAR),G(NN2)
C
*VOPTION VEC
      DO  10  I = 1, NUMVAR
        IF (IFTOR(I).EQ.1)  THEN
          COSV = A(I)*NS(I)*DCOS(NB(I)*VAR(I))
          ETOR = ETOR + A(I) + COSV
          F(I) = F(I) - A(I)*NS(I)*NB(I)*DSIN(NB(I)*VAR(I))
          NADD = I*(I+1)/2
          G(NADD) = G(NADD) - NB(I)*NB(I)*COSV
        ENDIF
  10  CONTINUE
C
      RETURN
      END
      SUBROUTINE  DCALSS (IPAIR1,IPAIR2,EL,JJ,KANGLE,EF,IFLAG,IFRONT,CO)
      IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (SIZE)
      INCLUDE 'inc/size'
C     COMMON/NUMBER/  NUMATM,NUMVAR,NN2,NUMINT,NSS,NUMRES
      COMMON/ENE000/  ETOR,EES,ENB,ELOOP,ECYSTR
      COMMON/DISULF/  RSS(4),ASS(4),BSS(9)
      DIMENSION  EF(6,NUMVAR),EL(30,*),KANGLE(*),IFRONT(NUMVAR),CO(3,*)
      DIMENSION  IPAIR1(6),IPAIR2(6),CAB(6),DAB(6)
      DIMENSION  XA(6),YA(6),ZA(6),XB(6),YB(6),ZB(6)
      DIMENSION  XAB(6) ,YAB(6) ,ZAB(6)
      DIMENSION  XAXB(6),YAXB(6),ZAXB(6)
      DIMENSION  RMAG(6),RI1(6),RI2(6)
      DIMENSION  KSTRT(2),KFIN(2),LSTRT(2),LFIN(2),MSTRT(3),MFIN(3)
      DIMENSION  JJ(3)
      DATA  KSTRT /1,2/, LSTRT/1,5/, MSTRT/1,5,6/
      DATA  KFIN  /1,3/, LFIN /4,6/, MFIN /4,5,6/
      DATA  ONE,TWO /1.D0,2.D0/
C
       IF (IFLAG.EQ.2)  RETURN
C
      DO  10  L = LSTRT(IFLAG), LFIN(IFLAG)
        JPA = IPAIR1(L)
        JPB = IPAIR2(L)
        XA(L) = CO(1,JPA)
        YA(L) = CO(2,JPA)
        ZA(L) = CO(3,JPA)
        XB(L) = CO(1,JPB)
        YB(L) = CO(2,JPB)
        ZB(L) = CO(3,JPB)
        XAB(L) = XA(L)-XB(L)
        YAB(L) = YA(L)-YB(L)
        ZAB(L) = ZA(L)-ZB(L)
        XAXB(L) = YA(L)*ZB(L) - ZA(L)*YB(L)
        YAXB(L) = ZA(L)*XB(L) - XA(L)*ZB(L)
        ZAXB(L) = XA(L)*YB(L) - YA(L)*XB(L)
        RMAG(L) = XAB(L)*XAB(L) + YAB(L)*YAB(L) + ZAB(L)*ZAB(L)
        RI2(L) = ONE / RMAG(L)
        RI1(L) = DSQRT(RMAG(L))
  10  CONTINUE
C
C     IF (IFLAG.EQ.1)  THEN
C
        DO  20  L = 1, 4
          IF(L.LE.3) ELOOP = ELOOP + ASS(L)*(RI1(L)-RSS(L))**2
          RI = RSS(L)/RI1(L)
          CAB(L) = TWO*ASS(L)*(ONE-RI)
          DAB(L) = TWO*ASS(L)*RI*RI2(L)
  20    CONTINUE
        ECYSTR = ECYSTR + ASS(4)*(RI1(4)-RSS(4))**2
C
C* DOES NOT CARRY OUT THE FOLLOWINGS AT PRESENT. **
C
C     ELSE
C       DO  22  L = LSTRT(IFLAG), LFIN(IFLAG)
C         IF (RI1(L).LT.BSS(8))  THEN
C         ECYSTR = ECYSTR + ((BSS(1)*RMAG(L) + BSS(3))*RMAG(L) + BSS(5))
C    &           *RMAG(L) + ((BSS(2)*RMAG(L) + BSS(4))*RMAG(L) + BSS(6))
C    &            *RI1(L) + BSS(7)
C         CAB(L) = (6*BSS(1)*RMAG(L) + 4*BSS(3))*RMAG(L)
C    &           + (5*BSS(2)*RMAG(L) + 3*BSS(4))*RI1(L)
C    &           + 2*BSS(5) + BSS(6)/RI1(L)
C         DAB(L) = 24*BSS(1)*RMAG(L) + 15*BSS(2)*RI1(L) + 8*BSS(3)
C    &           + 3*BSS(4)/RI1(L) - BSS(6)*RI2(L)/RI1(L)
C          ELSE
C          ECYSTR = ECYSTR + BSS(9)*(RI1(L)-BSS(8))**2
C          RI = BSS(8)/RI1(L)
C          CAB(L) = TWO*BSS(9)*(ONE-RI)
C          DAB(L) = TWO*BSS(9)*RI*RI2(L)
C          ENDIF
C 22    CONTINUE
C     ENDIF
C*
C
      DO  40  K = KSTRT(IFLAG), KFIN(IFLAG)
        J = JJ(K)
        KA = IABS(KANGLE(J))
        IA = KA/10000
C
      DO  30  L = MSTRT(K), MFIN(K)
C
        EF(1,IA) = EF(1,IA) + CAB(L)*XAXB(L)
        EF(2,IA) = EF(2,IA) + CAB(L)*YAXB(L)
        EF(3,IA) = EF(3,IA) + CAB(L)*ZAXB(L)
        EF(4,IA) = EF(4,IA) + CAB(L)*XAB(L)
        EF(5,IA) = EF(5,IA) + CAB(L)*YAB(L)
        EF(6,IA) = EF(6,IA) + CAB(L)*ZAB(L)
C
      TX = DAB(L)*XAXB(L)
       EL(1,J) = EL(1,J) + CAB(L)*(YA(L)*YB(L)+ZA(L)*ZB(L))
     &                                          +TX*XAXB(L)
       EL(2,J) = EL(2,J) + CAB(L)*(-XA(L)*YB(L))+TX*YAXB(L)
       EL(3,J) = EL(3,J) + CAB(L)*(-XA(L)*ZB(L))+TX*ZAXB(L)
       EL(4,J) = EL(4,J)                        +TX*XAB(L)
       EL(5,J) = EL(5,J) + CAB(L)*ZB(L)         +TX*YAB(L)
       EL(6,J) = EL(6,J) + CAB(L)*(-YB(L))      +TX*ZAB(L)
      TY = DAB(L)*YAXB(L)
       EL(7,J) = EL(7,J) + CAB(L)*(-YA(L)*XB(L))+TY*XAXB(L)
       EL(8,J) = EL(8,J) + CAB(L)*(XA(L)*XB(L)+ZA(L)*ZB(L))
     &                                          +TY*YAXB(L)
       EL(9,J) = EL(9,J) + CAB(L)*(-YA(L)*ZB(L))+TY*ZAXB(L)
       EL(10,J)= EL(10,J)+ CAB(L)*(-ZB(L))      +TY*XAB(L)
       EL(11,J)= EL(11,J)                       +TY*YAB(L)
       EL(12,J)= EL(12,J)+ CAB(L)*XB(L)         +TY*ZAB(L)
      TZ = DAB(L)*ZAXB(L)
       EL(13,J)= EL(13,J)+ CAB(L)*(-ZA(L)*XB(L))+TZ*XAXB(L)
       EL(14,J)= EL(14,J)+ CAB(L)*(-ZA(L)*YB(L))+TZ*YAXB(L)
       EL(15,J)= EL(15,J)+ CAB(L)*(XA(L)*XB(L)+YA(L)*YB(L))
     &                                          +TZ*ZAXB(L)
       EL(16,J)= EL(16,J)+ CAB(L)*YB(L)         +TZ*XAB(L)
       EL(17,J)= EL(17,J)+ CAB(L)*(-XB(L))      +TZ*YAB(L)
       EL(18,J)= EL(18,J)                       +TZ*ZAB(L)
      TX = DAB(L)*XAB(L)
       EL(19,J)= EL(19,J)+ CAB(L)*(-ZA(L))      +TX*YAXB(L)
       EL(20,J)= EL(20,J)+ CAB(L)*YA(L)         +TX*ZAXB(L)
       EL(21,J)= EL(21,J)+ CAB(L)               +TX*XAB(L)
       EL(22,J)= EL(22,J)                       +TX*YAB(L)
       EL(23,J)= EL(23,J)                       +TX*ZAB(L)
      TY = DAB(L)*YAB(L)
       EL(24,J)= EL(24,J)+ CAB(L)*ZA(L)         +TY*XAXB(L)
       EL(25,J)= EL(25,J)+ CAB(L)*(-XA(L))      +TY*ZAXB(L)
       EL(26,J)= EL(26,J)+ CAB(L)               +TY*YAB(L)
       EL(27,J)= EL(27,J)                       +TY*ZAB(L)
      TZ = DAB(L)*ZAB(L)
       EL(28,J)= EL(28,J)+ CAB(L)*(-YA(L))      +TZ*XAXB(L)
       EL(29,J)= EL(29,J)+ CAB(L)*XA(L)         +TZ*YAXB(L)
       EL(30,J)= EL(30,J)+ CAB(L)               +TZ*ZAB(L)
  30  CONTINUE
C
        IB = MOD(KA,10000)
        IF (KANGLE(J).LT.0)  IB = IFRONT(IB)
        IF (IB.EQ.0)  GOTO  40
C
      DO  34  L = MSTRT(K), MFIN(K)
        EF(1,IB) = EF(1,IB) - CAB(L)*XAXB(L)
        EF(2,IB) = EF(2,IB) - CAB(L)*YAXB(L)
        EF(3,IB) = EF(3,IB) - CAB(L)*ZAXB(L)
        EF(4,IB) = EF(4,IB) - CAB(L)*XAB(L)
        EF(5,IB) = EF(5,IB) - CAB(L)*YAB(L)
        EF(6,IB) = EF(6,IB) - CAB(L)*ZAB(L)
  34  CONTINUE
C
  40  CONTINUE
      RETURN
      END
CKM   SUBROUTINE CLOCK(TIME,ID)
CKM   CALL CLOCKM(ITIME)
CKM   TIME=ITIME*0.001
CKM   CALL SECOND(TIME)
CKM   RETURN
CKM   END
C
      SUBROUTINE FOUTGR(IOUT,COLMS,LINES,NDATA,GX,GY)
C
      INTEGER IOUT,LINES,COLMS,NDATA
      PARAMETER (IGRMAX=128)
      REAL*8 GX(IGRMAX),GY(IGRMAX)
      CALL GRAPH(IOUT,'SCAT','CONFORMATIONAL ENERGY F0',COLMS,LINES
     &           ,NDATA
     &           ,GX,5,'ITERATIONS'
     &           ,GY,3,'ENERGY')
      RETURN
      END
