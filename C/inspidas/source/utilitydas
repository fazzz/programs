C*    DEC/CMS REPLACEMENT HISTORY, ELEMENT UTILITIES.FOR
C*    *70   23-JAN-1989 13:11:45 DBK ""
C*    *69   20-JAN-1989 18:05:00 DBK ""
C*    *68   20-JAN-1989 18:02:35 DBK ""
C*    *67   20-JAN-1989 17:42:40 DBK "FIX PARSER ERROR CHECKING SO THAT
C*    *66   19-JAN-1989 13:12:02 DBK "REMOVE CFLX CARDS"
C*    *65   18-JAN-1989 16:23:34 DBK "FIX CALL GTRMSTR IN ATNA ROUTINE"
C*    *64   18-JAN-1989 13:15:43 DBK "CHANGE CALL FRESTK TO = FRESTK"
C*    *63   15-DEC-1988 15:56:55 DBK "ADD GETFILNM"
C*    *62    8-DEC-1988 19:40:41 DBK ""
C*    *61    8-DEC-1988 18:41:57 DBK "FIX COMPRES"
C*    *60    8-DEC-1988 18:26:50 DBK "FIX LCRMSTR FOR ZERO LENGTH LINE"
C*    *59    6-DEC-1988 12:35:24 DBK "ADD GETRESN AND GETATNA"
C*    *58   21-NOV-1988 18:38:58 DBK "ADD NEW PARSING COMMAND"
C*    *57   11-NOV-1988 12:00:18 DBK ""
C*    *56   10-NOV-1988 13:28:45 DBK ""
C*    *55   10-NOV-1988 13:20:25 DBK ""
C*    *54   10-NOV-1988 13:07:19 DBK ""
C*    *53   10-NOV-1988 12:35:19 DBK ""
C*    *52   10-NOV-1988 12:19:46 DBK ""
C*    *51   10-NOV-1988 11:49:07 DBK ""
C*    *50   10-NOV-1988 11:38:13 DBK ""
C*    *49    9-NOV-1988 17:54:05 DBK ""
C*    *48    9-NOV-1988 17:45:28 DBK ""
C*    *47    9-NOV-1988 17:33:50 DBK ""
C*    *46    9-NOV-1988 17:08:23 DBK ""
C*    *45    9-NOV-1988 14:42:41 DBK ""
C*    *44    8-NOV-1988 18:13:25 DBK ""
C*    *43    8-NOV-1988 16:38:47 DBK ""
C*    *42    8-NOV-1988 16:23:39 DBK ""
C*    *41    8-NOV-1988 15:44:25 DBK ""
C*    *40    8-NOV-1988 14:52:48 DBK ""
C*    *39    8-NOV-1988 14:43:15 DBK "ADD NXTWRD"
C*    *38    8-NOV-1988 14:35:43 DBK ""
C*    *37    7-NOV-1988 18:39:21 DBK ""
C*    *36    7-NOV-1988 18:31:20 DBK ""
C*    *35    7-NOV-1988 18:22:12 DBK ""
C*    *34    7-NOV-1988 18:09:05 DBK "FIX LCRMSTR"
C*    *33    7-NOV-1988 17:17:47 DBK ""
C*    *32    4-NOV-1988 15:18:18 DBK "GET RID OF JOINWD"
C*    *31    4-NOV-1988 15:14:51 DBK ""
C*    *30    4-NOV-1988 10:52:32 DBK "FIX KYWRD"
C*    *29    1-NOV-1988 17:18:26 DBK "REMOVE UNUSED ROUTINES"
C*    *28    1-NOV-1988 16:55:30 DBK ""
C*    *27    1-NOV-1988 15:06:33 DBK "ADD NEW PARSER ROUTINES"
C*    *26   12-OCT-1988 11:12:00 DBK "REMOVE GRAPHICS ROUTINES"
C*    *25   10-OCT-1988 15:15:40 DBK "ADD SEND1D ROUTINE - 1D PLOTTING"
C*    *24   20-SEP-1988 16:32:24 BACK ""
C*    *23   20-SEP-1988 11:12:46 BACK ""
C*    *22   19-SEP-1988 17:33:21 DBK ""
C*    *21   19-SEP-1988 16:16:44 BACK ""
C*    *20   19-SEP-1988 15:45:02 BACK ""
C*    *19   19-SEP-1988 15:10:49 BACK "FIXED MALLADJSTMENT ERROR IN -NUM
C*    *18   19-SEP-1988 13:15:00 DBK ""
C*    *17   15-SEP-1988 13:25:18 DBK ""
C*    *16   14-SEP-1988 14:23:19 DBK ""
C*    *15   14-SEP-1988 14:21:36 DBK ""
C*    *14   14-SEP-1988 12:02:58 DBK ""
C*    *13    8-SEP-1988 18:27:07 DBK "FIX DLPRBL ROUTINE - PROBLEM ON CO
C*    *12    7-SEP-1988 16:55:39 DBK "REMOVE EXCLAMATION PTS"
C*    *11    1-SEP-1988 20:27:50 DK "CHANGED ARGUMENT FOR OPENING FILES
C*    *10    1-SEP-1988 16:35:00 DK ""
C*    *9     1-SEP-1988 16:30:57 DK ""
C*    *8     1-SEP-1988 16:05:53 DK "CHANGED C.A.'S ON SEND2D"
C*    *7     1-SEP-1988 11:28:41 DK "CHANGED CALLING ARGUMENTS TO SEND2D
C*    *6    31-AUG-1988 16:17:56 DK "CORRECTION TO UNITNUMBERS"
C*    *5    31-AUG-1988 16:11:06 DK "ADDED SEND2D AND MORE OPTIONS TO PA
C*    *4    30-AUG-1988 17:35:58 DK "CHANGED REFERENCE DIRECTORY OF COMM
C*    *3    30-AUG-1988 17:29:11 DK "ADDED PARSPLOT TO UTILITIES"
C*    *2    19-JUL-1988 12:13:49 DBK ""
C*    *1     6-JUL-1988 15:36:49 DBK "PARSER + DIE + READTITL"
C*    DEC/CMS REPLACEMENT HISTORY, ELEMENT UTILITIES.FOR
C
C
C*MODULE PARSER *DECK CHCNBL
      SUBROUTINE CHCNBL(ST,STLEN)
C
C     THIS SUBROUTINE CONVERTS ALL NONACCEPTABLE CONTROL CHARACTERS
C     INTO BLANKS. ST IS DESTINED TO GO INTO A FORMAT BETWEEN
C     QUOTES. THIS SUBROUTINE IS MACHINE DEPENDENT.
C
      IMPLICIT INTEGER(A-Z)
      CHARACTER*1 BLANK,LOWPRT,HGHPRT
      CHARACTER*(*) ST
      DATA BLANK /' '/
CMSP  LOWPRT = CHAR(64)
CMSP  HGHPRT = CHAR(255)
CTTN  LOWPRT = CHAR(32)
CTTN  HGHPRT = CHAR(125)
CCYB  LOWPRT = CHAR(32)
CCYB  HGHPRT = CHAR(125)
CVAX  LOWPRT = CHAR(32)
CVAX  HGHPRT = CHAR(125)
C
      IF (STLEN.EQ.0) RETURN
      DO 1 I=1,STLEN
        IF(ST(I:I).GE.LOWPRT .AND. ST(I:I).LE.HGHPRT) GOTO 1
          ST(I:I)=BLANK
    1   CONTINUE
      RETURN
      END
C
C*MODULE PARSER *DECK CLCSPC
      SUBROUTINE CLCSPC(ST,IFST)
CJDW 22-MAR-88 FIX THE CASE FOR NO TRAILING SPACE.
C
C FINDS LOCATION OF FIRST SPACE OR NULL IN ST OR LEN(ST) + 1 IF
C  NO SPACE IS FOUND. THE RESULT IS RETURNED IN IFST
C
      CHARACTER*(*) ST
      CHARACTER NULL*1
      NULL=CHAR(0)
      IFST = LEN(ST) + 1
      DO 1 I=1,LEN(ST)
        IF ((ST(I:I) .EQ. ' ').OR.(ST(I:I).EQ.NULL)) THEN
           IFST = I
           GO TO 2
        ENDIF
  1   CONTINUE
2     CONTINUE
      RETURN
      END
C
C*MODULE PARSER *DECK CNVTUC
      SUBROUTINE CNVTUC(ST,STLEN)
C
C     THIS CONVERTS A STRING TO ALL UPPERCASE. IT USES BYTE VARIABLES
C     AND THE PROPERTY OF ASCII CODES THAT LETTERS ARE CONTIGUOUS AND
C     UPPER CASE LETTERS ARE ALWAYS OFFSET A CONSTANT AMOUNT FROM THE
C     EQUIVALENT LOWERCASE LETTER SO IT IS MACHINE DEPENDENT.
C
      IMPLICIT INTEGER(A-Z)
      CHARACTER*(*) ST
      CHARACTER*1 A
C
      DO 10 I=1,STLEN
         A= ST(I:I)
         IA = ICHAR(A)
CMSP     IF(IA.GE.129.AND.IA.LE.169)THEN
CMSP        IA=IA + 64
CTTN     IF(IA.GE.97)THEN
CTTN        IA=IA - 32
CCYB     IF(IA.GE.97)THEN
CCYB        IA=IA - 32
CVAX     IF(IA.GE.97)THEN
CVAX        IA=IA - 32
            A = CHAR (IA)
            ST(I:I)=A
         ENDIF
10    CONTINUE
      RETURN
      END
C*MODULE PARSER *DECK COMPARE
      SUBROUTINE COMPAR (DATA,VARI,IFLAG)
      CHARACTER*4 DATA
      CHARACTER*1 VARI(4)
C
         DO 124 J=1,4
         IFLAG=INDEX(DATA(J:J),VARI(J))
           IF(IFLAG.EQ.0) RETURN
124      CONTINUE
128   CONTINUE
      RETURN
      END
C*MODULE DECODE.F *DECK DCWORK.F
C PROCEDURES DECODI DECODF
C PROJECT IMPACT
C PROGRAMER STEVEN BACK
C : TOCONVERT A STRING INTO A NUMBER.
C
C    ICTRL
C     0         INTEGER VALUE
C     1         REAL VALUE
       SUBROUTINE DCWORK(STRIN1,ICTRL,IOUT,ROUT)
       IMPLICIT REAL*8 (A-H,O-Z)
       CHARACTER*(*) STRIN1
       CHARACTER STRWOR *80
       I=1
        IPNT = 1
 50    IF (STRIN1(I:I).EQ.' ') THEN
           I=I+1
           GOTO 50
       ENDIF
       SIGN=1.0D0
       STRWOR ='0'
       IF (STRIN1(I:I).EQ.'-') THEN
           SIGN=-1.0D0
       ENDIF
       IF (STRIN1(I:I).EQ.'+'.OR. STRIN1(I:I).EQ.'-') THEN
           I=I+1
       ENDIF
 100   IF (STRIN1(I:I).GE.'0' .AND. STRIN1(I:I).LE.'9') THEN
           STRWOR (IPNT:IPNT)=STRIN1(I:I)
           IPNT = IPNT + 1
           I=I+1
           GOTO 100
       ENDIF
       DMENT=STRVAL(STRWOR ,IPNT-1)
C
C     IF ICTRL=0 THEN RETURN INTEGER PORTION
C
           IF (ICTRL.EQ.0) THEN
               DMENT = (DMENT+0.001D+00)*SIGN
               IOUT=INT(DMENT)
               RETURN
           ENDIF
C
C     OTHERWISE LOOK FOR '.'
C
           IF (STRIN1(I:I).EQ.'.') THEN
               I=I+1
               J=1
               STRWOR ='0'
 200           IF (STRIN1(I:I).GE.'0' .AND. STRIN1(I:I).LE.'9') THEN
                   STRWOR (J:J)=STRIN1(I:I)
                   I=I+1
                   J=J+1
                   GOTO 200
               ENDIF
               DFRACT=STRVAL(STRWOR ,J-1)/(10.0D+00**DFLOAT(J-1))
               DMENT=DMENT+DFRACT
           ENDIF
C
C     THEN CHECK FOR EXPONENT.
C
           IF (STRIN1(I:I).EQ.'E'.OR.STRIN1(I:I)
     1     .EQ.'E'.OR.    STRIN1(I:I).EQ.'D'.OR.STRIN1(I:I).EQ.'D') THEN
               I=I+1
           ENDIF
           ESIGN=1.0D0
           IF (STRIN1(I:I).EQ.'-') THEN
               ESIGN=-1.0D0
           ENDIF
           IF (STRIN1(I:I).EQ.'+'.OR.STRIN1(I:I).EQ.'-') THEN
               I=I+1
           ENDIF
           J=1
           STRWOR ='0'
 300       IF (STRIN1(I:I).GE.'0' .AND. STRIN1(I:I).LE.'9') THEN
               STRWOR (J:J)=STRIN1(I:I)
               I=I+1
               J=J+1
               GOTO 300
           ENDIF
           IF (J.GT.1) THEN
               DEXP=STRVAL(STRWOR ,J-1)
               ELSE
               DEXP=0.0
           ENDIF
           DTEST=(10.0D0**(ESIGN*DEXP))
           IF (ESIGN.GT.0.0D0) THEN
               DMENT=DMENT*(10.0D0**(DEXP))
               ELSE
               DMENT=DMENT/(10.0D0**(DEXP))
           ENDIF
           ROUT=DMENT*SIGN
           RETURN
           END
C*MODULE DECODE.F *DECK DECODF.F
C
C
CFH    REAL*8 FUNCTION DECODF(TXT,ISTRLEN)
       DOUBLE PRECISION FUNCTION DECODF(TXT,ISTRLE )
       IMPLICIT REAL*8 (A-H,O-Z)
          INTEGER*4       ISTRLE
       CHARACTER*1 TXT(ISTRLE +1)
       CHARACTER WORK*40
       DO 100 I=1,ISTRLE
           WORK(I:I)=TXT(I)
  100  CONTINUE
       WORK(ISTRLE +1:ISTRLE +1)=' '
       CALL DCWORK(WORK,1,IOUT,ROUT)
       DECODF=ROUT
       RETURN
       END
C*MODULE DECODE.F *DECK DECODI.F
C
C
       INTEGER FUNCTION DECODI(TXT,ISTRLE )
       IMPLICIT REAL*8 (A-H,O-Z)
          INTEGER*4       ISTRLE
       CHARACTER*1 TXT(ISTRLE )
       CHARACTER WORK*40
       DO 100 I=1,ISTRLE
           WORK(I:I)=TXT(I)
  100  CONTINUE
       WORK(ISTRLE +1:ISTRLE +1)=' '
       CALL DCWORK(WORK,0,IOUT,ROUT)
       DECODI=IOUT
       RETURN
       END
C ----------------------------------------------------------------
        SUBROUTINE DIE
C ----------------------------------------------------------------
C PURPOSE: TO PROVIDE A TRACEBACK OF ERRORS
C
C
        DIE1 = 0.0
        DIE2 = 1.0/DIE1
C
        STOP
        END
C
C*MODULE PARSER *DECK DLPRBLK
      SUBROUTINE DLPRBL (ST)
CDBK 07-APR-88 FIX THE CASE FOR A PRECEDING BLANK
C
C DELETES PRECEDING BLANK OR NULL CHARACTERS OF STRING IF FOUND
C
C
      CHARACTER*(*) ST
        CHARACTER*80 TMP
        CHARACTER*1 NULL
        NULL = CHAR(0)
      ILNGTH = LEN(ST)
        ITOT = LEN(ST)
        TMP(1:ITOT) = ST(1:ITOT)
        I=1
10      CONTINUE
        IF ((ST(I:I) .EQ. ' ').OR.(ST(I:I).EQ.NULL)) THEN
           ILNGTH = ITOT - I
           IBEG = I + 1
           TMP(1:ILNGTH) = ST(IBEG:ITOT)
           I = I + 1
           IF (I .EQ. ITOT) GO TO 2
           GO TO 10
        ENDIF
2     CONTINUE
        ST(1:ITOT) = TMP(1:ILNGTH)
      RETURN
      END
C*MODULE PARSER *DECK ECHO
      SUBROUTINE ECHOIN(NLINE)
CMSP  INCLUDE (UNITNUMS)
CTTN  INCLUDE '/labo/qclib/inspidas/common/unitnums'
CMSP  INCLUDE (ECHO)
CTTN  INCLUDE '/labo/qclib/inspidas/common/echo'
C
      DO 100 I=1,500
       READ(IN01,10,END=999) INLINE(I)
100   CONTINUE
999   NLINE=I - 1
10    FORMAT(A80)
      REWIND IN01
      RETURN
      END
C*MODULE PARSER *DECK ECHOOUT
      SUBROUTINE ECHOOU (NLINE)
CMSP  INCLUDE (UNITNUMS)
CTTN  INCLUDE '/labo/qclib/inspidas/common/unitnums'
CMSP  INCLUDE (ECHO)
CTTN  INCLUDE '/labo/qclib/inspidas/common/echo'
C
      DO 100 I=1,NLINE
       WRITE(IOUT02,10) INLINE(I)
100   CONTINUE
C
10    FORMAT(6X,A80)
      WRITE(IOUT02,*)
      RETURN
      END
C*MODULE ENCODE.F *DECK ENCODF.F
C
C ENCODF: CONVERT REAL NUMBER TO STRING
C     WITH MINIMUZATION OF RESULTING STRING
C     (WHICH MEANS UNEEDED SPACES, ZEROS AND DECIMAL
C     POINTS ARE REMOVED)
C
       SUBROUTINE ENCODF(RNUMBE ,TXT,MAXSIZ ,NUMSIZ )
       IMPLICIT REAL*8 (A-H,O-Z)
          REAL*8          RNUMBE
          INTEGER*4       MAXSIZ
          INTEGER*4       NUMSIZ
       CHARACTER*(*) TXT
       CHARACTER TEMP*1,HOLD*25
       RNUM=RNUMBE
       IFRMT=0
       TXT='                      '
       CALL XYITOS(RNUM,TXT,NUMSIZ ,IFRMT,14,7)
 100   IF (TXT(1:1).EQ.' ') THEN
           CALL XYDELC (TXT,1,1)
           GOTO 100
       ENDIF
       CALL XYLSCH(TXT,NUMSIZ )
       TEMP=TXT(NUMSIZ :NUMSIZ )
 200   IF ((TEMP.EQ.' '.OR.TEMP.EQ.'0'.OR.TEMP.EQ.'.').AND.
     * NUMSIZ .GT.1) THEN
           CALL XYDELC (TXT,NUMSIZ ,1)
           NUMSIZ =NUMSIZ -1
           TEMP=TXT(NUMSIZ :NUMSIZ )
           GOTO 200
       ENDIF
       END
C*MODULE ENCODE.F *DECK ENCODI.F
C
C SUBROUTINE ENCODI, CONVERT AN INTEGER TO A STRING
C
       SUBROUTINE ENCODI(NUMBER,TXT,MAXSIZ ,NUMSIZ )
       IMPLICIT REAL*8 (A-H,O-Z)
          INTEGER*4       MAXSIZ
          INTEGER*4       NUMSIZ
       CHARACTER*(*) TXT
       CHARACTER TEMP*12
       TXT=' '
       IF (NUMBER.LT.0) THEN
           ISIGN=-1
           ELSE
           ISIGN=1
       ENDIF
       CALL XYITOC(NUMBER,TXT,MAXSIZ )
 100   IF (TXT(1:1).EQ.' ') THEN
           CALL XYDELC (TXT,1,1)
           GOTO 100
       ENDIF
       IF (ISIGN.EQ.-1) THEN
           CALL XYAPPD(TEMP,'-',TXT)
           TXT=TEMP
       ENDIF
       CALL XYLSCH(TXT,NUMSIZ )
       END
C
C*MODULE PARSER *DECK EQST
      FUNCTION EQST(ST1,LEN1,ST2,LEN2)
C
C     COMPARES TWO STRINGS AND RETURNS TRUE IF THEY ARE EQUAL.
C
      IMPLICIT INTEGER(A-Z)
      LOGICAL EQST
      CHARACTER*1 ST1(1),ST2(2)
C
      IF(LEN1.EQ.LEN2) GOTO 1
      EQST=.FALSE.
      RETURN
    1 EQST=.TRUE.
      IF (LEN1.EQ.0) RETURN
      DO 2 I=1,LEN1
        IF(ST1(I).NE.ST2(I)) GOTO 3
    2   CONTINUE
      RETURN
    3 EQST=.FALSE.
      RETURN
      END
C*MODULE PARSER *DECK FILNUL
      SUBROUTINE FILNUL(ST,STMAX,STLEN)
C
C     THIS SUBROUTINE FILLS THE UNUSED PART OF ST WITH ASCII NUL (0)
C
      IMPLICIT INTEGER(A-Z)
      CHARACTER*(*) ST
      CHARACTER*(1) NUL
C
      NUL=CHAR(0)
      IF(STLEN.EQ.STMAX) RETURN
      S=STLEN+1
      DO 1 I=S,STMAX
    1   ST(I:I)=NUL
      RETURN
      END
C*MODULE PARSER *DECK FILSPC
      SUBROUTINE FILSPC(ST,STMAX,STLEN)
C
C     THIS SUBROUTINE FILLS THE UNUSED PART OF ST WITH SPACES.
C
      IMPLICIT INTEGER(A-Z)
      CHARACTER*(*) ST
      CHARACTER*1 BLANK
      DATA BLANK/' '/
C
      IF(STLEN.EQ.STMAX) RETURN
      S=STLEN+1
      DO 1 I=S,STMAX
    1   ST(I:I)=BLANK
      RETURN
      END
C*MODULE DECODE.F *DECK STRVAL.F
C
C SUBROUTINE STRVAL: USED BY DECODE, CONVERTES A SIMPLE,
C INTEGER (STYLELIZED) NUMBER IN CHARACTER FORM INTO A REAL
C
CFH    REAL*8 FUNCTION STRVAL(TXT,ISIZE)
       DOUBLE PRECISION FUNCTION STRVAL(TXT,ISIZE)
       IMPLICIT REAL*8 (A-H,O-Z)
          INTEGER*4       LETZER
       CHARACTER*(*) TXT
       TENVAL=10.0D0**DFLOAT(ISIZE-1)
       RVAL=0
C GET THE ASCII VALUE OF ZERO
       LETZER =ICHAR('0')
       ICOUNT=1
 100   IF (ICOUNT.LE.ISIZE) THEN
           RVAL=RVAL+TENVAL*DFLOAT(ICHAR(TXT(ICOUNT:ICOUNT))-LETZER )
           TENVAL=TENVAL/10.0D0
           ICOUNT=ICOUNT+1
           GOTO 100
       ENDIF
       STRVAL=RVAL
       RETURN
       END
C*MODULE PARSER *DECK GTFLNM
        SUBROUTINE GTFLNM(FILNAM)
CMSP  INCLUDE (COMMAND)
CTTN  INCLUDE '/labo/qclib/inspidas/common/command'
        CHARACTER*(*) FILNAM
         LENFL = LEN(FILNAM)
         CALL NXTWRD(COMLY2 ,COMLEN,FILNAM,LENFL)
CVAX     CALL FILSPC(FILNAM,60,LENFL)
CCYB     CALL FILSPC(FILNAM,60,LENFL)
CTTN     CALL FILNUL(FILNAM,60,LENFL)
CMSP     CALL FILNUL(FILNAM,60,LENFL)
         RETURN
         END
       SUBROUTINE KYWRD(KEYWOR ,KEY,NSIZE)
       IMPLICIT REAL*8 (A-H,O-Z)
       CHARACTER*(*) KEYWOR
       CHARACTER*1  KEY(NSIZE)
       DO 10 I=1,NSIZE
         KEY(I)=KEYWOR (I:I)
10     CONTINUE
       RETURN
       END
C*MODULE PARSER *DECK NXTCMND
      SUBROUTINE NXTCMN (NXTSTR)
C     DECLARATIONS FOR COMMAND SCANNING.
C
CMSP  INCLUDE (COMMAND)
CTTN  INCLUDE '/labo/qclib/inspidas/common/command'
CMSP  INCLUDE (UNITNUMS)
CTTN  INCLUDE '/labo/qclib/inspidas/common/unitnums'
      INTEGER CEIL,TASK,INUNIT,PRUNIT
      INTEGER DELEN
      INTEGER WDLEN,WDMAX,SRCHWD,INDX,ST,STLEN
      LOGICAL  DELIM
      CHARACTER*(*) NXTSTR
      LOGICAL EOF
C
C     PARAMETER NWORD1=24,NWORD2=12,NWORD3 = 4
C
C
      DIMENSION WORDYN(12),ICNTRL(20)
C
      DATA MXCMSZ/2000/
      ISTRM=1
C THIS IS THE .INP FILE IT IS READING FROM
C
C     THIS IS THE MAIN LOOP FOR READING AND PROCESSING COMMANDS. BEFORE
C     READING THE NEXT COMMAND, MAKE SURE THAT THE VARIABLES HAVE NOT
C     EXCEEDED THEIR BOUNDS.
C
   60 CONTINUE
      CALL TRIMST (COMLY2 ,COMLEN)
      IF ( COMLEN .GT. 0 ) THEN
         WRITE(IOUT06,91)
         WRITE(IOUT06,90) COMLY2 (1:COMLEN)
         WRITE(IOUT06,92)
   91 FORMAT(/20X,60('*'),
     1       /20X,'WARNING : FOLLOWING EXTRANEOUS CHARCTERS ',
     2            'FOUND.')
   90 FORMAT(25(/20X,A80))
   92 FORMAT(/20X,60('*'))
      ENDIF
C
      CALL RDCMND(COMLY2 ,MXCMSZ,COMLEN,ISTRM,EOF,.TRUE.)
      IF (EOF)THEN
C
C      EOF = .FALSE.
      WRITE(IOUT06,*)' EOF '
      CALL TIMIT(IOUT02,1)
      STOP ' END OF TASK FILE '
      ENDIF
C
      NXTSTR = ' '
      LENSTR = LEN(NXTSTR)
      CALL NXTWRD(COMLY2 ,COMLEN,NXTSTR,LENSTR)
C
C     SHORTEN WORD TO FOUR CHARACTERS OR LESS AND PAD WITH BLANKS TO
C     PREPARE FOR SEARCH INTO COMMAND ARRAY.
C
      IF (NXTSTR .NE. ' ') THEN
        RETURN
      ELSE
       WRITE(IOUT06,*)' ERROR IN READING NEXT LINE '
       RETURN
      ENDIF
      END
C*MODULE PARSER *DECK RDCMND
      SUBROUTINE RDCMND(COMLYN,MXCMSZ,CMNLEN,UNIT,EOF,QPRINT)
C
C             THIS SUBROUTINE READS A COMMAND IN FROM UNIT. THE COMMAND
C     FIELD ON A LINE MAY EXTEND TO COLUMN 80 OR MAY BE TERMINATED BY AN
C     EXCLAMATION MARK ANYWHERE ON THE LINE. A COMMAND IS ONE COMMAND
C     FIELD OF INFORMATION UNLESS THE LAST NONBLANK CHARACTER IN THAT
C     FIELD IS A HYPHEN. IN THAT CASE, THE COMMAND FIELD ON THE NEXT
C     RECORD IS APPENDED TO THE CHARACTERS PRECEDING THE HYPHEN.
C     TRAILING BLANKS ARE REMOVED FROM ALL COMMAND FIELDS, AND LOWERCASE
C     LETTERS ARE CONVERTED TO UPPERCASE. IF AN END OF FILE IS SEEN
C     WHILE READING A COMMAND, EOF IS TURNED ON. IF EOF IS TURNED ON
C     WHEN CALLED, THE SUBROUTINE RETURNS IMMEDIATELY. IF QPRINT IS ON,
C     THE RECORDS ARE PRINTED ON UNIT 6 AS THEY ARE READ.
C
      IMPLICIT INTEGER(A-Z)
          INTEGER*4       NEWLEN
CMSP  INCLUDE (UNITNUMS)
CTTN  INCLUDE '/labo/qclib/inspidas/common/unitnums'
      CHARACTER*(*) COMLYN
      CHARACTER*1 HYPHEN,EXCLMK
      CHARACTER*80 CARD
      LOGICAL EOF,QPRINT
      DATA HYPHEN/'-'/,EXCLMK/'!'/
C
      IF(EOF) RETURN
      CMNLEN=0
      IF (QPRINT) WRITE(IOUT06,201)
  201 FORMAT('  ')
    1 READ(UNIT,100,END=9) CARD
  100 FORMAT(A80)
  200 FORMAT(14X,80A1)
      CARDLN=80
      IEND = INDEX(CARD,EXCLMK)
      IF (IEND.NE.0) CARDLN=IEND-1
      CALL TRIMST (CARD,CARDLN)
      CALL CHCNBL(CARD,CARDLN)
CMSP  CALL CNVTUC(CARD,CARDLN)
      IF(CARDLN.EQ.0) GOTO 1
      IF(CARD(CARDLN:CARDLN).NE.HYPHEN) THEN
    2    NEWLEN  = CMNLEN + CARDLN
         COMLYN(CMNLEN+1:NEWLEN ) = CARD(1:CARDLN)
         CMNLEN = NEWLEN
         RETURN
      ELSE
        IF(CARDLN.EQ.1) GOTO 1
        NEWLEN  = CMNLEN + CARDLN - 1
        COMLYN(CMNLEN+1:NEWLEN ) = CARD(1:CARDLN-1)
        CMNLEN = NEWLEN
        GOTO 1
      ENDIF
    9 EOF=.TRUE.
      RETURN
      END
C* DEC/CMS REPLACEMENT HISTORY, ELEMENT READTITL.FOR
C* *3    10-MAR-1988 14:28:01 DBK ""
C* *2    10-MAR-1988 12:42:58 DBK ""
C* *1     7-MAR-1988 15:05:20 DBK "UTILITY ROUTINES"
C* DEC/CMS REPLACEMENT HISTORY, ELEMENT READTITL.FOR
      SUBROUTINE READTI  (INUNIT,IOUT,IPRN)
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER*4(I-N)
C
      CHARACTER*80  TITLE
      CHARACTER*1 STAR,BLANK
      DATA  STAR/'*'/, BLANK/' '/
C
C IPRN IS A PRINT FLAG IPRN = 1         PRINT
C                             OTHERWISE NORPINT
C
10    READ(INUNIT,95) TITLE
      IF (TITLE(1:1) .NE. STAR)  THEN
        WRITE(IOUT,110)
        CALL DIE
      ENDIF
C
      DO 20 I=80,2,-1
         IF(TITLE(I:I).NE.BLANK) THEN
           IF(IPRN.EQ.1) WRITE(IOUT,100) TITLE
           GO TO 10
         ENDIF
20      CONTINUE
C
 95   FORMAT(A80)
100   FORMAT(1X,A80)
110   FORMAT(' TITLE CARDS MUST HAVE A * IN THE COLUMN 1 OF EACH LINE',
     . //,' *** EXECUTION TERMINATING *** ')
C
      RETURN
      END
        SUBROUTINE COMPRE (COMLYN,LENCOM)
        IMPLICIT REAL*8 (A-H,O-Z)
C
C REMOVES EXTRA SPACES FROM THE LINE
C  COMLYN - COMMAND LINE
C  LENCOM - LENGTH OF COMMAND LINE
C
        CHARACTER*(*) COMLYN
        CHARACTER*1 TEST
        IF (LENCOM .LE. 0) RETURN
        N = 1
30      CONTINUE
        IBEG = N
        IEND = LENCOM
        DO 10 I=IBEG,IEND
         TEST = COMLYN(I:I)
         IF (TEST .EQ. ' ') THEN
           IF (COMLYN(I+1:I+1) .EQ. ' ') THEN
               DO 20 J=I,IEND
                COMLYN(J:J) = COMLYN(J+1:J+1)
20             CONTINUE
           LENCOM = LENCOM - 1
           N = I
           GOTO 30
           ENDIF
         ENDIF
         N = I
10      CONTINUE
        LENCOM = N
        RETURN
        END
        SUBROUTINE RMVWBK  (COMLYN,LENCOM,LEN,IOFFSE )
        IMPLICIT REAL*8 (A-H,O-Z)
          INTEGER*4       IOFFSE
        CHARACTER*(*) COMLYN
C
C REMOVES A WORD FROM A COMMAND LINE BEGINNING FROM THE LAST CHARACTER
C  OF THE WORD
C  COMLYN - COMMAND LINE
C  LENCOM - LENGTH OF COMMAND LINE
C  LEN - LENGTH OF WORD TO BE REMOVED
C  IOFFSET - INDEX OF LAST CHARACTER OF WORD
        IOFF1 = IOFFSE
        IBEG = IOFF1 - LEN
        IEND = IOFF1
        COMLYN(IBEG:IOFF1) = ' '
        CALL COMPRE (COMLYN,LENCOM)
        RETURN
        END
        SUBROUTINE RMVWFD  (COMLYN,LENCOM,LEN,IOFFSE )
        IMPLICIT REAL*8 (A-H,O-Z)
          INTEGER*4       IOFFSE
        CHARACTER*(*) COMLYN
C
C REMOVES A WORD FROM A COMMAND LINE BEGINNING WITH THE FIRST CHARACTER
C  OF THE WORD
C  COMLYN - COMMAND LINE
C  LENCOM - LENGTH OF COMMAND LINE
C  LEN - LENGTH OF WORD TO BE REMOVED
C  IOFFSET - INDEX OF FIRST CHARACTER OF WORD
        IOFF1 = IOFFSE  + LEN + 1
        IBEG = IOFF1 - LEN
        COMLYN(IBEG:IOFF1) = ' '
        CALL COMPRE (COMLYN,LENCOM)
        RETURN
        END
        INTEGER FUNCTION LCRMST (COMLYN,LENCOM,STRING,LEN1,OPTION,LEN2)
        IMPLICIT REAL*8 (A-H,O-Z)
          INTEGER*4       IOFFSE
          INTEGER*4       IOFFBE
C
C  FUNCTION WHICH DETERMINES IF A WORD (OR A FRACTIONAL PART ) EXISTS
C   THE VALUE RETURNED IS THE INDEX OF THE LAST CHARACTER OF THE WORD
C   COMLYN - COMMAND LINE
C   LENCOM - LENGTH OF LINE
C   STRING - THE FIRST LEN1 CHARACTERS WHICH MUST OCCUR FOR THE WORD TO
C            BE FOUND
C   OPTION - AN OPTIONAL EXTENSION OF THE WORD - SOME OF IT MAY OR MAY
C            NOT EXIST ( E.G. IF STRING IS 'BIG' AND 'GER' IS OPTIONAL
C            'BIGGEST' WOULD NOT BE FOUND BUY BIG,BIGG,BIGGE,OR BIGGER
C            COULD ALL BE FOUND
C
        CHARACTER*(*) COMLYN,STRING,OPTION
        CHARACTER*(800) NXTWD
        CHARACTER*1 SPACE
        IOFF = 0
        LCRMST  = 0
        IF (LENCOM .LE. 0) RETURN
CTTN    SPACE = CHAR(32)
CMSP    SPACE = CHAR(64)
CCYB    SPACE = CHAR(32)
CVAX    SPACE = CHAR(32)
        IOFFSE  = 1
        IOFFBE  = 1
C FIND THE MANDATORY PART OF THE KEYWORD IN COMLYN
20      IF (IOFFBE  .GT. LENCOM) RETURN
        IOFF = INDEX(COMLYN(IOFFBE :LENCOM),STRING) + IOFFBE  - 1
C IOFF IS 0 IF IT IS NOT THERE
        IF (IOFF .EQ. 0) RETURN
C IF THE PRECEDING CHARACTER IN THE COMMAND LINE IS NOT A BLANK
C    THEN THIS IS THE MIDDLE OF A WORD
       IF (IOFF .GT. 1) THEN
C       TRY AGAIN IF THIS IS IN THE MIDDLE OF A WORD
        IOFFM1 = IOFF - 1
        IF (COMLYN(IOFFM1:IOFFM1) .NE. SPACE) THEN
         IOFFBE  = IOFF + 1
         GOTO 20
        ENDIF
       ENDIF
C LTEST WOULD BE THE MAXIMUM LENGTH OF THE STRING+OPTION + THE OFFSET
C   OF STRING + 1 TO ACCOUNT FOR SPACE AFTER ALL WORDS
        LTEST = LEN1 + LEN2 + IOFF + 1
        IF (LTEST .GT. LENCOM) LTEST = LENCOM
        LBEGIN = IOFF + LEN1
        IF (LBEGIN .GT. LENCOM) LBEGIN = LENCOM
C SEARCH FOR OPTION IN COMLYN
C   FIND FIRST SPACE AFTER STRING BUT BEFORE THE END OF OPTION
        IOFF2 = INDEX(COMLYN(LBEGIN:LTEST),SPACE)
C IF THERE IS NO SPACE THEN THE REST OF THE WORD AFTER STRING MUST
C   BE LONGER THAN OPTION THEREFORE THIS CAN'T BE WORD WE ARE LOOKING FO
        IF (IOFF2 .EQ. 0) THEN
           IF (LTEST .GE. LENCOM) THEN
             IOFF2 = LENCOM - IOFF - LEN1 + 2
             LTEST = LENCOM
           ELSE
             RETURN
           ENDIF
        ENDIF
        IENDWD = IOFF2 + IOFF + LEN1 - 1
C  FILL NXTWD WITH THE PORTION OF COMLYN WHICH WOULD CORRESPOND TO OPTIO
        NXTWD = COMLYN(LBEGIN:IENDWD)
C NDIFF IS THE NUMBER OF CHARACTERS BEFORE THE NEXT SPACE
        NDIFF = IOFF2 - 1
C SEARCH CHAR. BY CHAR. THROUGH NXTWD TO MAKE SURE THAT IT CORRESPONDS T
C   OPTION - NOTE THAT NOT ALL OF OPTION MUST EXIST
        DO 10 I=1,NDIFF
          IF (NXTWD(I:I) .NE. OPTION(I:I)) RETURN
10      CONTINUE
C CALCULATE THE OFFSET TO THE END OF THE WORD WHICH ACTUALLY IS IN THE L
           IOFFSE  = IOFF + LEN1 + NDIFF
C CALCULATE LENGTH OF WORD IN LINE (INCLUDE ROOM FOR SPACE AT END OF WOR
           LTOT = IOFFSE  - IOFF + 1
C REMOVE THE WORD FROM LINE
           CALL RMVWBK  (COMLYN,LENCOM,LTOT,IOFFSE )
           IOFFSE  = IOFFSE  - LTOT
C PUT VALUE OF OFFSET IN VALUE OF FUNCTION
           LCRMST  = IOFFSE
        IF (IOFFSE  .EQ. 0) LCRMST  = 1
           RETURN
           END
        SUBROUTINE GETNXT  (COMLYN,LENCOM,STRING,LEN1,OPTION,LEN2,
     *                      RETSTR,LEN)
        IMPLICIT REAL*8 (A-H,O-Z)
C
C GETS THE NEXT STRING -
C  COMLYN - COMMAND LINE
C  LENCOM - LENGTH OF COMMAND LINE
C  STRING - SEARCHES FOR THIS STRING OF LENGTH, LEN1
C  OPTION - OPTIONAL PORTION OF STRING, LENGTH = LEN2
C  RETSTR - STRING TO BE RETURNED, LENGTH = LEN
C
        CHARACTER*(*) COMLYN,STRING,OPTION
        CHARACTER*(*) RETSTR
        CHARACTER*1 DELIM
        DELIM = ' '
        RETSTR = ' '
        CALL COMPRE (COMLYN,LENCOM)
        IOFF1 = LCRMST (COMLYN,LENCOM,STRING,LEN1,OPTION,LEN2)
        IF (IOFF1 .GE. LENCOM) RETURN
        IF (IOFF1 .GT. 0) THEN
          IF (COMLYN(IOFF1:IOFF1) .EQ. ' ') IOFF1 = IOFF1 + 1
          CALL NEWWD(COMLYN,LENCOM,RETSTR,IOFF1,LEN,DELIM)
        ELSE
         RETURN
        ENDIF
        RETURN
        END
        SUBROUTINE NEWWD(COMLYN,LENCOM,STRING,IOFFSE ,LENGTH,DELIM)
        IMPLICIT REAL*8 (A-H,O-Z)
          INTEGER*4       IOFFSE
          INTEGER*4       LENGTH
C
C RETURNS A WORD (ALL CHARACTERS UP TO A DELIMITER)
C  COMLYN - COMMAND LINE
C  LENCOM - LENGTH OF COMMANDLINE
C  STRING - NEXT WORD
C  IOFFSET - BEGINNING OF WORD IN COMLYN
C  LENGTH - LENGTH OF WORD RETURNED
C  DELIM - DELIMITER
C
        CHARACTER*(*) COMLYN,STRING,DELIM
        IF (LENCOM .EQ. 0) THEN
          STRING = ' '
          RETURN
        ENDIF
        LENGTH = INDEX(COMLYN(IOFFSE :LENCOM),DELIM)
C IF THERE IS NO SPACE AT END OF LINE GET ALL CHARACTERS TO END OF LINE
         IF (LENGTH .EQ. 0) THEN
           LENGTH = LENCOM - IOFFSE  + 1
          ENDIF
        IEND = IOFFSE  + LENGTH - 1
C
C  PROTECT AGAINST READING IN A WORD WHICH IS TOO LONG TO FIT IN STRING
C
        IF (LEN(STRING) .LT. LENGTH) THEN
          LENGTH  = LEN(STRING)
          IENDN = IOFFSE  + LENGTH  - 1
        ELSE
          LENGTH  = LENGTH
          IENDN = IEND
        ENDIF
        STRING = COMLYN(IOFFSE :IENDN)
        CALL RMVWBK  (COMLYN,LENCOM,LENGTH,IEND)
        RETURN
        END
        SUBROUTINE GETPAF  (COMLYN,LENCOM,STRING,LEN1,OPTION,LEN2,FVALU)
        IMPLICIT REAL*8 (A-H,O-Z)
C FINDS A FLOATING POINT PARAMETER AFTER A STRING
C  COMLYN,LENCOM - COMMAND LINE & ITS LENGTH
C  STRING - STRING TO BE SEARCHED FOR TO LOCATE PARAMETER
C  OPTION - OPTIONAL STRING WHICH MAY BE PRESENT
C  LEN1,LEN2 - LENGTH OF STRING AND OPTION, RESPECTIVELY
C  FVALU - VALUE OF THE PARAMETER TO BE RETURNED
C
        CHARACTER*(*) COMLYN,STRING,OPTION
        CHARACTER*80 RETSTR
        CALL GETNXT  (COMLYN,LENCOM,STRING,LEN1,OPTION,LEN2,RETSTR,LEN)
        IF (RETSTR .EQ. ' ') RETURN
C       FVALU = DECODF(RETSTR,LEN)
        CALL DCWORK(RETSTR,1,IOUT,ROUT)
        FVALU = ROUT
        RETURN
        END
        SUBROUTINE GETPAI  (COMLYN,LENCOM,STRING,LEN1,OPTION,LEN2,NVALU)
        IMPLICIT REAL*8 (A-H,O-Z)
C GETS AN INTEGER PARAMETER VALUE
C  COMLYN,LENCOM - COMMAND LINE & ITS LENGTH
C  STRING - STRING TO BE SEARCHED FOR TO LOCATE PARAMETER
C  OPTION - OPTIONAL STRING WHICH MAY BE PRESENT
C  LEN1,LEN2 - LENGTH OF STRING AND OPTION, RESPECTIVELY
C  NVALU - VALUE OF THE PARAMETER TO BE RETURNED
C
        CHARACTER*(*) COMLYN,STRING,OPTION
        CHARACTER*80 RETSTR
        CALL GETNXT  (COMLYN,LENCOM,STRING,LEN1,OPTION,LEN2,RETSTR,LEN)
        IF (RETSTR .EQ. ' ') RETURN
        CALL DCWORK(RETSTR,0,IOUT,ROUT)
C       NVALU = DECODI(RETSTR,LEN)
        NVALU = IOUT
        RETURN
        END
        SUBROUTINE NXTWRD(COMLYN,LENCOM,STRING,NLENG)
        IMPLICIT REAL*8 (A-H,O-Z)
          INTEGER*4       IOFFSE
C
C RETURNS A WORD OF LENG NLENG, DELETES FULL WORD
C   COMLYN - COMMAND LINE
C   LENCOM - LENGTH OF COMMAND LINE
C   STRING - WORD TO BE RETURNED
C   NLENG - NUMBER OF CHARACTERS IN STRING
C
        CHARACTER*(*) COMLYN,STRING
        CHARACTER*(80) TEMP
        CHARACTER*(1) SPACE
C
        SPACE = ' '
C
        STRING(1:NLENG) = ' '
        TEMP(1:NLENG) = ' '
C
        CALL TRIMST (COMLYN,LENCOM)
        IOFFSE  = 1
        CALL NEWWD(COMLYN,LENCOM,TEMP,IOFFSE ,LEN,SPACE)
        IF (NLENG .GT. LEN) THEN
          NTEMP = LEN
        ELSE
          NTEMP = NLENG
        ENDIF
        STRING(1:NTEMP) = TEMP(1:NTEMP)
        RETURN
        END
        SUBROUTINE CNVSTB (WD,NEXTWD,LENWD)
        IMPLICIT REAL*8 (A-H,O-Z)
C
C  CONV CHAR *1 ARRAY(LENWD) TO CHAR *LENWD ARRAY
C
        CHARACTER*1 WD
        CHARACTER*(*) NEXTWD
        DIMENSION WD(LENWD)
        NEXTWD=' '
        DO 10 I=1,LENWD
          NEXTWD(I:I)=WD(I)
 10     CONTINUE
        RETURN
        END
        SUBROUTINE TRIMST (STRING,LENCOM)
        IMPLICIT REAL*8 (A-H,O-Z)
C
C TRIMS LEADING BLANK FROM STRING
C  LENCOM IS LENGTH OF STRING
C
        CHARACTER*(*) STRING
        CHARACTER*1 NULL
        IF (LENCOM .EQ. 0) RETURN
        NULL = CHAR(0)
        IOLD = LENCOM
C
C REMOVE PRECEDING BLANKS
C
        DO 20 J=1,IOLD
         IF (STRING(1:1) .EQ. ' ' .OR. STRING(1:1) .EQ. NULL) THEN
         DO 10 I=1,LENCOM
10        STRING(I:I) = STRING(I+1:I+1)
          LENCOM = LENCOM - 1
        ELSE
          IOLD1 = LENCOM
          DO 30 K=IOLD1,1,-1
           IF (STRING(K:K) .EQ. ' ' .OR. STRING(K:K) .EQ. NULL) THEN
            STRING(K:K) = NULL
            LENCOM = LENCOM - 1
           ELSE
            RETURN
           ENDIF
30        CONTINUE
        ENDIF
20      CONTINUE
        RETURN
        END
        SUBROUTINE GTRMST (COMLYN,LENCOM,STRING,LEN1,OPTION,LEN2,
     *                      RETSTR,DELIM,LENGTH)
        IMPLICIT REAL*8 (A-H,O-Z)
C
C GETS THE NEXT STRING -
C  COMLYN - COMMAND LINE
C  LENCOM - LENGTH OF COMMAND LINE
C  STRING - SEARCHES FOR THIS STRING OF LENGTH, LEN1
C  OPTION - OPTIONAL PORTION OF STRING, LENGTH = LEN2
C  RETSTR - STRING TO BE RETURNED, LENGTH = LEN
C  DELIM -  DELIMITER FOR STRING
        CHARACTER*(*) COMLYN,STRING,OPTION
        CHARACTER*(*) RETSTR
        CHARACTER*(*) DELIM
        RETSTR = ' '
        CALL COMPRE (COMLYN,LENCOM)
        IOFF1 = LCRMST (COMLYN,LENCOM,STRING,LEN1,OPTION,LEN2)
        IF (IOFF1 .GE. LENCOM) RETURN
        IF (IOFF1 .GT. 0) THEN
          IF (COMLYN(IOFF1:IOFF1) .EQ. ' ') IOFF1 = IOFF1 + 1
          CALL NEWWD(COMLYN,LENCOM,RETSTR,IOFF1,LENGTH,DELIM)
C GET RID OF THE DELIMITER FROM RETSTR
        LDEL = LEN(DELIM)
         IF (RETSTR(LENGTH-LDEL+1:LENGTH) .EQ. DELIM) THEN
          RETSTR(LENGTH-LDEL+1:LENGTH) = ' '
          LENGTH = LENGTH - LDEL
         ENDIF
        ELSE
         RETURN
        ENDIF
        RETURN
        END
        SUBROUTINE GETRES (IRES,IOUT)
        IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (COMMAND)
CTTN  INCLUDE '/labo/qclib/inspidas/common/command'
C
C   RETURNS THE VALUE, IRES, AFTER THE NEXT OCCURENCE OF RESNUMBER IN TH
C    COMMAND LINE
C
C     EVENTUALLY THIS ROUTINE SHOULD ALSO TRANSLATE INSERTION/DELETION/C
C       CODES
        CALL GETPAI  (COMLY2 ,COMLEN,'RESN',4,'UMBER',5,IRES)
        RETURN
        END
C------------------------------------------
        SUBROUTINE GETATN (INAME,IOUT)
        IMPLICIT REAL*8 (A-H,O-Z)
CMSP  INCLUDE (COMMAND)
CTTN  INCLUDE '/labo/qclib/inspidas/common/command'
        CHARACTER*(*) INAME
C
C   RETURNS THE VALUE, INAME , AFTER THE NEXT OCCURENCE OF ATOMNAME IN T
C    COMMAND LINE
C   INAME IS THE CHARACTER NAME OF THE ATOM WHICH IS ACTUALLY FOUND IN T
C    COMMAND LINE
C
        LENGTH = 0
         CALL GTRMST (COMLY2 ,COMLEN,'ATOM',4,'NAME',4,INAME,' ',LENGTH)
        IF (LENGTH .EQ. 0) THEN
          CALL GTRMST (COMLY2 ,COMLEN,'ATNA',4,'ME',2,INAME,' ',LENGTH)
        ENDIF
        RETURN
        END
        SUBROUTINE GETFIL  (FILNAM)
        IMPLICIT REAL*8 (A-H,O-Z)
          INTEGER*4       MATMTY
          INTEGER*4       MPLT1D
          INTEGER*4       MPLT2D
          INTEGER*4       MSUBTY
          INTEGER*4       MCONTU
          INTEGER*4       MCHWOR
          INTEGER*4       MPTSST
C
C  RETRIEVES A FILE NAME FROM A COMMAND LINE AFTER THE WORD 'FILE'
C
CMSP  INCLUDE (MAXSIZE)
CTTN  INCLUDE '/labo/qclib/inspidas/common/maxsize'
CMSP  INCLUDE (COMMAND)
CTTN  INCLUDE '/labo/qclib/inspidas/common/command'
C
        CHARACTER*(*) FILNAM
C
        FILNAM = ' '
        CALL GETNXT  (COMLY2 ,COMLEN,'FILE',4,'NAME',4,FILNAM,LENGTH)
C
        RETURN
        END
C*MODULEENCODE.F *DECK XYAPPD.F
C
C     APPENDS TWO FORTRAN STRINGS, (BETTER THAN BUILTIN APPEND)
C
      SUBROUTINE XYAPPD(FRONT,UTXT,ALL)
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*(*) FRONT,UTXT,ALL
      CALL XYLSCH(UTXT,IONE)
      FRONT=' '
      DO 100 I=1,IONE
         FRONT(I:I)=UTXT(I:I)
 100  CONTINUE
      CALL XYLSCH(ALL,ITWO)
      DO 200 I=1,ITWO
         FRONT(I+IONE:I+IONE)=ALL(I:I)
 200  CONTINUE
      RETURN
      END
C*MODULE ENCODE.F *DECK XYDELCH.F
C
C XYDELCH: DELETES FROM A STRING A RANGE OF CHARACTER
C
       SUBROUTINE XYDELC (TXT,ISTART,ISIZE)
       IMPLICIT REAL*8 (A-H,O-Z)
       CHARACTER*(*) TXT
       CALL XYLSCH(TXT,IMAX)
       DO 100 I=ISTART,IMAX-ISIZE
           TXT(I:I)=TXT(I+ISIZE:I+ISIZE)
 100   CONTINUE
       DO 200 I=IMAX-ISIZE+1,IMAX
           TXT(I:I)=' '
 200   CONTINUE
       RETURN
       END
C*MODULEENCODE.F *DECK XYITOC.F
C
C     CONVERTS AN INTEGER TO A STRING.
C     IVAL IS THE INTEGER TO CONVERT
C     STR IS THE STRING VARABLE TO PUT THE RESULT
C     ISIZE IS THE MAXIMUM SIZE THAT THE RESULT IS ALLOWED TO BE
C
       SUBROUTINE XYITOC(IVAL,STR,ISIZE)
       IMPLICIT REAL*8 (A-H,O-Z)
       CHARACTER*(*) STR
       CHARACTER*40 DIGITS
       CHARACTER*1 K
       INTVAL=ABS(IVAL)
       I=1
       DIGITS='0123456789'
       IF (IVAL.EQ.0) THEN
          STR='0'
       ELSE
          STR(1:1)=' '
 100      I=I+1
          ID = MOD(INTVAL,10)
          STR(I:I)=DIGITS(ID+1:ID+1)
          INTVAL = INTVAL / 10
          IF (INTVAL.NE.0 .AND. I.LE.ISIZE) GOTO 100
          J=1
          IOLD=I
 200      IF (J.LT.I) THEN
             K=STR(I:I)
             STR(I:I)=STR(J:J)
             STR(J:J)=K
             I=I-1
             J=J+1
             GOTO 200
          ENDIF
       ENDIF
       RETURN
       END
C*MODULEENCODE.F*DECK XYITOS.F
C
C     CONVERTS A REAL NUMBER TO A STRING, I1 AND I2 ARE THE FIELD SIZES
C     ILEN IS RETURNED AS THE SIZE OF THE RESULTING STRING
C     IFRMT CONTROLS IF NORMAL OF SCIENTIFIC NOTIONS IS TO BE USED
C
       SUBROUTINE XYITOS(X,RESULT,ILEN,IFRMT,I1,I2)
       IMPLICIT REAL*8 (A-H,O-Z)
       CHARACTER*(*) RESULT
       CHARACTER*40 PART1,PART2,PART3
       PART1=' '
       IF (IFRMT.GT.0) THEN
          WRITE(PART1,1) X
 1        FORMAT(1E16.8)
       ELSE
          WRITE(PART1,2) X
 2        FORMAT(1F16.8)
       ENDIF
       I=1
 100   IF (PART1(I:I).EQ.' '.AND.I.LT.32) THEN
          I=I+1
          GOTO 100
       ENDIF
       ILOC=1
       PART2=' '
       PART3=' '
       IEFLAG=0
       IDFLAG=0
       CALL XYLSCH(PART1,ILEN)
 200   IF (ILOC.LT.(I1+I2).AND.I.LT.ILEN) THEN
          IF (PART1(I:I).EQ.'.') IDFLAG=1
          IF (PART1(I:I).EQ.'E') IEFLAG=1
          PART2(ILOC:ILOC)=PART1(I:I)
          ILOC=ILOC+1
          I=I+1
          GOTO 200
       ENDIF
       IF (IFRMT.GT.0.OR.IEFLAG.EQ.1) THEN
          IF (IEFLAG.EQ.0) THEN
 300         IF (PART1(I:I).NE.'E'.AND.I.LT.ILEN) THEN
                I=I+1
                GOTO 300
             ENDIF
          ENDIF
 400      IF (I.LE.ILEN) THEN
             PART2(ILOC:ILOC)=PART1(I:I)
             ILOC=ILOC+1
             I=I+1
             GOTO 400
          ENDIF
       ELSE IF (IFRMT.EQ.0) THEN
          IF (IDFLAG.EQ.0) THEN
             CALL XYAPPD(PART3,'ERR',PART2(1:(I1+I2)-3))
          ENDIF
       ENDIF
       CALL XYLSCH(PART2,ILEN)
       RESULT=PART2
       RETURN
       END
C
C RETURNS LENGHT OF STRING, (ASSUMES STRING ENDS IN
C SPACES OR NULLS)
C
       SUBROUTINE XYLSCH(UTXT,ILGTH)
       IMPLICIT REAL*8 (A-H,O-Z)
       CHARACTER*(*) UTXT
       IACTU=LEN(UTXT)
       ILGTH=IACTU
 100   IF ((UTXT(ILGTH:ILGTH).EQ.' ' .OR. UTXT(ILGTH:ILGTH).EQ.CHAR(0))
     1  .AND. ILGTH.GT.1 ) THEN
           ILGTH=ILGTH-1
           GOTO 100
       ENDIF
       RETURN
       END
C*MODULEENCODE.F *DECK TENLOG.F
C
C     RETURNS LOGS BASE 10 (VERSES NATURAL LOGS)
C
CFH    REAL*8 FUNCTION TENLOG(X)
       DOUBLE PRECISION FUNCTION TENLOG(X)
       IMPLICIT REAL*8 (A-H,O-Z)
       VAL=1.0D0
       IF (X.GT.0.0) THEN
          VAL=LOG(X)/LOG(10.0D0)
       ENDIF
       TENLOG=VAL
       RETURN
       END
C
       SUBROUTINE XYRTOC(X,RESULT,ISZ,I1,I2)
       IMPLICIT REAL*8 (A-H,O-Z)
          REAL*8          DILIMI
       CHARACTER*(*) RESULT
       CHARACTER*40 FRONT,BACK,ALL
       DATA TEN/10.0D+00/
       ALL=' '
       FRONT=' '
       BACK=' '
       IF (X.LE.-1.0D0) THEN
          SIGN=-1.0D0
          X=X
       ELSE
          SIGN=1.0D0
       ENDIF
       ISZ=0
       RTEMP=X
       ILIMIT=I1+I2
       DILIMI  = DFLOAT(ILIMIT)
       IF (DABS(RTEMP).GE.TEN**DILIMI ) THEN
 50       IF (DABS(RTEMP).GT.TEN**DILIMI ) THEN
             RTEMP=RTEMP/TEN
             ISZ=ISZ+1
             GOTO 50
          ENDIF
          IPARTA=INT(RTEMP+0.1*SIGN)
          CALL XYITOC(IPARTA,FRONT,ILIMIT)
          BACK='0'
       ELSE IF (DABS(RTEMP).LE.TEN**(-DILIMI )) THEN
          ISZ=I2
 100      IF (DABS(RTEMP).LT.TEN**(-DILIMI )) THEN
             RTEMP=RTEMP*TEN
             ISZ=ISZ-1
             GOTO 100
          ENDIF
          IPARTA=INT(RTEMP*TEN**DILIMI )
          CALL XYITOC(IPARTA,BACK,ILIMIT)
          FRONT='0'
       ELSE
          IPARTA=(RTEMP+0.1D+00*SIGN)
          CALL XYITOC(IPARTA,FRONT,ILIMIT)
          IPARTB=((RTEMP-IPARTA)*TEN**DILIMI )
          CALL XYITOC(IPARTB,BACK,ILIMIT)
       ENDIF
       CALL XYLSCH(FRONT,J)
       ALL=' '
       DO 200 I=I1,J
          FRONT(I:I)=' '
          ISZ=ISZ+1
 200   CONTINUE
       CALL XYLSCH(BACK,K)
       DO 300 I=I2,K
          BACK(I:I)=' '
C          ISZ=ISZ+1
 300   CONTINUE
       ALL=' '
       CALL XYLSCH(FRONT,J)
       DO 400 I=1,J
          ALL(I:I)=FRONT(I:I)
 400   CONTINUE
       ILOC=J+1
       ALL(ILOC:ILOC)='.'
       ILOC=ILOC+1
       CALL XYLSCH(BACK,K)
       DO 500 I=1,K
          ALL(ILOC:ILOC)=BACK(I:I)
          ILOC=ILOC+1
 500   CONTINUE
       IF (X.LT.0) THEN
          CALL XYAPPD(FRONT,'-',ALL)
          ALL=FRONT
       ENDIF
       IF (SIGN.LT.0) THEN
          X=X+1.0D0
       ENDIF
       RESULT=ALL
       RETURN
       END
        SUBROUTINE CENLIN(STRING,IOUT,IWIDTH)
        IMPLICIT REAL*8 (A-H,O-Z)
        CHARACTER*(*) STRING
        CHARACTER*80 TEMP,FORM
        CHARACTER*(10) NUMCHA ,LENCHA
        CHARACTER*1 XX,COMMA
C
C WRITES OUT STRING TO IOUT ON A CENTERED LINE 80 CHARACTER LINE
C   ADDS A PRECEDING AND TRAILING BLANK LINE
C
         XX = 'X'
         COMMA = ','
         IF (IWIDTH .EQ. 0) THEN
          IWIDTH = 80
         ENDIF
         LENGTH = LEN(STRING)
         CALL TRIMST (STRING,LENGTH)
         IDIF = IWIDTH - LENGTH
         ISPAC = IDIF/2
         NSIZE = 0
         NSIZE1 = 0
         CALL ENCODI(ISPAC,NUMCHA ,10,NSIZE1)
         CALL ENCODI(LENGTH,LENCHA ,10,NSIZE)
         TEMP(1:1) = '('
         NSIZE2 = NSIZE1 + 2
         TEMP(2:NSIZE1+1) = NUMCHA
         TEMP(NSIZE2:NSIZE2)= XX
         NSIZE2 = NSIZE2 + 1
         TEMP(NSIZE2:NSIZE2) = COMMA
         NSIZE2 = NSIZE2 + 1
         TEMP(NSIZE2:NSIZE2) = 'A'
         FORM = TEMP(1:NSIZE2)//LENCHA (1:NSIZE)
         IEND = NSIZE2 + NSIZE + 1
         FORM(IEND:IEND) = ')'
         WRITE(IOUT,*)
         WRITE(IOUT,FORM) STRING(1:LENGTH)
         WRITE(IOUT,*)
         RETURN
         END
